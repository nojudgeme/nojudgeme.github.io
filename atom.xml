<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nojudgeme.github.io</id>
    <title>Huffman&apos;s Study Area</title>
    <updated>2021-04-09T02:59:47.291Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nojudgeme.github.io"/>
    <link rel="self" href="https://nojudgeme.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://nojudgeme.github.io/images/avatar.png</logo>
    <icon>https://nojudgeme.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Huffman&apos;s Study Area</rights>
    <entry>
        <title type="html"><![CDATA[从零开始学算法 - 队列]]></title>
        <id>https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-dui-lie/</id>
        <link href="https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-dui-lie/">
        </link>
        <updated>2021-04-09T02:42:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">s</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零开始学算法 - 栈]]></title>
        <id>https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-zhan/</id>
        <link href="https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-zhan/">
        </link>
        <updated>2021-04-09T02:42:03.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">/**
 * Functional Purpose - 栈 后进先出数据结构 LIFO(Last in First Out)
 * @date:2021-04-08 上午11:31
 * @author huffman
*/
public interface Stack&lt;E&gt; {

    /**
     * 元素入栈尾
     * @param e
     */
    void push(E e);

    /**
     * 元素出栈尾
     * @return
     */
    E pop();

    /**
     * 获取栈尾元素
     * @return
     */
    E peek();

    /**
     * 获取栈内元素总个数
     * @return
     */
    int getSize();

    /**
     * 判断栈元素是否为空
     * @return
     */
    boolean isEmpty();
}

/**
 * Functional Purpose - 动态数组的方式实现栈
 * @date:2021-04-08 上午11:54
 * @author huffman
*/
public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt;{

    private final Arrays&lt;E&gt; arrays;

    public ArrayStack() {
        arrays = new Arrays&lt;&gt;();
    }

    public ArrayStack(int capacity){
        arrays = new Arrays&lt;&gt;(capacity);
    }

    @Override
    public void push(E e) {
        arrays.addLast(e);
    }

    @Override
    public E pop() {
        return arrays.removeLast();
    }

    @Override
    public E peek() {
        return arrays.getLastElement();
    }

    @Override
    public int getSize() {
        return arrays.getSize();
    }

    @Override
    public boolean isEmpty() {
        return arrays.isEmpty();
    }

    public int getCapacity(){
        return arrays.getCapacity();
    }

    @Override
    public String toString() {
        return &quot;ArrayStack{&quot; +
                &quot;arrays=&quot; + arrays +
                '}';
    }

}
</code></pre>
<blockquote>
<p>注意事项:</p>
<p>1.基于动态数组实现的栈十分简单,进行栈元素操作时,直接使用动态数组提供的添加/删除元素操作,就可以实现栈元素的操作.但需要注意的是,栈是FILO(先进后出 first in last out)或者是LIFO(后进先出 last in first out),故在添加/删除栈元素时,是入头元素和出头元素.这一点与队列相反!</p>
<p>2.入栈操作叫:push;出栈操作叫:pop;查看栈顶元素:peek.</p>
<p>3.无论栈的数据结构实现是什么,用户并不关心,只用知道如何操作栈元素即可(push,pop,peek).</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零开始学算法 - 数组]]></title>
        <id>https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-shu-zu/</id>
        <link href="https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-shu-zu/">
        </link>
        <updated>2021-04-09T02:33:05.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">/**
 * Functional Purpose - 动态数组 类似java.util.ArrayList
 *
 * @author huffman
 * @date:2021-04-06 下午5:26
 */
public class Arrays&lt;E&gt; {

    /**
     * 初始化数组数据
     */
    private E[] data;

    /**
     * 数组实际容量
     */
    private int size;

    /**
     * 扩容因子
     */
    private int resizeFactor = 2;

    /**
     * 以数组e初始化数组
     *
     * @param e 数组
     */
    public Arrays(E[] e) {
        this.data = e;
    }

    /**
     * 以最大容量为capacity初始化数组
     *
     * @param capacity 最大容量
     */
    public Arrays(int capacity) {
        data = (E[]) new Object[capacity];
        size = 0;
    }

    /**
     * 以默认容量10初始化数组
     */
    public Arrays() {
        this(10);
    }

    /**
     * 数组内元素是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return this.size == 0;
    }

    /**
     * 获取实际元素个数
     *
     * @return
     */
    public int getSize() {
        return size;
    }

    /**
     * 获取最大容量大小
     */
    public int getCapacity() {
        return data.length;
    }

    /**
     * 从指定位置插入元素
     */
    public void addElement(E e, int index) {
        checkIndex(index);
        //实际存储元素的容量已经满了
        if (size == data.length) {
            resize(resizeFactor * getCapacity());
        }
        //从下标为size-1的元素开始 从后往前挪动一位元素,即index+1的元素=index的元素
        for (int i = size - 1; i &gt;= index; i--) {
            data[i + 1] = data[i];
        }
        data[index] = e;
        size++;
    }

    /**
     * 从末尾新增元素
     */
    public void addLast(E e) {
        addElement(e, size);
    }

    /**
     * 从头尾新增元素
     */
    public void addFirst(E e) {
        addElement(e, 0);
    }

    /**
     * 获取指定下标元素
     *
     * @param index
     * @return
     */
    public E getElement(int index) {
        checkIndex(index);
        return data[index];
    }

    /**
     * 获取最后一个元素
     * @return
     */
    public E getLastElement() {
        return getElement(size-1);
    }

    /**
     * 获取第一个元素
     * @return
     */
    public E getFirstElement() {
        return getElement(0);
    }

    /**
     * 修改指定下标元素为e
     *
     * @param e
     * @param index
     */
    public void setElement(E e, int index) {
        checkIndex(index);
        data[index] = e;
    }

    /**
     * 检查下标
     *
     * @param index
     */
    public void checkIndex(int index) {
        //下标不能为负且数组得是连续的元素 所以也不能大于size,不然中间会出现空缺元素
        if (index &lt; 0 || index &gt; size) {
            throw new IllegalArgumentException(&quot;AddElement failed. The index can't be less then 0 or more than capacity&quot;);
        }
    }

    /**
     * 检查数组中是否包含元素e
     *
     * @param e
     * @return
     */
    public boolean contains(E e) {
        for (int i = 0; i &lt; size; i++) {
            if (data[i].equals(e)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 寻找数组中e元素的下标,若没有则返回-1
     *
     * @param e
     * @return
     */
    public int findElement(E e) {
        for (int i = 0; i &lt; size; i++) {
            if (data[i].equals(e)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 寻找数组中所有e元素的下标
     *
     * @param e
     * @return todo:不对 需要调整或删除
     */
    @Deprecated
    public int[] findAllElements(E e) {
        int[] indexArray = new int[size];
        int index = 0;
        for (int i = 0; i &lt; size; i++) {
            if (data[i].equals(e)) {
                indexArray[index++] = i;
            }
        }
        return indexArray;
    }

    /**
     * 删除数组中指定下标的元素,返回删除后的元素
     *
     * @param index
     * @return
     */
    public E remove(int index) {
        checkIndex(index);
        E e = data[index];
        for (int i = index; i &lt; size; i++) {
            data[i] = data[i + 1];
        }
        size--;

        if (size &lt;= getCapacity() / resizeFactor / 2 &amp;&amp; getCapacity() / 2 != 0) {//懒处理 不及时缩容
            resize(getCapacity() / resizeFactor);
        }
        return e;
    }

    /**
     * 删除数组中第一个元素
     *
     * @return
     */
    public E removeFirst() {
        return remove(0);
    }

    /**
     * 删除数组中最后一个元素
     *
     * @return
     */
    public E removeLast() {
        return remove(size - 1);
    }

    /**
     * 删除一个元素e
     *
     * @param e
     */
    public void removeElement(E e) {
        if (contains(e)) {
            int index = findElement(e);
            remove(index);
        }
    }

    /**
     * 删除所有元素e
     *
     * @param e todo:不对 需要调整或删除
     */
    @Deprecated
    public void removeAllElements(E e) {
        if (contains(e)) {
            for (Integer index : findAllElements(e)) {
                remove(index);
            }
        }
    }

    @Override
    public String toString() {
        return &quot;Arrays{&quot; +
                &quot; size=&quot; + size +
                &quot;, capacity=&quot; + data.length +
                &quot;,data=&quot; + java.util.Arrays.toString(data) +
                '}';
    }

    private void resize(int newCapacity) {
        E[] newArray = (E[]) new Object[newCapacity];
        for (int i = 0; i &lt; size; i++) {
            newArray[i] = data[i];
        }
        data = newArray;
    }

}
</code></pre>
<blockquote>
<p>注意事项:</p>
<p>1.在指定下标操作元素时,要注意下标是否越界</p>
<p>2.在增加/删除元素时,要注意数组的大小,满了就扩容,少了就缩容.缩容时,要避免出现刚扩容后,立马缩容的情况,这样会增加时间复杂度,所以这里我们粗略的采用:当元素总数为容积的<strong>1/4</strong>时,进行容积的<strong>1/2</strong>缩容.</p>
<p>3.同时,增加/删除元素时,要同时维护元素总数(size)</p>
<p>4.扩容时复制元素至新数组,容量大小为 resizeFactor*capacity</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些有趣的事情]]></title>
        <id>https://nojudgeme.github.io/post/yi-xie-you-qu-de-shi-qing/</id>
        <link href="https://nojudgeme.github.io/post/yi-xie-you-qu-de-shi-qing/">
        </link>
        <updated>2021-01-18T10:12:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id=""></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[鸟哥的私房菜-Linux(基础学习篇)]]></title>
        <id>https://nojudgeme.github.io/post/niao-ge-de-si-fang-cai-linuxji-chu-xue-xi-pian/</id>
        <link href="https://nojudgeme.github.io/post/niao-ge-de-si-fang-cai-linuxji-chu-xue-xi-pian/">
        </link>
        <updated>2021-01-15T04:21:25.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/1.html">鸟哥的私房菜:基础学习篇 第四版</a><br>
<a href="https://www.processon.com/view/link/5faa4716e0b34d7a1aa28933" target="_blank"><br>
<img src="http://assets.processon.com/chart_image/5f59820c07912902cf7ed0a6.png"/><br>
</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://nojudgeme.github.io/post/about/</id>
        <link href="https://nojudgeme.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>学习交流所见所闻,分享一切有趣的事~</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>一个偶尔有技术追求的咸鱼</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>爱动漫,打游戏,健身(还没开始orz...)</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>Gmail:charles@gmail.com<br>
QQ:2451179899<br>
wx:q15172426627</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://nojudgeme.github.io/post/hello-gridea/</id>
        <link href="https://nojudgeme.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>