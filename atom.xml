<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nojudgeme.github.io</id>
    <title>Huffman&apos;s Study Area</title>
    <updated>2021-05-14T02:25:27.903Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nojudgeme.github.io"/>
    <link rel="self" href="https://nojudgeme.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://nojudgeme.github.io/images/avatar.png</logo>
    <icon>https://nojudgeme.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Huffman&apos;s Study Area</rights>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 泛型]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-fan-xing/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-fan-xing/">
        </link>
        <updated>2021-05-14T02:10:06.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1泛型是什么">1.泛型是什么</h4>
<p>在java中,泛型是指:参数化类型-即把类型当做参数传递,当调用类/方法时,传递指定类型.是一种通用的代码模板处理手段,利用泛型,可以使一套代码,多种使用方式.</p>
<h4 id="2为什么要使用泛型">2.为什么要使用泛型</h4>
<ol>
<li>使代码更加简洁，不必进行强制类型转换，避免了<code>ClassCastException</code>异常。</li>
<li>使代码更具有通用性，避免了重复代码。</li>
</ol>
<h4 id="3使用泛型">3.使用泛型</h4>
<h5 id="定义泛型">定义泛型</h5>
<pre><code class="language-java">/**
 * 泛型类
 * @param &lt;K&gt; key的类型
 * @param &lt;V&gt; value的类型
 */
public class Pair &lt;K,V&gt;{
    
    private final K key;
    private final V value;
    //编译器提示出错:org.pzzhang.generics.Pair.this' cannot be referenced from a static context,泛型使用不能在静态成员变量上
    //private static K staticProperty;

    /**
     * 无法直接通过new K/V()的方式进行初始化
     * this.key = new K(); type parameter 'K' cannot be instantiated directly
     *  his.value = new V(); type parameter 'V' cannot be instantiated directly
     *  可以采用如下两种方式进行初始化
     */

    //1.通过Object强制转换为目标类型
    public Pair() {
        this.key = (K) new Object();
        this.value = (V) new Object();
    }

    //2.通过指定K,V的class,使用Class.newInstance()方法
    public Pair(Class&lt;K&gt; kClass,Class&lt;V&gt; vClass) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        this.key = kClass.getDeclaredConstructor().newInstance();
        this.value = vClass.getDeclaredConstructor().newInstance();
    }

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    /**
     * 注意:此处的createPairs的方法与下面createPari方法并不一致
     * 此处定义的泛型K,V跟Pair.class定义的泛型K,V没有关系
     * 此处定义的泛型由返回值前面定义的&lt;K,V&gt;相关,它也可以是&lt;T,B&gt; 效果是相等的
     * 而createPair方法参数类型的K,V才是由Pair.class定义的泛型K,V,它不能是T,B,编译器会提示Cannot resolve symbol 'T,B'
     * 所以createPairs == createPairs2 != createPair
     * @return
     */
    public static &lt;K,V&gt; Pair&lt;K,V&gt; createPairs(K key,V value){
        return new Pair&lt;&gt;(key,value);
    }

    /**
     * 泛型方法 - 使用由类定义的泛型K,V
     * @param key
     * @param value
     * @return
     */
    public  Pair&lt;K,V&gt; createPair(K key, V value){
        return new Pair&lt;&gt;(key,value);
    }

    /**
     * 静态泛型方法 - 使用由方法中返回值前定义的泛型T,B;与类定义的泛型无关
     * @param key
     * @param value
     * @param &lt;T&gt;
     * @param &lt;B&gt;
     * @return
     */
    public static &lt;T,B&gt; Pair&lt;T,B&gt; createPairs2(T key,B value){
        return new Pair&lt;&gt;(key,value);
    }
    
    /*
    编译器出错,提示Cannot resolve symbol 'T,B'
    public static Pair&lt;T,B&gt; createPairs3(T key,B value){
        return new Pair&lt;&gt;(key,value);
    }*/

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }
}
</code></pre>
<h5 id="使用泛型">使用泛型</h5>
<pre><code class="language-java">public static void main(String[] args){
  Pair&lt;String, Object&gt; pair = new Pair&lt;&gt;(&quot;charles&quot;,123);
  //泛型限制了传入K,V类型只能是String,Object
  System.out.println(String.format(&quot;key:%s,value:%s&quot;,pair.getKey(),pair.getValue()));
  //key:charles,value:123
    
  Pair&lt;String, String&gt; pair2 = new Pair&lt;&gt;(&quot;锁&quot;,&quot;钥匙&quot;);
  //泛型限制了传入K,V类型只能是String,String
  System.out.println(String.format(&quot;key:%s,value:%s&quot;,pair2.getKey(),pair2.getValue()));
  //key:锁,value:钥匙
    
  Pair&lt;String, Integer&gt; pair3 = Pair.createPairs2(&quot;锁密码&quot;, 123);
  //静态泛型方法参数决定了返回值类型为String,Integer
  System.out.println(String.format(&quot;key:%s,value:%s&quot;,pair3.getKey(),pair3.getValue()));
  //key:锁密码,value:123
}
</code></pre>
<h4 id="4泛型擦除">4.泛型擦除</h4>
<h5 id="泛型擦除定义">泛型擦除定义</h5>
<p>泛型擦除是什么?泛型擦除其实就是Java实现泛型的方式.在编译阶段,编译器已经强制转型为目标类型了,如:<code>Pair&lt;K.class,V.class&gt; pair = (Pair&lt;K.class,V.class&gt;)new Pair&lt;Object,Object&gt;();</code>,在运行阶段,JVM看不到K,V了,只有Pair.class.让我们看一个例子:</p>
<pre><code class="language-java">public static void main(String[] args){
    Pair&lt;String,Object&gt; pairEx1 = new Pair&lt;&gt;();
	Pair&lt;Integer,String&gt; pairEx2 = new Pair&lt;&gt;();
	System.out.println(Pair.getClass().equals(Pair.getClass()));//true
}
//class在JVM中只有独一份,结果等于true.
//说明在运行期间JVM认为Pair&lt;String,Object&gt;==Pair&lt;Integer,String&gt;.
//即只存在一个PairExClass.
</code></pre>
<h5 id="泛型擦除后的信息">泛型擦除后的信息</h5>
<p>那么又产生了一个新的问题:发生了泛型擦除,那我在运行期还能否获取到泛型的具体类型呢?看下面的例子</p>
<pre><code class="language-java">public static void main(String[] args){
    Type pairExType = PairExClass.class.getGenericSuperclass();
    if(pairExType instanceof ParameterizedType){//判断父类Class是否是参数化类型(泛型类)
        for (Type actualTypeArgument : ((ParameterizedType) pairExType).getActualTypeArguments()) {
            System.out.println(actualTypeArgument.getTypeName());
            //输出K,V
        }
    }

    Type pairEx1Type = PairExClass1.class.getGenericSuperclass();
    if(pairEx1Type instanceof ParameterizedType){//判断父类Class是否是参数化类型(泛型类)
        for (Type actualTypeArgument : ((ParameterizedType) pairEx1Type).getActualTypeArguments()) {
            System.out.println(actualTypeArgument.getTypeName()); 
            //输出java.lang.String;java.lang.Object;
        }
    }
}
</code></pre>
<p>从上述输出结果中可以明确看到,在运行期又可以拿到泛型的信息.这是为什么?</p>
<blockquote>
<p>Pair字节码文件:</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_jetbrains-idea_20210513153421.png" alt="截图_jetbrains-idea_20210513153421" loading="lazy"></figure>
<p>可以从Pair的字节码文件中观察到:class信息上没有了泛型的信息.</p>
<p>上面的注释中signature标明了Pair的泛型信息为(K:java.lang.Object,V:java.lang.Object).</p>
<p>而declaration标明了类信息为:Pair&lt;K,V&gt;</p>
</blockquote>
<blockquote>
<p>PairExClass字节码文件:</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_jetbrains-idea_20210513153948.png" alt="截图_jetbrains-idea_20210513153948" loading="lazy"></figure>
<p>可以从PairExClass的字节码文件中观察到:class信息上没有了泛型的信息.</p>
<p>上面的注释中signature标明了PairExClass的泛型信息为(K:java.lang.Object,V:java.lang.Object).Pair的泛型信息为&lt;TK,TV&gt;</p>
<p>而declaration标明了类的继承关系:PairExClass&lt;K,V&gt; extends Pair&lt;K,V&gt;</p>
</blockquote>
<p>所以在字节码文件中,signature可以取到泛型的具体类型.如果是K,V类型没有指定的情况,返回java.lang.Object;否则返回具体的指定类型.</p>
<h5 id="不恰当的覆写方法">不恰当的覆写方法</h5>
<p>当我们编写equals方法时,编译器提示:</p>
<pre><code class="language-java">/**
 * 编译不通过,编译提示:
 * 'equals(K)' in 'org.pzzhang.generics.Pair' clashes with 'equals(Object)' in    
 * 'java.lang.Object'; both methods have same erasure, yet neither overrides the other
 * @param o
 * @return
 */
public boolean equals(K o) {
    return this == o;
}

/**
 * 编译通过
 */
public boolean equals(String str){
    return this.toString().equals(str);
}
</code></pre>
<p>可是问题是,我们的类型K又不一定会是Object,这应该算是方法的重载而不是重写.为什么会出现这样的情况?</p>
<p>是因为在发生了泛型擦除之后,没有指定的K类型如上述所说会被编译成java.lang.Object;则equals方法就和父类Object中的equals方法完全一致.那么正确的的做法是什么?</p>
<pre><code class="language-java">/**
 * 编译通过
 * 方法名不一致,避免了冲突,则自然不会重写父类的方法
 */
public boolean isSame(K v){
	return this == v;
}
</code></pre>
<h5 id="泛型的限制">泛型的限制</h5>
<p>正因为泛型擦除的存在,在编译时将泛型类型擦除为了Object,那么就会存在如下问题</p>
<ol>
<li>
<p>泛型类型不能为基础数据类型</p>
<pre><code class="language-java">/**
 * 编译不通过
 * 编译错误:Type argument cannot be of primitive type
 * class PairExClass3 extends Pair&lt;int&gt;{}
 */
</code></pre>
</li>
<li>
<p>无法获取到泛型的Class</p>
<pre><code class="language-java">Type pairEx1Type = PairExClass1.class.getGenericSuperclass();
if(pairEx1Type instanceof ParameterizedType){//判断父类Class是否是参数化类型(泛型类)
    for (Type actualTypeArgument : ((ParameterizedType) pairEx1Type).getActualTypeArguments()) {
        System.out.println(&quot;class :&quot;+actualTypeArgument.getClass());
        //输出java.lang.String;java.lang.Object;
    }
}
</code></pre>
</li>
<li>
<p>无法判断带泛型的类型</p>
<pre><code class="language-java">/**
 * 无法通过编译:Illegal generic type for instanceof
 * PairExClass&lt;String,Object&gt; pairExClass = new PairExClass&lt;&gt;();
 * System.out.println(pairExClass instanceof PairExClass&lt;String, Object&gt;);
 */
</code></pre>
</li>
<li>
<p>不能直接实例化泛型类型</p>
<pre><code class="language-java">/**
 * 无法通过编译:type parameter 'K,V' cannot be instantiated directly
 * this.key = new K();
 * this.value = new V();
 */
</code></pre>
</li>
</ol>
<h4 id="5泛型的继承关系">5.泛型的继承关系</h4>
<p>我们知道,Java中提供了关键字extends表示类的继承关系.那么能否直接通过extends继承泛型类呢?</p>
<pre><code class="language-java">/**
 * 编译通过
 * @param &lt;K&gt; 指定泛型类型为K
 * @param &lt;V&gt; 指定泛型类型为V
 */
public class PairExClass&lt;K,V&gt; extends Pair&lt;K,V&gt;{

    @Override
    public Pair&lt;K, V&gt; createPair(K key, V value) {
        return super.createPair(key, value);
    }
}

/**
 * 编译通过
 * K:指定泛型类型为String
 * V:指定泛型类型为Object
 */
class PairExClass1 extends Pair&lt;String,Object&gt;{

    /**
     * Pair的父类方法中,所有的泛型K类型都变成了String,泛型V变成了Object
     * @param key
     * @param value
     * @return
     */
    @Override
    public Pair&lt;String, Object&gt; createPair(String key, Object value) {
        return super.createPair(key, value);
    }
}

/**
 * 编译不通过
 * 编译错误:Cannot resolve symbol 'K,V'
 * class PairExClass2 extends Pair&lt;K,V&gt;{
 *     @Override
 *     public Pair&lt;K, V&gt; createPair(K key, V value) {
 *         return super.createPair(key, value);
 *     }
 * }
 */
</code></pre>
<h4 id="6泛型的通配符">6.泛型的通配符</h4>
<h5 id="extends通配符">extends通配符</h5>
<pre><code class="language-java">/**
 * extends定义泛型类
 * 泛型限制传入参数类型必须继承于Number
 * @param &lt;N&gt; 参数类型
 */
public class PairGenericExClass &lt;N extends Number&gt;{

    private final N key;

    public PairGenericExClass(N key) {
        this.key = key;
    }

     /**
     * extends定义泛型方法参数
     */
    public boolean containKeyOrAddKey(List&lt;? extends Integer&gt; list){
        for (Integer integer : list) {
            if(integer.equals(key)) return true;
        }
        // 编译错误,无法添加: Required type:capture of ? extends Integer
        //Integer key = (Integer) this.key;
        //list.add(key);
        return false;
    }
    
    public static void main(String[] args){
        PairGenericExClass&lt;Integer&gt; integerPair = new PairGenericExClass&lt;&gt;(123);
        PairGenericExClass&lt;Double&gt; doublePair = new PairGenericExClass&lt;&gt;(123d);
        //编译错误,Type parameter 'java.lang.String' is not within its bound; should extend 'java.lang.Number'
        //PairGenericExClass&lt;String&gt; stringPair = new PairGenericExClass&lt;&gt;(&quot;123&quot;);
       System.out.println(integerPair.containKeyOrAddKey(Arrays.asList(123,456)));//true
    } 
}
</code></pre>
<p>显而易见:</p>
<ol>
<li>
<p>在使用extends修饰泛型类时,限制了泛型类型只能是Number以及Number的子类,String无法通过编译;</p>
</li>
<li>
<p>在使用extends修饰方法泛型参数时,可以获取到list所有元素,但限制了对list元素进行修改操作.(只读)</p>
</li>
</ol>
<h5 id="super通配符">super通配符</h5>
<pre><code class="language-java">/**
 * 编译错误:不支持的语法
 * class PairGenericSuClass2 &lt;P super Number&gt;{}
 */
public class PairGenericSuClass{

    private final Integer key;
    private final Integer value;

    public PairGenericSuClass(Integer key, Integer value) {
        this.key = key;
        this.value = value;
    }

    public Pair resetPair(Pair&lt;? super Integer,? super Integer&gt; pair) {
        return pair.createPair(key,value);
    }


    public static void main(String[] args){
        PairGenericSuClass pairGenericSuClass = new PairGenericSuClass(5, 7);
        Pair pair = pairGenericSuClass.resetPair(new Pair&lt;&gt;());
        System.out.println(&quot;pair key:&quot;+pair.getKey()+&quot;,pair value:&quot;+pair.getValue());
        //pair key:5,pair value:7
        Pair pair2 = pairGenericSuClass.resetPair(new Pair&lt;&gt;());
        System.out.println(&quot;pair2 key:&quot;+pair2.getKey()+&quot;,pair2 value:&quot;+pair2.getValue());
        //pair2 key:5,pair2 value:7

        //虽然我们明确知道pair.getKey()的值是int类型,但由于它既可能是int类型,还可以是Number类型,甚至是Object类型
        //所以我们只能通过Object去接受它,否则编译器会提示Provide type:Object,Required type:Integer,无法通过编译
        //Integer key = pair.getKey();
    }
}
</code></pre>
<p>显而易见:</p>
<ol>
<li>
<p>super无法像extends那样修饰泛型类</p>
</li>
<li>
<p>super修饰方法泛型参数时,可以修改原Pair泛型为&lt;? super Integer&gt;的key,value值.但无法正确接收key,value,只能用Object类型接收.(只写)</p>
</li>
</ol>
<h5 id="pecs原则">PECS原则</h5>
<p>为了方便记忆extends与super的区别,我们引入一个概念<code>PECS:Producer Extends Consumer Super</code>.</p>
<p>即:如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符.</p>
<pre><code class="language-java">public class Collections {
    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
        for (int i=0; i&lt;src.size(); i++) {
            T t = src.get(i); // src是producer
            dest.add(t); // dest是consumer
        }
    }
}
</code></pre>
<h5 id="通配符">? 通配符</h5>
<pre><code class="language-java">/**
 * 编译错误:不支持的语法
 * class PairGenericUnlimitedClass &lt;?&gt;{}
 */
public class PairGenericUnlimitedClass&lt;T&gt; {

    private final List&lt;T&gt; list;

    public PairGenericUnlimitedClass(List&lt;T&gt; list) {
        this.list = list;
    }

    public static boolean isEmpty(List&lt;?&gt; list){
        return list.size() == 0;
    }

    public static void addElementIfEmpty(List&lt;?&gt; list){
        if(isEmpty(list)){
            //无法通过编译:Required type:capture of ? Provided:int
            //list.add(123);
        }
        Object o = list.get(1);//无法拿任何类型去接受它,只有Object
    }

    public static void main(String[] args){
        PairGenericUnlimitedClass&lt;Integer&gt; pair = new PairGenericUnlimitedClass&lt;&gt;(Arrays.asList(123, 456, 789));
        PairGenericUnlimitedClass&lt;?&gt; newPair = pair;//编译通过
    }
}
</code></pre>
<p>结论:</p>
<ol>
<li>?不能修饰泛型类</li>
<li>?是泛型T的超类</li>
<li>?具有<code>extends</code>和<code>super</code>的特征(无法写;无法读),因为无法读写,一般只能用来判空,所以我们一般用的更多的是直接使用<code>泛型T</code>替代<code>?</code>通配符;</li>
</ol>
<h5 id="不可读与不可写">不可读与不可写</h5>
<p>关于读写问题解读,我的理解是:</p>
<p><strong>不可写</strong>:</p>
<p>可读:当使用<code>? extends T</code>时,<code>泛型T</code>为所有的类型顶点,所有类型都可以向上转型至<code>T类型</code>,我们可以直接这样写<code>T t = ?</code>,拿<code>T类型</code>去接收实例,跟面向接口编程的思想一致,都拿接口去接收实例.那自然都可读,都当做<code>T类型</code>处理.</p>
<p>不可写:假设<code>T类型</code>为<code>Number类型</code>,那么我即可以写入<code>Integer类型</code>,也可以写入<code>Double类型</code>,但是很明显<code>T类型(Number)</code>它不可能同时既是<code>Integer类型</code>又是<code>Double类型</code>,所以说不可写.</p>
<p><strong>不可读</strong>:</p>
<p>可写:当使用<code>? super T</code>时,<code>泛型T</code>为所有类型的底点,<code>T类型</code>是继承于他们的.假设<code>T类型</code>为<code>Integer类型</code>,那我们只能写入<code>Integer类型,Number类型,Object类型</code>.我们可以把他们都转型转为<code>Obejct类型</code>写入.</p>
<p>不可读:正因为我们可以把他们都转型为<code>Object类型</code>写入,那我们最终只能拿<code>Object类型</code>接收,否则你根本不知道你写入的到底是<code>Integer类型</code>和<code>Number类型</code>,所以说不可读.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 反射]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-fan-she/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-fan-she/">
        </link>
        <updated>2021-05-12T06:00:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1反射是什么">1.反射是什么</h4>
<p>在Java中,反射是指：可以通过程序在系统运行时(RetentionPolicy.Runtime描述过)，拿到指定对象所有信息。</p>
<h4 id="2为什么需要使用到反射">2.为什么需要使用到反射</h4>
<p>当程序运行时，我们并不知道这个指定对象是否存在，是否有目标属性，目标方法时，就可以通过反射去取得该对象的信息。</p>
<h4 id="3如何使用反射">3.如何使用反射</h4>
<h5 id="javalang提供类">java.lang提供类</h5>
<p>反射的核心包：java.lang.reflect，需要掌握如下标红的几个类</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/image-20210511171129193.png" alt="image-20210511171129193" loading="lazy"></figure>
<p>以及核心的java.lang.Class类。该类提供了在运行时可以获取到类的所有信息。</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/image-20210511171251795.png" alt="image-20210511171251795" loading="lazy"></figure>
<h5 id="掌握内容">掌握内容</h5>
<pre><code class="language-java">	获取Class类对象的三种方式：
    	1.实例对象.getClass();
		2.类名.class;
		3.Class.forName(&quot;实例对象完整类名&quot;);
​	判断Class对象是否相等或有继承关系：
    	1.使用 instanceof 关键字
    	2.使用 class.isAssignableFrom(Class&lt;?&gt; cls)方法
        //使用此方法时需要注意,参数(cls)是被检查对象,看cls是否能强制转型为class对象
        //如:Object.class.isAssignableFrom(Integer.class) == true
        //Integer.class.isAssignableFrom(Object.class) == false
​	获取类对象的属性、构造器、方法：
    	属性：	
    		1.获取类所有public属性(包括父类的所有public属性):class.getFields();
			2.获取类所有属性(不包括父类属性):class.getDeclaredFields();
			3.设置属性的访问权限:Field.setAccessible(boolean flag);
			4.取得/修改属性值:Field.get(属性名);/Filed.set(属性名,属性值);
		构造器：
            //构造器不被继承,所以取不到父类构造器,可以通过getSuperClass获取到父类对象再获取 
            1.获取类所有public构造方法:class.getConstructors();
            2.获取类所有构造方法:class.getDeclaredConstructors();
            3.设置构造器的访问权限:Constructor.setAccessible(boolean flag);
			4.新建构造器:class.getDeclaredConstructor(Paramater.class).newInstance();
		方法:
			1.获取类所有public方法(包括父类的所有public方法):class.getMethods();
			2.获取类所有方法(不包括父类方法):class.getDeclaredMethods();
			3.设置方法的访问权限:Method.setAccessible(boolean flag);
			4.调用方法:Method.invoke(Object obj,Object...args);
			//如果是静态实例,则obj=null,否则需要传入实例;如果是无参方法,则args=null,否则需要传入参数
			//如果是多态实例,则总是调用的是传入实例的覆写方法,而不是父类方法
​	动态加载：
    	JVM并不会一次性加载所有的class文件至内存,而是会在运行时第一次碰到了需要的class文件就加载.
</code></pre>
<h5 id="使用场景">使用场景</h5>
<p>利用动态加载的特性,在JVM运行时判断Class文件是否存在,动态配置JDBC驱动/日志库等</p>
<pre><code class="language-java">/**
 * 根据classpath下是否存在mysql/oracle驱动,选择连接哪个库
 * @throws SQLException
 */
public static void dynamicConnectJDBCDriver() throws SQLException {
    Connection connection = null;
    if(isPresentClass(&quot;com.mysql.jdbc.Driver&quot;)){
        connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;,&quot;test&quot;,&quot;test&quot;);
    }else if(isPresentClass(&quot;oracle.jdbc.driver.OracleDriver&quot;)){
        connection = DriverManager.getConnection(&quot;jdbc:oracle:thin@localhost:1521/test&quot;,&quot;test&quot;,&quot;test&quot;);
    }else{
        //todo:其他库
    }
    Statement statement = connection.createStatement();
    statement.executeQuery(&quot;select * from user&quot;);
    statement.close();
    connection.close();
}

/**
 * 类似commons logging和slf4j的作用-&gt;日志接口,动态检测并使用日志模块
 * 日志接口具体的实现对应关系:commons logging(接口)使用log4j(实现);slf4j(接口)使用logback(实现)
 */
public static void dynamicDispositionLogFactory(){
    LogFactory factory = null;
    if (isPresentClass(&quot;ch.qos.logback.classic.LoggerContext&quot;)) {//logback库
        factory = createLogback();
    } else if(isPresentClass(&quot;org.apache.logging.log4j.Logger&quot;)){//log4j库
        factory = createLog4j();
    }else{//jdk log库
        factory = createJdkLog();
    }
}

/**
 * 不能使用Class.forName()==null来判断是否存在,找不到只会直接抛出ClassNotFoundException异常
 * @param clazzName
 * @return
 */
public static boolean isPresentClass(String clazzName){
    try {
        Class.forName(clazzName);
        return true;
    }catch (ClassNotFoundException e){
        return false;
    }
}
</code></pre>
<p>SpringMVC利用反射给JavaBean(提供private属性,get/set方法)动态赋值,通过请求参数,反射查找JavaBean的属性,调用set方法赋值.</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/test&quot;)
@ResponseBody
public String test(TestVO testVO) { 
  String name= testVO.getName();
}
</code></pre>
<h4 id="4动态代理">4.动态代理</h4>
<h5 id="定义">定义</h5>
<p>动态代理指的是:当jvm运行时,动态创建某个接口(interface)的实例.</p>
<p>(没有.java文件,只有生成的.class文件:public class $Proxy0 extends Proxy implements 接口)</p>
<h5 id="使用方式">使用方式</h5>
<pre><code class="language-java">/**
 * 反射实现动态代理三部曲
 * 1.创建InvocationHandler对象,通过匿名内部类实现invoke方法
 * 2.通过Proxy.newInstance创建Proxy代理对象,传入代理类的classloader,代理类的class数组,和刚刚实现的invoke()方法
 * 3.通过返回的代理对象Object,强制向下转型,调用方法
 */
public class DynamicProxy {

    /**
     * 实现代理对象的抽象方法
     * @return
     */
    public static InvocationHandler invoke(){
        return (proxy, method, args) -&gt; {
            //public abstract void org.pzzhang.reflection.DynamicProxy$Hello.hello()
            System.out.println(method);
            if(Hello.class.getMethod(&quot;hello&quot;).equals(method)){
                System.out.println(&quot;hello world&quot;);
            }
            if(Hello.class.getMethod(&quot;hey&quot;, String.class).equals(method)){
                System.out.println(&quot;hey,&quot;+args[0]);
            }
            return null;
        };
    }
    
    /**
     * 创建代理对象,其中代理对象的方法已经通过InvocationHandler实现
     * 直接将代理对象强制转型为目标对象,调用目标对象的方法即可
     */
    public static void proxyHandler(){
        Hello proxyInstance = (Hello)Proxy.newProxyInstance(Hello.class.getClassLoader(), new Class[]{Hello.class}, invoke());
        proxyInstance.hello();
        proxyInstance.hey(&quot;charles&quot;);
    }

}
interface Hello{
    void hello();
    void hey(String name);
}
</code></pre>
<p>等价于如下静态代理实现类</p>
<pre><code class="language-java">class DynamicProxyStaticImplements implements Hello{

    private final InvocationHandler invocationHandler;

    public DynamicProxyStaticImplements(InvocationHandler invocationHandler) {
        this.invocationHandler = invocationHandler;
    }

    @Override
    public void hello() {
        try {
            invocationHandler.invoke(this,Hello.class.getMethod(&quot;hello&quot;),null);//没有参数,所以args=null
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }

    @Override
    public void hey(String name) {
        try {
            invocationHandler.invoke(this,Hello.class.getMethod(&quot;hey&quot;, String.class),new Object[]{name});
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }

    public static void main(String[] args){
        DynamicProxyStaticImplements staticImplements = new DynamicProxyStaticImplements((proxy, method, args1) -&gt; {
            if (Hello.class.getMethod(&quot;hello&quot;).equals(method)) {
                System.out.println(&quot;hello world&quot;);
            }
            if (Hello.class.getMethod(&quot;hey&quot;, String.class).equals(method)) {
                System.out.println(&quot;hey,&quot; + args1[0]);
            }
            return null;
        });
        staticImplements.hello();
        staticImplements.hey(&quot;charles&quot;);
    }
}
</code></pre>
<h5 id="使用场景-2">使用场景</h5>
<p>利用动态代理,对方法增强.在方法执行前后执行事务/输出日志等操作</p>
<pre><code class="language-java">public interface SQL {

    void executeSQL();
}

class Executor implements SQL{

    @Override
    public void executeSQL() {
        Logger.getGlobal().info(&quot;select * from user&quot;);
    }
}

/**
 * 三部曲:
 * 1.创建InvokeHandler对象,处理method方法,进行方法加强(开启/关闭事务,打印输出日志)
 * 2.通过Proxy.newInstance创建代理对象,传入参数
 * 3.转化成实际对象,执行目标方法
 */
class Test{

    private static Logger global = Logger.getGlobal();

    public static InvocationHandler invoke(){
        return (proxy, method, args) -&gt; {
            if(method.equals(SQL.class.getMethod(&quot;executeSQL&quot;))){
                global.info(&quot;开启数据库连接&quot;);
                Connection conn = openConnection();//创建数据库连接
                global.info(&quot;开启事务&quot;);
                conn.setAutoCommit(false);//关闭自动提交
                method.invoke(new Executor());//执行目标SQL
                global.info(&quot;事务处理完毕,提交事务&quot;);
                conn.commit();//提交事务
                global.info(&quot;关闭数据库连接&quot;);
                conn.close();
            }
            return null;
        };
    }

     private static Connection openConnection() {
        try {
            return  DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;,&quot;root&quot;,&quot;123456&quot;);
        } catch (SQLException throwables) {
            throwables.printStackTrace();
            return null;
        }
    }
    
    public static void main(String[] args){
        SQL sql = (SQL)Proxy.newProxyInstance(SQL.class.getClassLoader(), new Class[]{SQL.class}, invoke());
        sql.executeSQL();
    }
}
</code></pre>
<p>执行结果:</p>
<figure data-type="image" tabindex="3"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210512135749.png" alt="截图_选择区域_20210512135749" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 注解]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-zhu-jie/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-zhu-jie/">
        </link>
        <updated>2021-05-07T09:05:28.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1注解是什么">1.注解是什么</h4>
<p>注释: 说明文字,给人看的.</p>
<p>注解: 修饰数据的元数据,给JVM看的.</p>
<p>元注解: 修饰注解的注解.</p>
<h4 id="2为什么要使用注解">2.为什么要使用注解</h4>
<p>当我们希望描述一种数据时,使它能有更多的内容(如修饰词一样).</p>
<h4 id="3如何使用注解">3.如何使用注解</h4>
<p>在使用注解之前,先了解一下几个常见注解.</p>
<h5 id="基本注解javalang包下">基本注解(java.lang包下)</h5>
<p>3.1 @Deprecated</p>
<blockquote>
<p>注释为@Deprecated的程序元素是不鼓励程序员使用的元素。 某个元素可能由于多种原因而被弃用，例如，其使用可能会导致错误； 可能无法兼容地进行更改，或者在将来的版本中将其删除； 它已被更新的，通常更可取的替代方法所取代； 否则它已经过时了。     								  -</p>
<p>​		--来源java.lang.Deprecated注释描述</p>
</blockquote>
<p>简而言之:Deprecated注解用于<strong>标记程序为过时的</strong>.</p>
<p>@FunctionalInterface</p>
<blockquote>
<p>信息性注释类型，用于指示接口类型声明旨在成为Java语言规范定义的功能接口。 从概念上讲，功能接口仅具有一种抽象方法。 由于默认方法具有实现，因此它们不是抽象的。 如果接口声明了一个覆盖java.lang.Object的公共方法之一的抽象方法，则该方法也不计入接口的抽象方法计数，因为该接口的任何实现都将具有java.lang.Object或其他地方的实现。</p>
<p>​		---来源java.lang.FunctionalInterface注释描述</p>
</blockquote>
<p>简而言之:FunctionalInterface注解用于<strong>标记接口为函数式接口</strong>.</p>
<p>3.3 @Override</p>
<blockquote>
<p>指示方法声明旨在覆盖超类型中的方法声明。 如果使用此注释类型对方法进行注释，则除非至少满足以下条件之一，否则要求编译器生成错误消息：<br>
该方法的确覆盖或实现了在超类型中声明的方法。<br>
该方法的签名与Object中声明的任何公共方法的签名等效。</p>
<p>​		---来源java.lang.Override注释描述</p>
</blockquote>
<p>简而言之:Override注解用于<strong>重写父类的方法</strong>.</p>
<p>3.4 @SafeVarargs</p>
<blockquote>
<p>程序员断言带注释的方法或构造函数的主体不会对其varargs参数执行潜在的不安全操作。 将此注释应用于方法或构造函数可抑制有关非可调整变量Arity （vararg）类型的未经检查的警告，并抑制有关在调用站点创建参数化数组的未经检查的警告。<br>
除了其@Target元注释所施加的使用限制外，还要求编译器对此注释类型实施附加的使用限制。 如果用@SafeVarargs批注对方法或构造函数声明进行批注，则编译时错误，并且：<br>
声明是固定的arity方法或构造函数<br>
声明是可变的arity方法，既非static也非final或private 。</p>
<p>@SafeVarargs // Not actually safe!<br>
static void m(List<String>... stringLists) {<br>
Object[] array = stringLists;<br>
List<Integer> tmpList = Arrays.asList(42);<br>
array[0] = tmpList; // Semantically invalid, but compiles without warnings<br>
String s = stringLists[0].get(0); // Oh no, ClassCastException at runtime!<br>
}</p>
<p>​		---来源java.lang.SafeVarargs注释描述</p>
</blockquote>
<p>简而言之:SafeVarargs注解用于<strong>当一个非泛型集合(如Object[])赋值给泛型集合时,发生堆污染</strong>.</p>
<p>3.5 @SuppressWarnings</p>
<blockquote>
<p>指示应在带注释的元素（以及带注释的元素中包含的所有程序元素）中禁止命名的编译器警告。 请注意，在给定元素中禁止显示的警告集是在所有包含元素中禁止显示的警告的超集。 例如，如果您注释一个类以禁止一个警告，并注释一个方法以禁止另一个警告，则两种警告将在该方法中被抑制。 但是，请注意，如果在module-info文件中禁止显示警告，则该禁止适用于文件中的元素，而不适用于模块中包含的类型。<br>
作为样式问题，程序员应始终在最有效嵌套的最深层元素上使用此注释。 如果要在特定方法中禁止显示警告，则应注释该方法而不是其类。</p>
<p>​		---来源java.lang.SuppressWarnings注释描述</p>
</blockquote>
<p>简而言之:SuppressWarnings用于<strong>抑制编译器警告</strong>.</p>
<h5 id="元注解javalangannotation包下">元注解(java.lang.annotation包下)</h5>
<p>3.6 @Documented</p>
<blockquote>
<p>如果注释@Documented出现在注释类型A的声明中，则元素上的任何@A注释@A视为元素公共合同的一部分。 更详细地，当注释类型A与注释Documented ，存在和类型A的注释的值是元素A注释的公共合同的一部分。 相反，如果注释类型B没有带注释Documented ，存在和B的注释的值都不是元件B注释的公共合同的一部分。 具体来说，如果注释类型用Documented注释，则默认情况下，像javadoc这样的工具将在其输出中显示该类型的注释，而没有Documented的注释类型的注释将不显示。</p>
<p>​		---来源java.lang.annotation.Documented注释描述</p>
</blockquote>
<p>简而言之:Documented用于<strong>被@Documented修饰的注解会被javadoc工具输出成文档</strong>.</p>
<p>3.7 @Inherited</p>
<blockquote>
<p>指示注释类型是自动继承的。 如果注释类型声明中存在继承的元注释，并且用户在类声明中查询该注释类型，并且该类声明中没有该类型的注释，则将自动查询该类的超类以获取注释类型。 重复此过程，直到找到该类型的注释或到达类层次结构（对象）的顶部为止。 如果没有超类对此类型进行注释，则查询将指示所讨论的类没有此类注释。<br>
请注意，如果带注释的类型用于注释除类之外的任何内容，则此元注释类型无效。 还要注意，此元注释仅使注释从超类继承； 已实现的接口上的注释无效。</p>
<p>​		---来源java.lang.annotation.Inherited注释描述</p>
</blockquote>
<p>简而言之:Inherited用于<strong>被修饰的注解将会被子类继承</strong>.</p>
<p>3.8 @Repeatable</p>
<blockquote>
<p>注释类型java.lang.annotation.Repeatable用于指示其声明（元（meta-））注释的注释类型可重复。 @Repeatable的值表示可重复注释类型的包含注释类型。</p>
<p>​		---来源java.lang.annotation.Repeatable注释描述</p>
</blockquote>
<p>简而言之：Repeatable用于<strong>被修饰的注解可以重复使用</strong>.</p>
<p>3.9 @Retention</p>
<blockquote>
<p>指示带注释类型的注释将保留多长时间。 如果注释类型声明上没有保留注释，则保留策略默认为RetentionPolicy.CLASS 。<br>
仅当元注释类型直接用于注释时，保留元注释才有效。 如果将元注释类型用作另一注释类型的成员类型，则无效。</p>
<p>​		---来源java.lang.annotation.Retention注释描述</p>
</blockquote>
<p>简而言之：Retention用于<strong>决定被修饰的注解的生命周期</strong>.</p>
<p>3.10 @Target</p>
<blockquote>
<p>指示注释类型适用的上下文。 在JLS 9.6.4.1中指定了可以在其中应用注释类型的声明上下文和类型上下文，并在源代码中用java.lang.annotation.ElementType的枚举常量表示。<br>
如果在注释类型T上不存在@Target元注释，则可以将类型T的注释写为除类型参数声明之外的任何声明的修饰符。<br>
如果存在@Target元注释，则编译器将强制执行ElementType枚举常量指示的使用限制，以符合JLS 9.7.4的要求。</p>
<p>​		---来源java.lang.annotation.Target注释描述</p>
</blockquote>
<p>简而言之：Target用于<strong>指定被修饰的注解用在可以修饰的地方</strong>.</p>
<h5 id="补充说明">补充说明</h5>
<p>上述说到，Retention用于<strong>决定被修饰的注解的生命周期</strong>.其中RetentionPolicy定义了三个生命阶段</p>
<pre><code class="language-java">public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}
</code></pre>
<p>RetentionPolicy.SOURCE：注解被编译器使用，只存在于.java文件，不会进入到.class文件，被编译后(javac)成.class文件后擦除。</p>
<p>RetentionPolicy.CLASS：注解被.class文件使用，不会进入到JRE(Java Runtime Environment)中。</p>
<p>RetentionPolicy.RUNTIME：注解会在程序运行时读取到，一直存在于JVM中，也是我们最常用以及自定义注解时需要指明的注解生命周期。</p>
<p>Java文件的编译流程：</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/dyo3u7g3go.png" alt="dyo3u7g3go" loading="lazy"></figure>
<p>其中source-&gt;compiler过程：</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/321arjo9gz.png" alt="321arjo9gz" loading="lazy"></figure>
<p>整个编译-&gt;执行过程：source(java源代码)-&gt;parse(分析和输入到符号表)-&gt;processor(注解处理器)-&gt;analyse(分析语义)-&gt;generate(生成文件)-&gt;javac(编译)-&gt;字节码-&gt;classload(类加载)-&gt;JIT-&gt;机器码-&gt;目标机器执行</p>
<p>如果想在RetentionPolicy.class周期时获取到注解信息，需要继承AbstractProcessor类，实现process功能.(Lombok 生成get/set方法实现方式)</p>
<h5 id="自定义注解">自定义注解</h5>
<p>元注解：</p>
<pre><code class="language-java">/**
 * 元注解:修饰注解的注解
 * 即Target为ElementType.ANNOTATION_TYPE
 * 对注解进行标记,说明
 * JDK提供的元注解在java.lang.annotation包下,一共有5个      			(Documented,Inherited,Repeatable,Retention,Target)
 * 其中Native注解较为特殊,使用@Target(ElementType.FIELD)
 * 另外:所有注解都隐式继承java.lang.annotation.Annotation接口
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface MetaAnnotation {
}
</code></pre>
<p>普通注解：</p>
<pre><code class="language-java">/**
 * 注解:修饰数据的元数据
 * 即Target为除了(ElementType.ANNOTATION_TYPE)之外的ElementType
 * 对数据进行标记,说明
 * JDK提供的注解在java.lang包下
 */
@Retention(RetentionPolicy.RUNTIME) //Retention注解决定了该注解的生命周期,默认值RetentionPolicy.CLASS,详见Retention.class注释
@Target({ElementType.CONSTRUCTOR,ElementType.PARAMETER}) //target注解决定了该注解的使用范围
@MetaAnnotation
public @interface MyAnnotation {

    /**
     * 注解不能使用除(String,基本数据类型,Class,枚举,数组,注解)以外的数据类型
     */

    String name();

    int age() default 18; //default指定了缺省值

    //Class clazz();
    //ElementType TYPE();
    //int[] numbs();
    //Retention RETENTION();
    //Integer age();  无法通过编译
}
</code></pre>
<p>特殊注解：</p>
<pre><code class="language-java">/**
 * 当注解只有一个成员变量,且属性名为value时,赋值时不用显示声明value=XX
 */
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation2 {

    String value();
}
</code></pre>
<h5 id="使用注解">使用注解</h5>
<pre><code class="language-java">public class Human {

    private String name;

    private int age;

    @MyAnnotation(name = &quot;jarvis&quot;)
    public Human() {
        for (Constructor&lt;?&gt; constructor : Human.class.getConstructors()) {
            if (constructor.isAnnotationPresent(MyAnnotation.class)) {
                MyAnnotation annotation = constructor.getAnnotation(MyAnnotation.class);
                this.name = annotation.name();
                this.age = annotation.age();
            }
        }
    }

    public Human(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Human resetHuman(@MyAnnotation(name = &quot;huffman&quot;, age = 22) Human human) throws NoSuchMethodException {
        Method resetHuman = Human.class.getMethod(&quot;resetHuman&quot;, Human.class);
        for (Annotation[] parameterAnnotation : resetHuman.getParameterAnnotations()) {
            for (Annotation annotation : parameterAnnotation) {
                if (annotation instanceof MyAnnotation) {
                    MyAnnotation myAnnotation = (MyAnnotation) annotation;
                    String name = myAnnotation.name();
                    int age = myAnnotation.age();
                    return new Human(name, age);
                }
            }
        }
        return null;
    }

    @MyAnnotation2(&quot;test&quot;)
    public String getValue() throws NoSuchMethodException {
        Method getValue = Human.class.getMethod(&quot;getValue&quot;);
        return getValue.getAnnotation(MyAnnotation2.class).value();
    }

    @Override
    public String toString() {
        return &quot;Human{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }

    public static void main(String[] args) throws NoSuchMethodException {
        Human human = new Human();
        //System.out.println(human); 输出Human{name='jarvis', age=18}
        human = human.resetHuman(human);
        //System.out.println(human); 输出Human{name='huffman', age=22}
        //System.out.println(human.getValue()); 输出test
    }
}
</code></pre>
<h4 id="4总结">4.总结</h4>
<p>1.注解是用于修饰数据的一种特殊标记，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p>
<p>2.当我们需要给程序添加标注时，可以使用注解。</p>
<p>3.java.lang包提供了基础注解和元注解，元注解用于修饰注解。</p>
<p>4.注解有三个生命周期：源码时(source)，Class文件时(class)，运行时(Runtime)。我们常常自定义注解需要在运行时通过反射获取，通过程序对获取到的注解实现相应功能。</p>
<p>5.如果想利用java文件在编译过程中，利用注解实现功能，可以考虑通过继承AbstractProcessor类，实现process功能来完成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零开始学算法 - 队列]]></title>
        <id>https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-dui-lie/</id>
        <link href="https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-dui-lie/">
        </link>
        <updated>2021-04-09T02:42:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">/**
 * Functional Purpose - 队列 先进先出数据结构 FIFO(first in first out)
 * @date:2021-04-08 下午4:01
 * @author huffman
*/
public interface Queue&lt;E&gt; {

    /**
     * 元素入队尾
     * @param e
     */
    void enqueue(E e);

    /**
     * 元素出队首
     * @return
     */
    E dequeue();

    /**
     * 获取队首元素
     * @return
     */
    E getFront();

    /**
     * 获取队列元素总个数
     * @return
     */
    int getSize();

    /**
     * 判断队列元素是否为空
     * @return
     */
    boolean isEmpty();
}

/**
 * Functional Purpose - 动态数组实现队列
 *
 * @author huffman
 * @date:2021-04-08 下午4:05
 */
public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; {

    private Arrays&lt;E&gt; data;

    public ArrayQueue() {
        data = new Arrays();
    }

    public ArrayQueue(int capacity) {
        data = new Arrays(capacity);
    }

    @Override
    public void enqueue(E e) {
        data.addLast(e);
    }

    @Override
    public E dequeue() {
        return data.removeFirst();
    }

    @Override
    public E getFront() {
        return data.getFirstElement();
    }

    @Override
    public boolean isEmpty() {
        return data.isEmpty();
    }

    @Override
    public int getSize() {
        return data.getSize();
    }

    public int getCapacity(){
        return data.getCapacity();
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format(&quot;ArrayQueue: size = %d , capacity = %d\n&quot;,getSize(),getCapacity()));
        res.append(&quot;front:[&quot;);
        for (int i = 0; i &lt; getSize(); i++) {
            res.append(data.getElement(i));
            if(i!=getSize()-1){
                res.append(&quot; ,&quot;);
            }
        }
        res.append(&quot;]tail&quot;);
        return res.toString();
    }

    public static void main(String[] args) {
        Queue&lt;Integer&gt; queue = new ArrayQueue&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            queue.enqueue(i);
            System.out.println(queue);
            if (i % 3 == 2) {
                queue.dequeue();
                System.out.println(queue);
            }
        }
    }
}

/**
 * Functional Purpose -  循环队列
 * 以牺牲一个空间,头部和尾部索引循环,得到循环队列
 * 当头部等于尾部时,认为该队列为空;当头部等于(尾部+1)/总容量时,认为该队列已满
 *
 * @author huffman
 * @date:2021-04-08 下午4:55
 */
public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; {

    /**
     * 数组存储元素
     */
    private E[] data;

    /**
     * 下标的头部,尾部
     */
    private int front, tail;

    /**
     * 元素总个数
     */
    private int size;

    /**
     * 扩容因子
     */
    private int resizeFactor = 2;

    public LoopQueue(int capacity) {
        data = (E[]) new Object[capacity + 1];
        front = 0;
        tail = 0;
        size = 0;
    }

    public LoopQueue() {
        this(10);
    }

    @Override
    public void enqueue(E e) {
        //先看容量大小,需不需要扩容
        if ((tail + 1) % data.length == front) {
            resize(resizeFactor * getCapacity());
        }
        //维护队尾下标和元素总数
        data[tail] = e;
        tail = (tail + 1) % data.length;
        size++;
    }

    @Override
    public E dequeue() {
        //如果容器中无元素,则直接抛出异常
        if (isEmpty()) {
            throw new IllegalArgumentException(&quot;The queue is empty,no element can be dequeue&quot;);
        }
        //维护队首下标和元素总数
        E e = data[front];
        data[front] = null;
        front = (front + 1) % data.length;
        size--;
        //看容量大小,需不需要扩容,这里也采用懒缩容的方式,避免复杂度震荡,增加复杂度
        if (size == getCapacity() / resizeFactor / 2) {
            resize(getCapacity() / resizeFactor);
        }
        return e;
    }

    @Override
    public E getFront() {
        if (isEmpty()) {
            throw new IllegalArgumentException(&quot;The queue is empty.&quot;);
        }
        return data[front];
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return front == tail;
    }

    public int getCapacity() {
        return data.length - 1;
    }

    private void resize(int newCapacity) {
        E[] newData = (E[]) new Object[newCapacity + 1];
        //挪动元素
        for (int i = 0; i &lt; size; i++) {
            newData[i] = data[(front + i) % data.length];
        }
        data = newData;
        front = 0;//头下标 从0开始
        tail = size;//尾下标 从最后的元素开始
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format(&quot;LoopQueue: size = %d , capacity = %d\n&quot;, getSize(), getCapacity()));
        res.append(String.format(&quot;front [&quot;));
        for (int i = front; i != tail; i = (i + 1) % data.length) {
            res.append(data[i]);
            if ((i + 1) % data.length != tail) {
                res.append(&quot;, &quot;);
            }
        }
        res.append(String.format(&quot;] tail&quot;));
        return res.toString();
    }

    public static void main(String[] args) {
        Queue&lt;Integer&gt; queue = new LoopQueue&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            queue.enqueue(i);
            System.out.println(queue);
            if (i % 3 == 2) {
                queue.dequeue();
                System.out.println(queue);
            }
        }
    }
}
</code></pre>
<blockquote>
<p>注意事项:</p>
<p>1.同样的,无论队列的数据结构实现是什么,用户并不关心,只用知道如何操作队列元素即可(入队:enqueue;出队:dequeue;查看队首元素:front).</p>
<p>2.此处队列提供了两种实现方式:以动态数组的方式实现与以循环数组的方式实现.</p>
<p>优缺点比较:</p>
<p>动态数组优点:直接采用动态数组为底层数据结构,直接复用Arrays代码,通过Arrays的增加/删除元素操作队列进行入队/出队操作.实现起来十分简单.</p>
<p>动态数组缺点:进行出队操作时,需要将头元素以后的元素往前挪一位,时间复杂度表现为O(n),性能较差.</p>
<p>循环数组优点:进行出队操作时,只需维护Front头元素的下标信息,指向下一个下标即可,时间复杂度表现为O(1),性能优秀.</p>
<p>循环数组缺点:需要实现新的数据结构-循环数组,在进行出队/入队操作时,需要维护front/tail信息,增加了理解难度.</p>
<p>3.循环数组的实现逻辑:可以想象一个时钟,刻度为12(capacity),头元素为0,尾元素最大值为11(capacity-1),当尾元素到达12时,也同时指向0. 可以理解为该时钟又从零开始 : 即 当头元素=尾元素时,该数组为空;当尾元素=11(capacity-1)时,最大,同时该数组应该扩容. 注意:capacity+1 = length!</p>
<p>4.循环数组牺牲了一个空间,为了保证该数组容积大小等于初始化时的容积大小,故在初始化时需要将指定容积大小+1,所以当获取该容积时,需要将数组长度-1时,才能符合用户预期输入时的容积大小.进行循环时,实际还是得除以数组的实际容积大小,才能保证循环.</p>
<p>5.循环操作:front = (front+1)/length;tail = (tail+1)/length.  只有除以了length,才能保证front、tail永远小于length,故在一个数组长度内进行循环</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零开始学算法 - 栈]]></title>
        <id>https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-zhan/</id>
        <link href="https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-zhan/">
        </link>
        <updated>2021-04-09T02:42:03.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">/**
 * Functional Purpose - 栈 后进先出数据结构 LIFO(Last in First Out)
 * @date:2021-04-08 上午11:31
 * @author huffman
*/
public interface Stack&lt;E&gt; {

    /**
     * 元素入栈尾
     * @param e
     */
    void push(E e);

    /**
     * 元素出栈尾
     * @return
     */
    E pop();

    /**
     * 获取栈尾元素
     * @return
     */
    E peek();

    /**
     * 获取栈内元素总个数
     * @return
     */
    int getSize();

    /**
     * 判断栈元素是否为空
     * @return
     */
    boolean isEmpty();
}

/**
 * Functional Purpose - 动态数组的方式实现栈
 * @date:2021-04-08 上午11:54
 * @author huffman
*/
public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt;{

    private final Arrays&lt;E&gt; arrays;

    public ArrayStack() {
        arrays = new Arrays&lt;&gt;();
    }

    public ArrayStack(int capacity){
        arrays = new Arrays&lt;&gt;(capacity);
    }

    @Override
    public void push(E e) {
        arrays.addLast(e);
    }

    @Override
    public E pop() {
        return arrays.removeLast();
    }

    @Override
    public E peek() {
        return arrays.getLastElement();
    }

    @Override
    public int getSize() {
        return arrays.getSize();
    }

    @Override
    public boolean isEmpty() {
        return arrays.isEmpty();
    }

    public int getCapacity(){
        return arrays.getCapacity();
    }

    @Override
    public String toString() {
        return &quot;ArrayStack{&quot; +
                &quot;arrays=&quot; + arrays +
                '}';
    }

}
</code></pre>
<blockquote>
<p>注意事项:</p>
<p>1.无论栈的数据结构实现是什么,用户并不关心,只用知道如何操作栈元素即可(入栈:push,出栈:pop,查看栈顶元素:peek).</p>
<p>2.基于动态数组实现的栈十分简单,进行栈元素操作时,直接使用动态数组提供的添加/删除元素操作,就可以实现栈元素的操作.但需要注意的是,栈是FILO(先进后出 first in last out)或者是LIFO(后进先出 last in first out),故在添加/删除栈元素时,是入头元素和出头元素.这一点与队列相反!</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零开始学算法 - 数组]]></title>
        <id>https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-shu-zu/</id>
        <link href="https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-shu-zu/">
        </link>
        <updated>2021-04-09T02:33:05.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">/**
 * Functional Purpose - 动态数组 类似java.util.ArrayList
 *
 * @author huffman
 * @date:2021-04-06 下午5:26
 */
public class Arrays&lt;E&gt; {

    /**
     * 初始化数组数据
     */
    private E[] data;

    /**
     * 数组实际容量
     */
    private int size;

    /**
     * 扩容因子
     */
    private int resizeFactor = 2;

    /**
     * 以数组e初始化数组
     *
     * @param e 数组
     */
    public Arrays(E[] e) {
        this.data = e;
    }

    /**
     * 以最大容量为capacity初始化数组
     *
     * @param capacity 最大容量
     */
    public Arrays(int capacity) {
        data = (E[]) new Object[capacity];
        size = 0;
    }

    /**
     * 以默认容量10初始化数组
     */
    public Arrays() {
        this(10);
    }

    /**
     * 数组内元素是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return this.size == 0;
    }

    /**
     * 获取实际元素个数
     *
     * @return
     */
    public int getSize() {
        return size;
    }

    /**
     * 获取最大容量大小
     */
    public int getCapacity() {
        return data.length;
    }

    /**
     * 从指定位置插入元素
     */
    public void addElement(E e, int index) {
        checkIndex(index);
        //实际存储元素的容量已经满了
        if (size == data.length) {
            resize(resizeFactor * getCapacity());
        }
        //从下标为size-1的元素开始 从后往前挪动一位元素,即index+1的元素=index的元素
        for (int i = size - 1; i &gt;= index; i--) {
            data[i + 1] = data[i];
        }
        data[index] = e;
        size++;
    }

    /**
     * 从末尾新增元素
     */
    public void addLast(E e) {
        addElement(e, size);
    }

    /**
     * 从头尾新增元素
     */
    public void addFirst(E e) {
        addElement(e, 0);
    }

    /**
     * 获取指定下标元素
     *
     * @param index
     * @return
     */
    public E getElement(int index) {
        checkIndex(index);
        return data[index];
    }

    /**
     * 获取最后一个元素
     * @return
     */
    public E getLastElement() {
        return getElement(size-1);
    }

    /**
     * 获取第一个元素
     * @return
     */
    public E getFirstElement() {
        return getElement(0);
    }

    /**
     * 修改指定下标元素为e
     *
     * @param e
     * @param index
     */
    public void setElement(E e, int index) {
        checkIndex(index);
        data[index] = e;
    }

    /**
     * 检查下标
     *
     * @param index
     */
    public void checkIndex(int index) {
        //下标不能为负且数组得是连续的元素 所以也不能大于size,不然中间会出现空缺元素
        if (index &lt; 0 || index &gt; size) {
            throw new IllegalArgumentException(&quot;AddElement failed. The index can't be less then 0 or more than capacity&quot;);
        }
    }

    /**
     * 检查数组中是否包含元素e
     *
     * @param e
     * @return
     */
    public boolean contains(E e) {
        for (int i = 0; i &lt; size; i++) {
            if (data[i].equals(e)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 寻找数组中e元素的下标,若没有则返回-1
     *
     * @param e
     * @return
     */
    public int findElement(E e) {
        for (int i = 0; i &lt; size; i++) {
            if (data[i].equals(e)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 寻找数组中所有e元素的下标
     *
     * @param e
     * @return todo:不对 需要调整或删除
     */
    @Deprecated
    public int[] findAllElements(E e) {
        int[] indexArray = new int[size];
        int index = 0;
        for (int i = 0; i &lt; size; i++) {
            if (data[i].equals(e)) {
                indexArray[index++] = i;
            }
        }
        return indexArray;
    }

    /**
     * 删除数组中指定下标的元素,返回删除后的元素
     *
     * @param index
     * @return
     */
    public E remove(int index) {
        checkIndex(index);
        E e = data[index];
        for (int i = index+1; i &lt; size; i++) {
            data[i-1] = data[i];
        }
        size--;

        if (size &lt;= getCapacity() / resizeFactor / 2 &amp;&amp; getCapacity() / 2 != 0) {//懒处理 不及时缩容
            resize(getCapacity() / resizeFactor);
        }
        return e;
    }

    /**
     * 删除数组中第一个元素
     *
     * @return
     */
    public E removeFirst() {
        return remove(0);
    }

    /**
     * 删除数组中最后一个元素
     *
     * @return
     */
    public E removeLast() {
        return remove(size - 1);
    }

    /**
     * 删除一个元素e
     *
     * @param e
     */
    public void removeElement(E e) {
        if (contains(e)) {
            int index = findElement(e);
            remove(index);
        }
    }

    /**
     * 删除所有元素e
     *
     * @param e todo:不对 需要调整或删除
     */
    @Deprecated
    public void removeAllElements(E e) {
        if (contains(e)) {
            for (Integer index : findAllElements(e)) {
                remove(index);
            }
        }
    }

    @Override
    public String toString() {
        return &quot;Arrays{&quot; +
                &quot; size=&quot; + size +
                &quot;, capacity=&quot; + data.length +
                &quot;,data=&quot; + java.util.Arrays.toString(data) +
                '}';
    }

    private void resize(int newCapacity) {
        E[] newArray = (E[]) new Object[newCapacity];
        for (int i = 0; i &lt; size; i++) {
            newArray[i] = data[i];
        }
        data = newArray;
    }

}
</code></pre>
<blockquote>
<p>注意事项:</p>
<p>1.在指定下标操作元素时,要注意下标是否越界</p>
<p>2.在增加/删除元素时,要注意数组的大小,满了就扩容,少了就缩容.缩容时,要避免出现刚扩容后,立马缩容的情况,这样会增加时间复杂度,所以这里我们粗略的采用:当元素总数为容积的<strong>1/4</strong>时,进行容积的<strong>1/2</strong>缩容.</p>
<p>3.同时,增加/删除元素时,要同时维护元素总数(size)</p>
<p>4.扩容时复制元素至新数组,容量大小为 resizeFactor*capacity</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些有趣的事情]]></title>
        <id>https://nojudgeme.github.io/post/yi-xie-you-qu-de-shi-qing/</id>
        <link href="https://nojudgeme.github.io/post/yi-xie-you-qu-de-shi-qing/">
        </link>
        <updated>2021-01-18T10:12:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id=""></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[鸟哥的私房菜-Linux(基础学习篇)]]></title>
        <id>https://nojudgeme.github.io/post/niao-ge-de-si-fang-cai-linuxji-chu-xue-xi-pian/</id>
        <link href="https://nojudgeme.github.io/post/niao-ge-de-si-fang-cai-linuxji-chu-xue-xi-pian/">
        </link>
        <updated>2021-01-15T04:21:25.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/1.html">鸟哥的私房菜:基础学习篇 第四版</a><br>
<a href="https://www.processon.com/view/link/5faa4716e0b34d7a1aa28933" target="_blank"><br>
<img src="http://assets.processon.com/chart_image/5f59820c07912902cf7ed0a6.png"/><br>
</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://nojudgeme.github.io/post/about/</id>
        <link href="https://nojudgeme.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>学习交流所见所闻,分享一切有趣的事~</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>一个偶尔有技术追求的咸鱼</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>爱动漫,打游戏,健身(还没开始orz...)</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>Gmail:charles@gmail.com<br>
QQ:2451179899<br>
wx:q15172426627</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://nojudgeme.github.io/post/hello-gridea/</id>
        <link href="https://nojudgeme.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>