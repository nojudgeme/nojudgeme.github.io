<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nojudgeme.github.io</id>
    <title>Huffman&apos;s Study Area</title>
    <updated>2021-06-19T04:26:24.145Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nojudgeme.github.io"/>
    <link rel="self" href="https://nojudgeme.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://nojudgeme.github.io/images/avatar.png</logo>
    <icon>https://nojudgeme.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Huffman&apos;s Study Area</rights>
    <entry>
        <title type="html"><![CDATA[加密与安全]]></title>
        <id>https://nojudgeme.github.io/post/jia-mi-yu-an-quan/</id>
        <link href="https://nojudgeme.github.io/post/jia-mi-yu-an-quan/">
        </link>
        <updated>2021-06-19T04:14:44.000Z</updated>
        <summary type="html"><![CDATA[<p>为了防止通信过程中,数据被窃听/篡改/伪造,加密成为了对应手段.计算机密码学是建立在严格是数学基础上的,已经发展成为了一门科学.对于编写一个安全的加密算法是十分困难的,所以要遵循下面三个原则:</p>
<ol>
<li>不要自己设计山寨加密算法</li>
<li>不要自己实现已有加密算法</li>
<li>不要自己修改已有加密算法</li>
</ol>
<h4 id="编码算法">编码算法</h4>
<p>编码算法并不是加密算法,他们的目的是为了让二进制数据和文本有对应关系.</p>
<h5 id="url编码">URL编码</h5>
<p>URL编码是浏览器给服务器发送数据时使用的编码,目的是为了将字符编译成%前缀的文本,便于服务器和浏览器相互识别.如Java中提供了标准函数库:<code>java.net.URLDecoder、java.net.URLEncoder</code></p>
<pre><code class="language-java">public class URLCoderDemo {

    public static void main(String[] args) throws UnsupportedEncodingException {
        String encode = URLEncoder.encode(&quot;哈哈哈哈&quot;, StandardCharsets.UTF_8.toString());
        System.out.println(&quot;url 编码后的结果:&quot;+encode);
        //输出:url 编码后的结果:%E5%93%88%E5%93%88%E5%93%88%E5%93%88
        String decode = URLDecoder.decode(encode, StandardCharsets.UTF_8.toString());
        System.out.println(&quot;url 解码后的结果:&quot;+decode);
        //输出:url 解码后的结果:哈哈哈哈
    }
}
</code></pre>
<h5 id="base64编码">Base64编码</h5>
<p>Base64编码是将二进制数据编译成文本,且只包含<code>A</code><sub>`Z`、`a`</sub><code>z</code>、<code>0</code>~<code>9</code>、<code>+</code>、<code>/</code>、<code>=</code>这些字符.同样的,Java中提供了标准函数库:<code>java.util.Base64</code></p>
<pre><code class="language-java">public class Base64Demo {

    public static void main(String[] args){

        String encode = Base64.getEncoder().encodeToString(&quot;哈哈&quot;.getBytes(StandardCharsets.UTF_8));
        System.out.println(&quot;base64编码后的结果:&quot;+encode);
        //base64编码后的结果:5ZOI5ZOI
        
        byte[] decode = Base64.getDecoder().decode(encode);
        System.out.println(&quot;base64解码后的结果:&quot;+ Arrays.toString(decode));
        //base64解码后的结果:[-27, -109, -120, -27, -109, -120]
        System.out.println(&quot;base64解码后的结果:&quot;+ new String(decode,StandardCharsets.UTF_8));
        //base64解码后的结果:哈哈
    }
}
</code></pre>
<h4 id="哈希算法">哈希算法</h4>
<p>Hash-翻译散列或哈希算法-又名摘要算法(Digest).</p>
<p>作用在于:输入一组任意长度的数据,通过哈希算法,压缩成固定长度的摘要.</p>
<p>最主要特点:</p>
<ul>
<li>相同的输入一定得到相同的输出.</li>
<li>不相同的输入大概率得到不相同的输出.</li>
</ul>
<p>最直接的,如Java中<code>java.lang.Object.hashcode()</code>就是一个哈希算法.</p>
<pre><code class="language-java">//open jdk1.8 native hashcode:
System.out.println(new URLCoderDemo().hashCode());//1304836502
System.out.println(new Base64Demo().hashCode());//225534817
System.out.println(new HashDemo().hashCode());//1878246837
</code></pre>
<h5 id="哈希碰撞">哈希碰撞</h5>
<p>哈希碰撞是指:不同的输入得到相同的输出</p>
<pre><code class="language-java">System.out.println(&quot;AaAaAa&quot;.hashCode());// 1952508096
System.out.println(&quot;BBAaBB&quot;.hashCode());// 1952508096
</code></pre>
<p>为什么会出现这种事情?</p>
<p>从哈希算法的作用中可以得到解释:<strong>通过散列函数,将任意长度的数据压缩成固定长度的摘要</strong>.既然是固定长度,那么它的输出数据一定是可以穷举出来的.如长度为4的一维int数组,一共能存10<sup>4个数字.那么无限的输入集合,与10</sup>4个输出集合,必然会出现多个输入出现相同输出的情况,也就是我们所说的<strong>哈希碰撞</strong>.</p>
<p>当我们设计一个哈希算法时,碰撞的概率是该函数好坏的评判标准.一个安全的哈希算法必须满足下面两个条件:</p>
<ul>
<li>碰撞概率低</li>
<li>不可猜出输出</li>
</ul>
<p><strong>不可猜出输出:即输出规律不可循.</strong></p>
<p>如果<code>AaAaAa.haschode()=1952508096;AaAaAb.hashcode()=1952508097;</code>,那我们可以这个<code>hashcode()</code>是一个不安全的哈希算法.</p>
<h5 id="常见哈希算法">常见哈希算法</h5>
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">输出长度（位）</th>
<th style="text-align:left">输出长度（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MD5</td>
<td style="text-align:left">128 bits</td>
<td style="text-align:left">16 bytes</td>
</tr>
<tr>
<td style="text-align:left">SHA-1</td>
<td style="text-align:left">160 bits</td>
<td style="text-align:left">20 bytes</td>
</tr>
<tr>
<td style="text-align:left">RipeMD-160</td>
<td style="text-align:left">160 bits</td>
<td style="text-align:left">20 bytes</td>
</tr>
<tr>
<td style="text-align:left">SHA-256</td>
<td style="text-align:left">256 bits</td>
<td style="text-align:left">32 bytes</td>
</tr>
<tr>
<td style="text-align:left">SHA-512</td>
<td style="text-align:left">512 bits</td>
<td style="text-align:left">64 bytes</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">public class HashDemo {

    public static void main(String[] args) throws NoSuchAlgorithmException {
        String encryptString = &quot;hello world&quot;;
        System.out.println(md5(encryptString));
        //md5摘要输出:5eb63bbbe01eeed093cb22bb8f5acdc3
        System.out.println(sha1(encryptString));
        //sha1摘要输出:2aae6c35c94fcfb415dbe95f408b9ce91ee846ed
        System.out.println(sha256(encryptString));
        //sha256摘要输出:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
        System.out.println(sha512(encryptString));
        //sha512摘要输出:                 			309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f
    	//RipeMD-160 java标准库中暂未提供算法实现
    }

    private static String md5(String encryptString) throws NoSuchAlgorithmException {
        return hash(encryptString, &quot;MD5&quot;);
    }

    private static String sha1(String encryptString) throws NoSuchAlgorithmException {
        return hash(encryptString, &quot;SHA-1&quot;);
    }

    private static String sha256(String encryptString) throws NoSuchAlgorithmException {
        return hash(encryptString, &quot;SHA-256&quot;);
    }

    private static String sha512(String encryptString) throws NoSuchAlgorithmException {
        return hash(encryptString, &quot;SHA-512&quot;);
    }

    private static String hash(String encryptString, String hashType) throws NoSuchAlgorithmException {
        MessageDigest md5 = MessageDigest.getInstance(hashType);
        md5.update(encryptString.getBytes(StandardCharsets.UTF_8));
        byte[] digest = md5.digest();
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i &lt; digest.length; i++) {
            String hex = Integer.toHexString(0xff &amp; digest[i]);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }
}
</code></pre>
<blockquote>
<p>点击查看:<a href="https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms">JDK支持的摘要算法实现</a></p>
</blockquote>
<h5 id="拓展实现">拓展实现</h5>
<p>当java标准库提供的算法不足以满足需求时--如上面<code>RipeMD-160</code>算法Java标准库并未提供,我们通常会引入已实现的第三库.而<a href="https://www.bouncycastle.org/">bouncycastle</a>就是一个提供了很多哈希算法和加密算法的第三方库.我们使用maven引入<code>bouncycastle</code>.</p>
<pre><code class="language-java">&lt;dependency&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
    &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;
    &lt;version&gt;1.68&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">private static String ripeMD160(String encryptString) throws NoSuchAlgorithmException {
    //Java标准库中使用java.security.Security注册第三方供应商算法库
    Security.addProvider(new BouncyCastleProvider());
    return hash(encryptString, &quot;RipeMD160&quot;);
}

String encryptString = &quot;hello world&quot;;
System.out.println(ripeMD160(encryptString));
//98c615784ccb5fe5936fbc0cbe9dfdb408d92f0f
</code></pre>
<p>使用<code>java.security.Security.addProvider()</code>注册了<code>bouncycastle</code>后,就可以使用<code>bouncycastle</code>提供的诸多哈希/加密算法.</p>
<h5 id="使用场景">使用场景</h5>
<p>一种常见场景:</p>
<p>当我们下载网络资源时,一般官方为了安全着想,会贴出资源的MD5摘要,目的是为了防止下载内容被篡改,用户下载完资源后可以通过计算资源的MD5与官方提供的MD5是否一致.</p>
<p>另一种常见场景:</p>
<p>使用数据库存储过用户数据的小伙伴应该很清楚,一般而言数据库存放用户密码不会使用明文,而是通过各种手段进行密码加密,防止被人看到明文后偷窃.</p>
<p>很常见的做法是:使用**MD5(MD5(用户明文)+salt)**的方式存储.</p>
<p>目的:为什么要两次md5,甚至还有salt? 原因是因为增加干扰因素,防止人为暴力穷举破解常见密码.(俗称<strong>彩虹表</strong>)</p>
<pre><code class="language-java">String encryptString = &quot;hello world&quot;;
String salt = &quot;dgh/$^@e2&quot;;
System.out.println(md5(encryptString));
//5eb63bbbe01eeed093cb22bb8f5acdc3
System.out.println(md5(md5(encryptString)+salt));
//41e3004572d157ae85eb846afa930ac6
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210615214125.png" alt="截图_选择区域_20210615214125" loading="lazy"></figure>
<h5 id="hmac算法">Hmac算法</h5>
<p>如果我们每次都需要md5(用户明文+salt)的方式,还要自己定义salt,那么有没有现成的算法替代它呢,那就是<code>HmacMD5</code>算法,它相当于加盐的Md5.那么Hmac是什么东西?</p>
<p>**Hmac算法就是一种基于密钥的消息认证码算法,它的全称是Hash-based Message Authentication Code,是一种更安全的消息摘要算法.**Hmac总是配合某种哈希算法一起使用,如<code>HmacMD5,HmacSHA1</code>等</p>
<pre><code class="language-java">private static void hmacMD5() throws NoSuchAlgorithmException, InvalidKeyException {
    //通过HmacMD5获取keyGenerator实例
    KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;HmacMD5&quot;);
    //使用keyGenerator用于生成SecretKey
    SecretKey secretKey = keyGenerator.generateKey();
    //获取编码后数据-随机key-所谓salt 盐值
    byte[] encoded = secretKey.getEncoded();
    //输出16进制的字符串
    System.out.println(new BigInteger(1,encoded).toString(16));
    
    //获取HmacMD5实例
    Mac md5 = Mac.getInstance(&quot;HmacMD5&quot;);
    //使用secretKey初始化HmacMD5
    md5.init(secretKey);
    //update输入数据
    md5.update(&quot;hello world&quot;.getBytes(StandardCharsets.UTF_8));
    //doFinal获取最终hash值
    byte[] res = md5.doFinal();
    //输出16进制的字符串
    System.out.println(new BigInteger(1,res).toString(16));
    //输出8b40d6bd8affe55fabe1c2c3986aaedf
}
</code></pre>
<h4 id="加密算法">加密算法</h4>
<h5 id="对称加密">对称加密</h5>
<p>对称加密即<strong>使用同一个密码对数据进行加/解密</strong>.</p>
<p>相当于密码锁,我给大门上了锁,密码是123456.你可以使用密码123456打开门.</p>
<pre><code class="language-java">public class SymmetricEncrypt {

    private static final String SECRET_KEY = &quot;123456&quot;;

    private static void lock(){
        System.out.println(&quot;我已经通过密码给信息上锁啦! 你得解锁才能看到消息!&quot;);
    }

    private static void unlock(String secretKey){
        if(SECRET_KEY.equals(secretKey)){
            System.out.println(&quot;财富密码是 0635 5631&quot;);
        }else{
            System.out.println(&quot;密码不对哦!别想拿到财富密码&quot;);
        }
    }

    public static void main(String[] args){
        lock();
         //我已经通过密码给信息上锁啦! 你得解锁才能看到消息!
        unlock(&quot;123&quot;);
		//密码不对哦!别想拿到财富密码
        unlock(&quot;123456&quot;);
        //财富密码是 0635 5631
    }
}
</code></pre>
<p>这只是一个简单的例子,用来说明对称加密的作用.但是密码使用简单的6位数非常容易被破解.通常而言密钥的长度直接决定了加密强度,而工作模式和填充模式则可以认为是对称加密算法的参数和格式.以下有常见的对称加密算法:</p>
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">密钥长度</th>
<th style="text-align:left">工作模式</th>
<th style="text-align:left">填充模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DES</td>
<td style="text-align:left">56/64</td>
<td style="text-align:left">ECB/CBC/PCBC/CTR/...</td>
<td style="text-align:left">NoPadding/PKCS5Padding/...</td>
</tr>
<tr>
<td style="text-align:left">AES</td>
<td style="text-align:left">128/192/256</td>
<td style="text-align:left">ECB/CBC/PCBC/CTR/...</td>
<td style="text-align:left">NoPadding/PKCS5Padding/PKCS7Padding/...</td>
</tr>
<tr>
<td style="text-align:left">IDEA</td>
<td style="text-align:left">128</td>
<td style="text-align:left">ECB</td>
<td style="text-align:left">PKCS5Padding/PKCS7Padding/...</td>
</tr>
</tbody>
</table>
<p>其中DES因为密钥长度过短,可以被短时间内暴力破解,所以认为是不安全的对称加密算法,尽量不使用.</p>
<p>我们使用AES加密介绍常规的对称加密正确使用姿势:</p>
<h6 id="aes加密">AES加密</h6>
<pre><code class="language-java">/**
 * Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：
 * 1. 根据算法名称/工作模式/填充模式获取Cipher实例；
 * 2. 根据算法名称初始化一个SecretKey实例，密钥必须是指定长度；
 * 3. 使用SerectKey初始化Cipher实例，并设置加密或解密模式；
 * 4. 传入明文或密文，获得密文或明文。
 */
public class SymmetricEncrypt {

    private static final String SECRET_KEY = &quot;abcdefghABCDEFGH&quot;;

    public static void main(String[] args) throws GeneralSecurityException {
        String message = &quot;hello world&quot;;
        System.out.println(&quot;原文:&quot;+message);
        String encrypt = aesEncrypt(message);
        System.out.println(&quot;密文:&quot;+encrypt);
        String decrypt = aesDecrypt(encrypt);
        System.out.println(&quot;解密后原文:&quot;+decrypt);
        //原文:hello world
        //密文:OQLN7aU8TPwS8DxiFQZgzA==
        //解密后原文:hello world
    }

    /**
     * AES/ECB/PKCS5Padding加密
     * ECB模式要求:16倍数个bytes key
     * 使用Base64
     */
    public static String  aesEncrypt(String encryptString) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
        SecretKey keySpec = new SecretKeySpec(SECRET_KEY.getBytes(StandardCharsets.UTF_8), &quot;AES&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        byte[] encrypt = cipher.doFinal(encryptString.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(encrypt);
    }

    /**
     * AES/ECB/PKCS5Padding解密
     * ECB模式要求:16倍数个bytes key
     */
    public static String aesDecrypt(String decryptString) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
        SecretKey keySpec = new SecretKeySpec(SECRET_KEY.getBytes(StandardCharsets.UTF_8), &quot;AES&quot;);
        cipher.init(Cipher.DECRYPT_MODE, keySpec);
        byte[] decrypt = cipher.doFinal(Base64.getDecoder().decode(decryptString));
        return new String(decrypt,StandardCharsets.UTF_8);
    }
}
</code></pre>
<p><code>ECB</code>模式是最简单的AES工作模式,需要一个16倍数bytes长度*(16bytes = 128bit)*的密钥,然后会根据固定明文生成固定密文,安全系数较低.更好的方式是使用CBC模式,需要一个随机密钥,根据明文每次会生成不同的密文.</p>
<pre><code class="language-java">/**
 * AES/CBC/PKCS5Padding加密
 * CBC模式要求:随机密钥
 */
public static Pair&lt;IvParameterSpec,String&gt; aesCBCEncrypt(String encryptString) throws GeneralSecurityException {
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    SecretKey keySpec = new SecretKeySpec(SECRET_KEY.getBytes(StandardCharsets.UTF_8), &quot;AES&quot;);
    // CBC模式需要生成一个16 bytes的initialization vector:
    SecureRandom sr = SecureRandom.getInstanceStrong();
    byte[] iv = sr.generateSeed(16);
    IvParameterSpec ivps = new IvParameterSpec(iv);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec,ivps);
    byte[] encrypt = cipher.doFinal(encryptString.getBytes(StandardCharsets.UTF_8));
    return new Pair&lt;&gt;(ivps,Base64.getEncoder().encodeToString(encrypt));
}

/**
 * AES/CBC/PKCS5Padding解密
 * ECB模式要求:16个bytes key
 */
public static String aesCBCDecrypt(Pair&lt;IvParameterSpec,String&gt; decryptMsg) throws GeneralSecurityException {
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    SecretKey keySpec = new SecretKeySpec(SECRET_KEY.getBytes(StandardCharsets.UTF_8), &quot;AES&quot;);
    cipher.init(Cipher.DECRYPT_MODE, keySpec,decryptMsg.getKey());
    byte[] decrypt = cipher.doFinal(Base64.getDecoder().decode(decryptMsg.getValue()));
    return new String(decrypt,StandardCharsets.UTF_8);
}

public static void main(String[] args) throws GeneralSecurityException {
    String message = &quot;hello world&quot;;
    System.out.println(&quot;原文:&quot;+message);
    Pair&lt;IvParameterSpec, String&gt; encryptMsg = aesCBCEncrypt(message);
    System.out.println(&quot;密文:&quot;+encryptMsg.getValue());
    String decrypt = aesCBCDecrypt(encryptMsg);
    System.out.println(&quot;解密后原文:&quot;+decrypt);
    //第一次运行:
    //原文:hello world
    //密文:16IL3aOZ7+ApZSJjgYYD1Q==
    //解密后原文:hello world
    //第二次运行:
    //原文:hello world
    //密文:73DsTjyK669ymtssXhBpgg==
    //解密后原文:hello world
}
</code></pre>
<p>从上面可以看出CBC与ECB的区别在于:</p>
<ul>
<li>CBC会需要一个16位的随机bytes作为密钥,而ECB需要一个16位的固定bytes作为密钥.</li>
<li>CBC需要在<code>Cipher</code>加密初始化时传入<code>IvParameterSpec</code>对象,而在解密初始化时,需要加密初始化<code>IvParameterSpec</code>对象,保证是持有相同的密钥.而ECB不需要这个对象作为初始化参数.</li>
<li>CBC每次运行得到的密文是随机的,而ECB是固定的.</li>
</ul>
<p>总结:即CBC模式加密初始化时需要一个随机生成的16位bytes的IV参数,作为随机密钥,解密时需要拿到这个密钥用于解密,因为每次的iv生成的密钥不同,所以每次生成的密文也不同.ECB因为密钥是固定的,所以生成密文也是固定的.</p>
<h6 id="pbe算法">PBE算法</h6>
<p>假设我们允许用户来设置固定密钥,而不使用程序定义的密钥或随机密钥时,那么能指望每个用户的固定密钥都是16倍数的bytes吗?答案是:非常困难.那么有没有办法解决,将用户输入的不固定密钥转换成16倍数的bytes密钥呢.</p>
<p>答案是:使用<code>PBE</code>算法,<code>PBE</code>算法的作用就是:<strong>将用户输入的密钥+一个安全随机口令随机拼凑后计算出真正密钥</strong>.</p>
<pre><code class="language-java">public class PBEDemo {

    public static void main(String[] args) throws Exception {
        // 把BouncyCastle作为Provider添加到java.security:
        Security.addProvider(new BouncyCastleProvider());
        // 原文:
        String message = &quot;hello world&quot;;
        // 加密口令:
        String password = &quot;123456&quot;;
        // 16 bytes随机Salt:
        byte[] salt = SecureRandom.getInstanceStrong().generateSeed(16);
        System.out.printf(&quot;salt: %032x\n&quot;, new BigInteger(1, salt));
        //salt: a84734db267f4a03396e7093e7286af5
        // 加密:
        byte[] data = message.getBytes(&quot;UTF-8&quot;);
        byte[] encrypted = encrypt(password, salt, data);
        System.out.println(&quot;encrypted: &quot; + Base64.getEncoder().encodeToString(encrypted));
        //encrypted: wJbzjLOORcccs3U5FpMEsw==
        // 解密:
        byte[] decrypted = decrypt(password, salt, encrypted);
        System.out.println(&quot;decrypted: &quot; + new String(decrypted, &quot;UTF-8&quot;));
        //decrypted: hello world
    }

    // 加密:
    public static byte[] encrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException {
        PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());
        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);
        SecretKey skey = skeyFactory.generateSecret(keySpec);
        PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000);
        Cipher cipher = Cipher.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);
        return cipher.doFinal(input);
    }

    // 解密:
    public static byte[] decrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException {
        PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());
        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);
        SecretKey skey = skeyFactory.generateSecret(keySpec);
        PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000);
        Cipher cipher = Cipher.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);
        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);
        return cipher.doFinal(input);
    }
}
</code></pre>
<p>总结:</p>
<ul>
<li><code>PBE</code>算法通过用户口令和安全的随机salt计算出Key,然后再进行加密</li>
<li>Key通过口令和安全的随机salt计算得出,大大提高了安全性</li>
<li><code>PBE</code>算法内部使用的仍然是标准对称加密算法（例如AES）</li>
</ul>
<h6 id="dh算法">DH算法</h6>
<p>从上面的例子中,我们都在程序这一侧同时完成加/解密操作.</p>
<p>但假如客户端发送了加密信息,服务器来完成解密操作,但是服务器又没有密钥时,那怎么办呢?</p>
<p>通常有两种做法:</p>
<ol>
<li>
<p>客户端发送加密信息的同时也传输密钥,服务器拿到密钥和加密信息后,再使用密钥去解密.</p>
</li>
<li>
<p>客户端不发送密钥,而是通过两端持有自己的公钥(大家可见)和私钥(大家不可见),然后交换各自的公钥,通过对方的公钥+自己的私钥生成最终的密钥,再使用密钥去解密.</p>
</li>
</ol>
<p>第一种方式,存在显而易见的问题:在加密信息和密钥传输时,如果被中间人(第三方hacker)恶意获取,那么他也可以通过密钥解密,得到原文信息,十分危险.</p>
<p>第二种方式,即<code>DH</code>算法(<em>即密钥交换算法-Diffie-Hellman算法</em>)的原理.</p>
<pre><code class="language-java">public class DHDemo {

    public static void main(String[] args) {
        // Bob和Alice:
        Person bob = new Person(&quot;Bob&quot;);
        Person alice = new Person(&quot;Alice&quot;);

        // 各自生成KeyPair:
        bob.generateKeyPair();
        alice.generateKeyPair();

        // 双方交换各自的PublicKey:
        // Bob根据Alice的PublicKey生成自己的本地密钥:
        bob.generateSecretKey(alice.publicKey.getEncoded());
        // Alice根据Bob的PublicKey生成自己的本地密钥:
        alice.generateSecretKey(bob.publicKey.getEncoded());

        // 检查双方的本地密钥是否相同:
        bob.printKeys();
        alice.printKeys();
        // 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密...
    }
	
    private static class Person {
        public final String name;

        public PublicKey publicKey;
        private PrivateKey privateKey;
        private byte[] secretKey;

        public Person(String name) {
            this.name = name;
        }

        // 生成本地KeyPair:
        public void generateKeyPair() {
            try {
                KeyPairGenerator kpGen = KeyPairGenerator.getInstance(&quot;DH&quot;);
                kpGen.initialize(512);
                KeyPair kp = kpGen.generateKeyPair();
                this.privateKey = kp.getPrivate();
                this.publicKey = kp.getPublic();
            } catch (GeneralSecurityException e) {
                throw new RuntimeException(e);
            }
        }

        public void generateSecretKey(byte[] receivedPubKeyBytes) {
            try {
                // 从byte[]恢复PublicKey:
                X509EncodedKeySpec keySpec = new X509EncodedKeySpec(receivedPubKeyBytes);
                KeyFactory kf = KeyFactory.getInstance(&quot;DH&quot;);
                PublicKey receivedPublicKey = kf.generatePublic(keySpec);
                // 生成本地密钥:
                KeyAgreement keyAgreement = KeyAgreement.getInstance(&quot;DH&quot;);
                keyAgreement.init(this.privateKey); // 自己的PrivateKey
                keyAgreement.doPhase(receivedPublicKey, true); // 对方的PublicKey
                // 生成SecretKey密钥:
                this.secretKey = keyAgreement.generateSecret();
            } catch (GeneralSecurityException e) {
                throw new RuntimeException(e);
            }
        }

        public void printKeys() {
            System.out.printf(&quot;Name: %s\n&quot;, this.name);
            System.out.printf(&quot;Private key: %x\n&quot;, new BigInteger(1, this.privateKey.getEncoded()));
            System.out.printf(&quot;Public key: %x\n&quot;, new BigInteger(1, this.publicKey.getEncoded()));
            System.out.printf(&quot;Secret key: %x\n&quot;, new BigInteger(1, this.secretKey));
        }
    }
}
</code></pre>
<p>输出结果:</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210617153052.png" alt="截图_选择区域_20210617153052" loading="lazy"></figure>
<p>但这其中存在一个问题:即Bob怎么知道对方是不是真的Alice还是中间人(第三方hacker)伪造出来的?Alice提供的公钥是真的Alice提供的吗?Bob并不能辨认出来.</p>
<p>所以说,DH算法并不能解决中间人问题,它只是在不安全通信过程中,交换公钥协商出密钥,再进行对称加密传输.</p>
<h5 id="非对称加密">非对称加密</h5>
<p>所以我们可以从DH算法中看出对称加密算法的局限性:只有拿到相同的密钥才能解密,但又无法避免中间人问题.</p>
<p>但是对称加密为非对称加密奠定了基础,即:<strong>密钥由公钥+私钥组成,公钥公开透明,私钥完全保密.</strong></p>
<p>非对称加密算法:**使用同一对公私玥才能正常加/解密.**如Bob拿到Alice的公钥加密文件,然后发给Alice,Alice必须得用对应的私钥才能解密.</p>
<h6 id="rsa算法">RSA算法</h6>
<p>而非对称加密算法最典型实现就是RSA算法.下面使用Java实现示例:</p>
<pre><code class="language-java">public class RSADemo {

    private static class Person {
        String name;
        // 私钥:
        PrivateKey sk;
        // 公钥:
        PublicKey pk;

        public Person(String name) throws GeneralSecurityException {
            this.name = name;
            // 生成公钥／私钥对:
            KeyPairGenerator kpGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);
            kpGen.initialize(1024);
            KeyPair kp = kpGen.generateKeyPair();
            this.sk = kp.getPrivate();
            this.pk = kp.getPublic();
        }

        // 用公钥加密:
        public byte[] encrypt(byte[] message,PublicKey pk) throws GeneralSecurityException {
            Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, pk);
            return cipher.doFinal(message);
        }

        // 用私钥解密:
        public byte[] decrypt(byte[] input,PrivateKey sk) throws GeneralSecurityException {
            Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);
            cipher.init(Cipher.DECRYPT_MODE, sk);
            return cipher.doFinal(input);
        }
    }

    public static void main(String[] args) throws Exception {
        // 明文:
        byte[] plain = &quot;hello world&quot;.getBytes(&quot;UTF-8&quot;);
        // 创建公钥／私钥对:
        Person alice = new Person(&quot;Alice&quot;);
        Person bob = new Person(&quot;Bob&quot;);
        // Bob用Alice的公钥加密:
        byte[] encrypted = bob.encrypt(plain,alice.pk);
        // 密文输出:encrypted: 7dbf69dc68806ae704fcb1ab81f57931ae...
        System.out.println(String.format(&quot;encrypted: %x&quot;, new BigInteger(1, encrypted)));
        // Alice用私钥解密:
        byte[] decrypted = alice.decrypt(encrypted,alice.sk);
        // 解密后原文输出:decrypted: hello world
        System.out.println(String.format(&quot;decrypted: %s&quot;, new String( decrypted, StandardCharsets.UTF_8)));
        // 假设用Bob的私钥解密
        decrypted = alice.decrypt(encrypted,bob.sk);
        //throws javax.crypto.BadPaddingException: Decryption error
        System.out.println(String.format(&quot;decrypted: %s&quot;, new String( decrypted, StandardCharsets.UTF_8)));
    }
}
</code></pre>
<p>RSA的密钥有256/512/1024/2048/4096等长度,跟所有密钥一样,长度越长,生成的密文安全强度越高,但加/解密消耗的时间就会更多.一般地,我们不直接采用RSA加密密文,而是先通过RSA加密AES密钥,然后通过个人私钥解密RSA得到AES密钥,再通过AES去加/解密密文.这样既保证了密钥安全,又保证了加/解密效率.</p>
<p>但需要注意的是:<strong>RSA算法也无法防止中间人攻击</strong>.主要问题还是在于:Bob不能辨认出Alice是真的还是假的,如果有人伪装成Alice,发送假的Alice公钥给Bob,那Bob会用假的Alice的公钥加密AES密钥,无法保证安全.</p>
<h4 id="签名算法">签名算法</h4>
<p>在使用非对称加密算法时,我们有一个基础认知:</p>
<p><strong>每个人持有一对公开的钥匙和私有的钥匙,使用别人的公开钥匙加密内容,公开钥匙的主人就可以通过自己的私有钥匙去解密</strong>.</p>
<p>那存不存在这么一种情况: 有人用私钥加密内容,并公钥去解密内容,那这样大伙都能通过他的公钥取得密文.</p>
<p>这么做的目的或意义在哪?</p>
<p>其实是为了向所有人表明,这条密文就是这个人发的!别人不能伪造,他也不能抵赖.</p>
<p><strong>使用私钥加密原始数据的摘要信息得到密文就是数字签名,想要解密就只能使用公布数字签名所有者的公钥解密.此时的私钥相当于用户身份--即签名,公钥用来给其他用户验证该签名.</strong></p>
<p>为什么要对原始数据的摘要信息进行加密,而不直接使用原始数据?</p>
<p>原因有两点:</p>
<ol>
<li>摘要算法可以压缩原始数据,压缩后的摘要更容易加/解密.</li>
<li>摘要信息不可逆,无法通过摘要信息逆推原始数据.这样保证了如果修改了原始数据,那么修改后的数据得到的摘要信息与解密后得到的摘要数据不一致,说明原始数据被人篡改了.</li>
</ol>
<h5 id="签名算法过程">签名算法过程</h5>
<figure data-type="image" tabindex="3"><img src="http://img.zhengjianru.work/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%B5%81%E7%A8%8B.png" alt="数字签名流程" loading="lazy"></figure>
<p>可以看出<strong>签名算法=Hash算法+非对称加密算法</strong>.</p>
<p>签名过程即:<code>signature = rsaEncrypt(privateKey, hash(message))</code></p>
<p>解签过程即:<code>hash(message) == rsaDecrypt(publicKey,signarture)</code></p>
<h5 id="常用数字签名算法">常用数字签名算法</h5>
<p><strong>RSA数字签名</strong> ：MD5withRSA、SHA1withRSA、SHA256withRSA</p>
<p><strong>DSA数字签名</strong> ：SHAwithDSA、SHA256withDSA、SHA512withDSA</p>
<p><strong>DSA数字签名</strong> ：secp256k1 (比特币的签名算法)</p>
<p>下面是Java中<code>MD5withRSA</code>应用</p>
<pre><code class="language-java">public class SignatureDemo {

    private static class Person {
        String name;
        // 私钥:
        PrivateKey sk;
        // 公钥:
        PublicKey pk;

        public Person(String name) throws GeneralSecurityException {
            this.name = name;
            // 生成公钥／私钥对:
            KeyPairGenerator kpGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);
            kpGen.initialize(1024);
            KeyPair kp = kpGen.generateKeyPair();
            this.sk = kp.getPrivate();
            this.pk = kp.getPublic();
        }
        // 私钥签名
        public byte[] sign(byte[] message) throws GeneralSecurityException {
            Signature md5withRSA = Signature.getInstance(&quot;MD5withRSA&quot;);
            md5withRSA.initSign(sk);
            md5withRSA.update(message);
            return md5withRSA.sign();
        }

        // 公钥解签并验证
        public boolean verify(byte[] message, byte[] signature,PublicKey pk) throws GeneralSecurityException {
            Signature md5withRSA = Signature.getInstance(&quot;MD5withRSA&quot;);
            md5withRSA.initVerify(pk);
            md5withRSA.update(message);
            return md5withRSA.verify(signature);
        }
    }

    public static void main(String[] args) throws UnsupportedEncodingException, GeneralSecurityException {
        // 明文:
        byte[] messages = &quot;hello world&quot;.getBytes(StandardCharsets.UTF_8);
        // 创建公钥／私钥对:
        Person bob = new Person(&quot;Bob&quot;);
        Person alice = new Person(&quot;Alice&quot;);
        Person doug = new Person(&quot;Doug&quot;);//中间人

        // Bob用自己的密钥签名
        byte[] signature = bob.sign(messages);

        //Bob向Alice发送明文+签名+公钥
        boolean verifyResult = alice.verify(messages, signature, bob.pk);
        System.out.println(verifyResult);//true

        //Doug把公钥换成自己的发给Alice
        verifyResult = alice.verify(messages, signature, doug.pk);
        System.out.println(verifyResult);//false

        //Doug把签名换成了自己,但想伪装成bob所以还是用bob的公钥
        verifyResult = alice.verify(messages, doug.sign(messages), bob.pk);
        System.out.println(verifyResult);//false

        //Doug把公开信息篡改了发送给Alice
        messages = &quot;how are you,alice&quot;.getBytes(StandardCharsets.UTF_8);
        verifyResult = alice.verify(messages, signature, bob.pk);
        System.out.println(verifyResult);//false
    }
}
</code></pre>
<h4 id="数字证书">数字证书</h4>
<p>上面的示例代码中缺少一个最极端的情况:Doug将签名换成了自己的,将Alice存储的Bob公钥偷换成了自己的公钥.</p>
<p>这种情况,Alice根本不会发现跟自己通信的人是Doug而是Bob,除非存储的Bob公钥过期了或删掉了,才会发现不对.</p>
<p>终于,当Alice发现不对劲后,让Bob去找<strong>受信任的证书中心(Certificate Authority - CA)</strong>,为公钥做认证.</p>
<p>于是<strong>证书中心(CA)<strong>用自己的私钥+Bob的公钥+其他的认证信息,生成了</strong>数字证书</strong>(Digital Certificate).</p>
<p>Bob拥有了<strong>证书中心(CA)<strong>开具的</strong>数字证书</strong>证明后,在签名的时候附上<strong>数字证书</strong>,传给Alice.</p>
<p>Alice在收到签名后,使用<strong>证书中心(CA)<strong>的公钥去解开</strong>数字证书</strong>,发现了公钥并能成功解密签名,说明这确实是Bob的数字签名.</p>
<p>流程如下:</p>
<figure data-type="image" tabindex="4"><img src="http://img.zhengjianru.work/%E5%B8%A6%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E7%AD%BE%E5%90%8D%E6%B5%81%E7%A8%8B.png" alt="带数字证书的签名流程" loading="lazy"></figure>
<p>最常见的<strong>数字证书</strong>的应用如:HTTPS协议</p>
<p>以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：</p>
<ol>
<li>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</li>
<li>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</li>
<li>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</li>
</ol>
<p>上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。</p>
<p>注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商<a href="https://en.wikipedia.org/wiki/DigiNotar">DigiNotar</a>就发生过私钥泄漏导致公司破产的事故。</p>
<blockquote>
<p>参考资料:<br>
<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943717668160">廖雪峰Java教程</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<p>为了防止通信过程中,数据被窃听/篡改/伪造,加密成为了对应手段.计算机密码学是建立在严格是数学基础上的,已经发展成为了一门科学.对于编写一个安全的加密算法是十分困难的,所以要遵循下面三个原则:</p>
<ol>
<li>不要自己设计山寨加密算法</li>
<li>不要自己实现已有加密算法</li>
<li>不要自己修改已有加密算法</li>
</ol>
<h4 id="编码算法">编码算法</h4>
<p>编码算法并不是加密算法,他们的目的是为了让二进制数据和文本有对应关系.</p>
<h5 id="url编码">URL编码</h5>
<p>URL编码是浏览器给服务器发送数据时使用的编码,目的是为了将字符编译成%前缀的文本,便于服务器和浏览器相互识别.如Java中提供了标准函数库:<code>java.net.URLDecoder、java.net.URLEncoder</code></p>
<pre><code class="language-java">public class URLCoderDemo {

    public static void main(String[] args) throws UnsupportedEncodingException {
        String encode = URLEncoder.encode(&quot;哈哈哈哈&quot;, StandardCharsets.UTF_8.toString());
        System.out.println(&quot;url 编码后的结果:&quot;+encode);
        //输出:url 编码后的结果:%E5%93%88%E5%93%88%E5%93%88%E5%93%88
        String decode = URLDecoder.decode(encode, StandardCharsets.UTF_8.toString());
        System.out.println(&quot;url 解码后的结果:&quot;+decode);
        //输出:url 解码后的结果:哈哈哈哈
    }
}
</code></pre>
<h5 id="base64编码">Base64编码</h5>
<p>Base64编码是将二进制数据编译成文本,且只包含<code>A</code><sub>`Z`、`a`</sub><code>z</code>、<code>0</code>~<code>9</code>、<code>+</code>、<code>/</code>、<code>=</code>这些字符.同样的,Java中提供了标准函数库:<code>java.util.Base64</code></p>
<pre><code class="language-java">public class Base64Demo {

    public static void main(String[] args){

        String encode = Base64.getEncoder().encodeToString(&quot;哈哈&quot;.getBytes(StandardCharsets.UTF_8));
        System.out.println(&quot;base64编码后的结果:&quot;+encode);
        //base64编码后的结果:5ZOI5ZOI
        
        byte[] decode = Base64.getDecoder().decode(encode);
        System.out.println(&quot;base64解码后的结果:&quot;+ Arrays.toString(decode));
        //base64解码后的结果:[-27, -109, -120, -27, -109, -120]
        System.out.println(&quot;base64解码后的结果:&quot;+ new String(decode,StandardCharsets.UTF_8));
        //base64解码后的结果:哈哈
    }
}
</code></pre>
<h4 id="哈希算法">哈希算法</h4>
<p>Hash-翻译散列或哈希算法-又名摘要算法(Digest).</p>
<p>作用在于:输入一组任意长度的数据,通过哈希算法,压缩成固定长度的摘要.</p>
<p>最主要特点:</p>
<ul>
<li>相同的输入一定得到相同的输出.</li>
<li>不相同的输入大概率得到不相同的输出.</li>
</ul>
<p>最直接的,如Java中<code>java.lang.Object.hashcode()</code>就是一个哈希算法.</p>
<pre><code class="language-java">//open jdk1.8 native hashcode:
System.out.println(new URLCoderDemo().hashCode());//1304836502
System.out.println(new Base64Demo().hashCode());//225534817
System.out.println(new HashDemo().hashCode());//1878246837
</code></pre>
<h5 id="哈希碰撞">哈希碰撞</h5>
<p>哈希碰撞是指:不同的输入得到相同的输出</p>
<pre><code class="language-java">System.out.println(&quot;AaAaAa&quot;.hashCode());// 1952508096
System.out.println(&quot;BBAaBB&quot;.hashCode());// 1952508096
</code></pre>
<p>为什么会出现这种事情?</p>
<p>从哈希算法的作用中可以得到解释:<strong>通过散列函数,将任意长度的数据压缩成固定长度的摘要</strong>.既然是固定长度,那么它的输出数据一定是可以穷举出来的.如长度为4的一维int数组,一共能存10<sup>4个数字.那么无限的输入集合,与10</sup>4个输出集合,必然会出现多个输入出现相同输出的情况,也就是我们所说的<strong>哈希碰撞</strong>.</p>
<p>当我们设计一个哈希算法时,碰撞的概率是该函数好坏的评判标准.一个安全的哈希算法必须满足下面两个条件:</p>
<ul>
<li>碰撞概率低</li>
<li>不可猜出输出</li>
</ul>
<p><strong>不可猜出输出:即输出规律不可循.</strong></p>
<p>如果<code>AaAaAa.haschode()=1952508096;AaAaAb.hashcode()=1952508097;</code>,那我们可以这个<code>hashcode()</code>是一个不安全的哈希算法.</p>
<h5 id="常见哈希算法">常见哈希算法</h5>
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">输出长度（位）</th>
<th style="text-align:left">输出长度（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MD5</td>
<td style="text-align:left">128 bits</td>
<td style="text-align:left">16 bytes</td>
</tr>
<tr>
<td style="text-align:left">SHA-1</td>
<td style="text-align:left">160 bits</td>
<td style="text-align:left">20 bytes</td>
</tr>
<tr>
<td style="text-align:left">RipeMD-160</td>
<td style="text-align:left">160 bits</td>
<td style="text-align:left">20 bytes</td>
</tr>
<tr>
<td style="text-align:left">SHA-256</td>
<td style="text-align:left">256 bits</td>
<td style="text-align:left">32 bytes</td>
</tr>
<tr>
<td style="text-align:left">SHA-512</td>
<td style="text-align:left">512 bits</td>
<td style="text-align:left">64 bytes</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">public class HashDemo {

    public static void main(String[] args) throws NoSuchAlgorithmException {
        String encryptString = &quot;hello world&quot;;
        System.out.println(md5(encryptString));
        //md5摘要输出:5eb63bbbe01eeed093cb22bb8f5acdc3
        System.out.println(sha1(encryptString));
        //sha1摘要输出:2aae6c35c94fcfb415dbe95f408b9ce91ee846ed
        System.out.println(sha256(encryptString));
        //sha256摘要输出:b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
        System.out.println(sha512(encryptString));
        //sha512摘要输出:                 			309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f
    	//RipeMD-160 java标准库中暂未提供算法实现
    }

    private static String md5(String encryptString) throws NoSuchAlgorithmException {
        return hash(encryptString, &quot;MD5&quot;);
    }

    private static String sha1(String encryptString) throws NoSuchAlgorithmException {
        return hash(encryptString, &quot;SHA-1&quot;);
    }

    private static String sha256(String encryptString) throws NoSuchAlgorithmException {
        return hash(encryptString, &quot;SHA-256&quot;);
    }

    private static String sha512(String encryptString) throws NoSuchAlgorithmException {
        return hash(encryptString, &quot;SHA-512&quot;);
    }

    private static String hash(String encryptString, String hashType) throws NoSuchAlgorithmException {
        MessageDigest md5 = MessageDigest.getInstance(hashType);
        md5.update(encryptString.getBytes(StandardCharsets.UTF_8));
        byte[] digest = md5.digest();
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i &lt; digest.length; i++) {
            String hex = Integer.toHexString(0xff &amp; digest[i]);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }
}
</code></pre>
<blockquote>
<p>点击查看:<a href="https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms">JDK支持的摘要算法实现</a></p>
</blockquote>
<h5 id="拓展实现">拓展实现</h5>
<p>当java标准库提供的算法不足以满足需求时--如上面<code>RipeMD-160</code>算法Java标准库并未提供,我们通常会引入已实现的第三库.而<a href="https://www.bouncycastle.org/">bouncycastle</a>就是一个提供了很多哈希算法和加密算法的第三方库.我们使用maven引入<code>bouncycastle</code>.</p>
<pre><code class="language-java">&lt;dependency&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
    &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;
    &lt;version&gt;1.68&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">private static String ripeMD160(String encryptString) throws NoSuchAlgorithmException {
    //Java标准库中使用java.security.Security注册第三方供应商算法库
    Security.addProvider(new BouncyCastleProvider());
    return hash(encryptString, &quot;RipeMD160&quot;);
}

String encryptString = &quot;hello world&quot;;
System.out.println(ripeMD160(encryptString));
//98c615784ccb5fe5936fbc0cbe9dfdb408d92f0f
</code></pre>
<p>使用<code>java.security.Security.addProvider()</code>注册了<code>bouncycastle</code>后,就可以使用<code>bouncycastle</code>提供的诸多哈希/加密算法.</p>
<h5 id="使用场景">使用场景</h5>
<p>一种常见场景:</p>
<p>当我们下载网络资源时,一般官方为了安全着想,会贴出资源的MD5摘要,目的是为了防止下载内容被篡改,用户下载完资源后可以通过计算资源的MD5与官方提供的MD5是否一致.</p>
<p>另一种常见场景:</p>
<p>使用数据库存储过用户数据的小伙伴应该很清楚,一般而言数据库存放用户密码不会使用明文,而是通过各种手段进行密码加密,防止被人看到明文后偷窃.</p>
<p>很常见的做法是:使用**MD5(MD5(用户明文)+salt)**的方式存储.</p>
<p>目的:为什么要两次md5,甚至还有salt? 原因是因为增加干扰因素,防止人为暴力穷举破解常见密码.(俗称<strong>彩虹表</strong>)</p>
<pre><code class="language-java">String encryptString = &quot;hello world&quot;;
String salt = &quot;dgh/$^@e2&quot;;
System.out.println(md5(encryptString));
//5eb63bbbe01eeed093cb22bb8f5acdc3
System.out.println(md5(md5(encryptString)+salt));
//41e3004572d157ae85eb846afa930ac6
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210615214125.png" alt="截图_选择区域_20210615214125" loading="lazy"></figure>
<h5 id="hmac算法">Hmac算法</h5>
<p>如果我们每次都需要md5(用户明文+salt)的方式,还要自己定义salt,那么有没有现成的算法替代它呢,那就是<code>HmacMD5</code>算法,它相当于加盐的Md5.那么Hmac是什么东西?</p>
<p>**Hmac算法就是一种基于密钥的消息认证码算法,它的全称是Hash-based Message Authentication Code,是一种更安全的消息摘要算法.**Hmac总是配合某种哈希算法一起使用,如<code>HmacMD5,HmacSHA1</code>等</p>
<pre><code class="language-java">private static void hmacMD5() throws NoSuchAlgorithmException, InvalidKeyException {
    //通过HmacMD5获取keyGenerator实例
    KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;HmacMD5&quot;);
    //使用keyGenerator用于生成SecretKey
    SecretKey secretKey = keyGenerator.generateKey();
    //获取编码后数据-随机key-所谓salt 盐值
    byte[] encoded = secretKey.getEncoded();
    //输出16进制的字符串
    System.out.println(new BigInteger(1,encoded).toString(16));
    
    //获取HmacMD5实例
    Mac md5 = Mac.getInstance(&quot;HmacMD5&quot;);
    //使用secretKey初始化HmacMD5
    md5.init(secretKey);
    //update输入数据
    md5.update(&quot;hello world&quot;.getBytes(StandardCharsets.UTF_8));
    //doFinal获取最终hash值
    byte[] res = md5.doFinal();
    //输出16进制的字符串
    System.out.println(new BigInteger(1,res).toString(16));
    //输出8b40d6bd8affe55fabe1c2c3986aaedf
}
</code></pre>
<h4 id="加密算法">加密算法</h4>
<h5 id="对称加密">对称加密</h5>
<p>对称加密即<strong>使用同一个密码对数据进行加/解密</strong>.</p>
<p>相当于密码锁,我给大门上了锁,密码是123456.你可以使用密码123456打开门.</p>
<pre><code class="language-java">public class SymmetricEncrypt {

    private static final String SECRET_KEY = &quot;123456&quot;;

    private static void lock(){
        System.out.println(&quot;我已经通过密码给信息上锁啦! 你得解锁才能看到消息!&quot;);
    }

    private static void unlock(String secretKey){
        if(SECRET_KEY.equals(secretKey)){
            System.out.println(&quot;财富密码是 0635 5631&quot;);
        }else{
            System.out.println(&quot;密码不对哦!别想拿到财富密码&quot;);
        }
    }

    public static void main(String[] args){
        lock();
         //我已经通过密码给信息上锁啦! 你得解锁才能看到消息!
        unlock(&quot;123&quot;);
		//密码不对哦!别想拿到财富密码
        unlock(&quot;123456&quot;);
        //财富密码是 0635 5631
    }
}
</code></pre>
<p>这只是一个简单的例子,用来说明对称加密的作用.但是密码使用简单的6位数非常容易被破解.通常而言密钥的长度直接决定了加密强度,而工作模式和填充模式则可以认为是对称加密算法的参数和格式.以下有常见的对称加密算法:</p>
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">密钥长度</th>
<th style="text-align:left">工作模式</th>
<th style="text-align:left">填充模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DES</td>
<td style="text-align:left">56/64</td>
<td style="text-align:left">ECB/CBC/PCBC/CTR/...</td>
<td style="text-align:left">NoPadding/PKCS5Padding/...</td>
</tr>
<tr>
<td style="text-align:left">AES</td>
<td style="text-align:left">128/192/256</td>
<td style="text-align:left">ECB/CBC/PCBC/CTR/...</td>
<td style="text-align:left">NoPadding/PKCS5Padding/PKCS7Padding/...</td>
</tr>
<tr>
<td style="text-align:left">IDEA</td>
<td style="text-align:left">128</td>
<td style="text-align:left">ECB</td>
<td style="text-align:left">PKCS5Padding/PKCS7Padding/...</td>
</tr>
</tbody>
</table>
<p>其中DES因为密钥长度过短,可以被短时间内暴力破解,所以认为是不安全的对称加密算法,尽量不使用.</p>
<p>我们使用AES加密介绍常规的对称加密正确使用姿势:</p>
<h6 id="aes加密">AES加密</h6>
<pre><code class="language-java">/**
 * Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：
 * 1. 根据算法名称/工作模式/填充模式获取Cipher实例；
 * 2. 根据算法名称初始化一个SecretKey实例，密钥必须是指定长度；
 * 3. 使用SerectKey初始化Cipher实例，并设置加密或解密模式；
 * 4. 传入明文或密文，获得密文或明文。
 */
public class SymmetricEncrypt {

    private static final String SECRET_KEY = &quot;abcdefghABCDEFGH&quot;;

    public static void main(String[] args) throws GeneralSecurityException {
        String message = &quot;hello world&quot;;
        System.out.println(&quot;原文:&quot;+message);
        String encrypt = aesEncrypt(message);
        System.out.println(&quot;密文:&quot;+encrypt);
        String decrypt = aesDecrypt(encrypt);
        System.out.println(&quot;解密后原文:&quot;+decrypt);
        //原文:hello world
        //密文:OQLN7aU8TPwS8DxiFQZgzA==
        //解密后原文:hello world
    }

    /**
     * AES/ECB/PKCS5Padding加密
     * ECB模式要求:16倍数个bytes key
     * 使用Base64
     */
    public static String  aesEncrypt(String encryptString) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
        SecretKey keySpec = new SecretKeySpec(SECRET_KEY.getBytes(StandardCharsets.UTF_8), &quot;AES&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        byte[] encrypt = cipher.doFinal(encryptString.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(encrypt);
    }

    /**
     * AES/ECB/PKCS5Padding解密
     * ECB模式要求:16倍数个bytes key
     */
    public static String aesDecrypt(String decryptString) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
        SecretKey keySpec = new SecretKeySpec(SECRET_KEY.getBytes(StandardCharsets.UTF_8), &quot;AES&quot;);
        cipher.init(Cipher.DECRYPT_MODE, keySpec);
        byte[] decrypt = cipher.doFinal(Base64.getDecoder().decode(decryptString));
        return new String(decrypt,StandardCharsets.UTF_8);
    }
}
</code></pre>
<p><code>ECB</code>模式是最简单的AES工作模式,需要一个16倍数bytes长度*(16bytes = 128bit)*的密钥,然后会根据固定明文生成固定密文,安全系数较低.更好的方式是使用CBC模式,需要一个随机密钥,根据明文每次会生成不同的密文.</p>
<pre><code class="language-java">/**
 * AES/CBC/PKCS5Padding加密
 * CBC模式要求:随机密钥
 */
public static Pair&lt;IvParameterSpec,String&gt; aesCBCEncrypt(String encryptString) throws GeneralSecurityException {
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    SecretKey keySpec = new SecretKeySpec(SECRET_KEY.getBytes(StandardCharsets.UTF_8), &quot;AES&quot;);
    // CBC模式需要生成一个16 bytes的initialization vector:
    SecureRandom sr = SecureRandom.getInstanceStrong();
    byte[] iv = sr.generateSeed(16);
    IvParameterSpec ivps = new IvParameterSpec(iv);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec,ivps);
    byte[] encrypt = cipher.doFinal(encryptString.getBytes(StandardCharsets.UTF_8));
    return new Pair&lt;&gt;(ivps,Base64.getEncoder().encodeToString(encrypt));
}

/**
 * AES/CBC/PKCS5Padding解密
 * ECB模式要求:16个bytes key
 */
public static String aesCBCDecrypt(Pair&lt;IvParameterSpec,String&gt; decryptMsg) throws GeneralSecurityException {
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    SecretKey keySpec = new SecretKeySpec(SECRET_KEY.getBytes(StandardCharsets.UTF_8), &quot;AES&quot;);
    cipher.init(Cipher.DECRYPT_MODE, keySpec,decryptMsg.getKey());
    byte[] decrypt = cipher.doFinal(Base64.getDecoder().decode(decryptMsg.getValue()));
    return new String(decrypt,StandardCharsets.UTF_8);
}

public static void main(String[] args) throws GeneralSecurityException {
    String message = &quot;hello world&quot;;
    System.out.println(&quot;原文:&quot;+message);
    Pair&lt;IvParameterSpec, String&gt; encryptMsg = aesCBCEncrypt(message);
    System.out.println(&quot;密文:&quot;+encryptMsg.getValue());
    String decrypt = aesCBCDecrypt(encryptMsg);
    System.out.println(&quot;解密后原文:&quot;+decrypt);
    //第一次运行:
    //原文:hello world
    //密文:16IL3aOZ7+ApZSJjgYYD1Q==
    //解密后原文:hello world
    //第二次运行:
    //原文:hello world
    //密文:73DsTjyK669ymtssXhBpgg==
    //解密后原文:hello world
}
</code></pre>
<p>从上面可以看出CBC与ECB的区别在于:</p>
<ul>
<li>CBC会需要一个16位的随机bytes作为密钥,而ECB需要一个16位的固定bytes作为密钥.</li>
<li>CBC需要在<code>Cipher</code>加密初始化时传入<code>IvParameterSpec</code>对象,而在解密初始化时,需要加密初始化<code>IvParameterSpec</code>对象,保证是持有相同的密钥.而ECB不需要这个对象作为初始化参数.</li>
<li>CBC每次运行得到的密文是随机的,而ECB是固定的.</li>
</ul>
<p>总结:即CBC模式加密初始化时需要一个随机生成的16位bytes的IV参数,作为随机密钥,解密时需要拿到这个密钥用于解密,因为每次的iv生成的密钥不同,所以每次生成的密文也不同.ECB因为密钥是固定的,所以生成密文也是固定的.</p>
<h6 id="pbe算法">PBE算法</h6>
<p>假设我们允许用户来设置固定密钥,而不使用程序定义的密钥或随机密钥时,那么能指望每个用户的固定密钥都是16倍数的bytes吗?答案是:非常困难.那么有没有办法解决,将用户输入的不固定密钥转换成16倍数的bytes密钥呢.</p>
<p>答案是:使用<code>PBE</code>算法,<code>PBE</code>算法的作用就是:<strong>将用户输入的密钥+一个安全随机口令随机拼凑后计算出真正密钥</strong>.</p>
<pre><code class="language-java">public class PBEDemo {

    public static void main(String[] args) throws Exception {
        // 把BouncyCastle作为Provider添加到java.security:
        Security.addProvider(new BouncyCastleProvider());
        // 原文:
        String message = &quot;hello world&quot;;
        // 加密口令:
        String password = &quot;123456&quot;;
        // 16 bytes随机Salt:
        byte[] salt = SecureRandom.getInstanceStrong().generateSeed(16);
        System.out.printf(&quot;salt: %032x\n&quot;, new BigInteger(1, salt));
        //salt: a84734db267f4a03396e7093e7286af5
        // 加密:
        byte[] data = message.getBytes(&quot;UTF-8&quot;);
        byte[] encrypted = encrypt(password, salt, data);
        System.out.println(&quot;encrypted: &quot; + Base64.getEncoder().encodeToString(encrypted));
        //encrypted: wJbzjLOORcccs3U5FpMEsw==
        // 解密:
        byte[] decrypted = decrypt(password, salt, encrypted);
        System.out.println(&quot;decrypted: &quot; + new String(decrypted, &quot;UTF-8&quot;));
        //decrypted: hello world
    }

    // 加密:
    public static byte[] encrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException {
        PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());
        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);
        SecretKey skey = skeyFactory.generateSecret(keySpec);
        PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000);
        Cipher cipher = Cipher.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);
        return cipher.doFinal(input);
    }

    // 解密:
    public static byte[] decrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException {
        PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());
        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);
        SecretKey skey = skeyFactory.generateSecret(keySpec);
        PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000);
        Cipher cipher = Cipher.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);
        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);
        return cipher.doFinal(input);
    }
}
</code></pre>
<p>总结:</p>
<ul>
<li><code>PBE</code>算法通过用户口令和安全的随机salt计算出Key,然后再进行加密</li>
<li>Key通过口令和安全的随机salt计算得出,大大提高了安全性</li>
<li><code>PBE</code>算法内部使用的仍然是标准对称加密算法（例如AES）</li>
</ul>
<h6 id="dh算法">DH算法</h6>
<p>从上面的例子中,我们都在程序这一侧同时完成加/解密操作.</p>
<p>但假如客户端发送了加密信息,服务器来完成解密操作,但是服务器又没有密钥时,那怎么办呢?</p>
<p>通常有两种做法:</p>
<ol>
<li>
<p>客户端发送加密信息的同时也传输密钥,服务器拿到密钥和加密信息后,再使用密钥去解密.</p>
</li>
<li>
<p>客户端不发送密钥,而是通过两端持有自己的公钥(大家可见)和私钥(大家不可见),然后交换各自的公钥,通过对方的公钥+自己的私钥生成最终的密钥,再使用密钥去解密.</p>
</li>
</ol>
<p>第一种方式,存在显而易见的问题:在加密信息和密钥传输时,如果被中间人(第三方hacker)恶意获取,那么他也可以通过密钥解密,得到原文信息,十分危险.</p>
<p>第二种方式,即<code>DH</code>算法(<em>即密钥交换算法-Diffie-Hellman算法</em>)的原理.</p>
<pre><code class="language-java">public class DHDemo {

    public static void main(String[] args) {
        // Bob和Alice:
        Person bob = new Person(&quot;Bob&quot;);
        Person alice = new Person(&quot;Alice&quot;);

        // 各自生成KeyPair:
        bob.generateKeyPair();
        alice.generateKeyPair();

        // 双方交换各自的PublicKey:
        // Bob根据Alice的PublicKey生成自己的本地密钥:
        bob.generateSecretKey(alice.publicKey.getEncoded());
        // Alice根据Bob的PublicKey生成自己的本地密钥:
        alice.generateSecretKey(bob.publicKey.getEncoded());

        // 检查双方的本地密钥是否相同:
        bob.printKeys();
        alice.printKeys();
        // 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密...
    }
	
    private static class Person {
        public final String name;

        public PublicKey publicKey;
        private PrivateKey privateKey;
        private byte[] secretKey;

        public Person(String name) {
            this.name = name;
        }

        // 生成本地KeyPair:
        public void generateKeyPair() {
            try {
                KeyPairGenerator kpGen = KeyPairGenerator.getInstance(&quot;DH&quot;);
                kpGen.initialize(512);
                KeyPair kp = kpGen.generateKeyPair();
                this.privateKey = kp.getPrivate();
                this.publicKey = kp.getPublic();
            } catch (GeneralSecurityException e) {
                throw new RuntimeException(e);
            }
        }

        public void generateSecretKey(byte[] receivedPubKeyBytes) {
            try {
                // 从byte[]恢复PublicKey:
                X509EncodedKeySpec keySpec = new X509EncodedKeySpec(receivedPubKeyBytes);
                KeyFactory kf = KeyFactory.getInstance(&quot;DH&quot;);
                PublicKey receivedPublicKey = kf.generatePublic(keySpec);
                // 生成本地密钥:
                KeyAgreement keyAgreement = KeyAgreement.getInstance(&quot;DH&quot;);
                keyAgreement.init(this.privateKey); // 自己的PrivateKey
                keyAgreement.doPhase(receivedPublicKey, true); // 对方的PublicKey
                // 生成SecretKey密钥:
                this.secretKey = keyAgreement.generateSecret();
            } catch (GeneralSecurityException e) {
                throw new RuntimeException(e);
            }
        }

        public void printKeys() {
            System.out.printf(&quot;Name: %s\n&quot;, this.name);
            System.out.printf(&quot;Private key: %x\n&quot;, new BigInteger(1, this.privateKey.getEncoded()));
            System.out.printf(&quot;Public key: %x\n&quot;, new BigInteger(1, this.publicKey.getEncoded()));
            System.out.printf(&quot;Secret key: %x\n&quot;, new BigInteger(1, this.secretKey));
        }
    }
}
</code></pre>
<p>输出结果:</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210617153052.png" alt="截图_选择区域_20210617153052" loading="lazy"></figure>
<p>但这其中存在一个问题:即Bob怎么知道对方是不是真的Alice还是中间人(第三方hacker)伪造出来的?Alice提供的公钥是真的Alice提供的吗?Bob并不能辨认出来.</p>
<p>所以说,DH算法并不能解决中间人问题,它只是在不安全通信过程中,交换公钥协商出密钥,再进行对称加密传输.</p>
<h5 id="非对称加密">非对称加密</h5>
<p>所以我们可以从DH算法中看出对称加密算法的局限性:只有拿到相同的密钥才能解密,但又无法避免中间人问题.</p>
<p>但是对称加密为非对称加密奠定了基础,即:<strong>密钥由公钥+私钥组成,公钥公开透明,私钥完全保密.</strong></p>
<p>非对称加密算法:**使用同一对公私玥才能正常加/解密.**如Bob拿到Alice的公钥加密文件,然后发给Alice,Alice必须得用对应的私钥才能解密.</p>
<h6 id="rsa算法">RSA算法</h6>
<p>而非对称加密算法最典型实现就是RSA算法.下面使用Java实现示例:</p>
<pre><code class="language-java">public class RSADemo {

    private static class Person {
        String name;
        // 私钥:
        PrivateKey sk;
        // 公钥:
        PublicKey pk;

        public Person(String name) throws GeneralSecurityException {
            this.name = name;
            // 生成公钥／私钥对:
            KeyPairGenerator kpGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);
            kpGen.initialize(1024);
            KeyPair kp = kpGen.generateKeyPair();
            this.sk = kp.getPrivate();
            this.pk = kp.getPublic();
        }

        // 用公钥加密:
        public byte[] encrypt(byte[] message,PublicKey pk) throws GeneralSecurityException {
            Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, pk);
            return cipher.doFinal(message);
        }

        // 用私钥解密:
        public byte[] decrypt(byte[] input,PrivateKey sk) throws GeneralSecurityException {
            Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);
            cipher.init(Cipher.DECRYPT_MODE, sk);
            return cipher.doFinal(input);
        }
    }

    public static void main(String[] args) throws Exception {
        // 明文:
        byte[] plain = &quot;hello world&quot;.getBytes(&quot;UTF-8&quot;);
        // 创建公钥／私钥对:
        Person alice = new Person(&quot;Alice&quot;);
        Person bob = new Person(&quot;Bob&quot;);
        // Bob用Alice的公钥加密:
        byte[] encrypted = bob.encrypt(plain,alice.pk);
        // 密文输出:encrypted: 7dbf69dc68806ae704fcb1ab81f57931ae...
        System.out.println(String.format(&quot;encrypted: %x&quot;, new BigInteger(1, encrypted)));
        // Alice用私钥解密:
        byte[] decrypted = alice.decrypt(encrypted,alice.sk);
        // 解密后原文输出:decrypted: hello world
        System.out.println(String.format(&quot;decrypted: %s&quot;, new String( decrypted, StandardCharsets.UTF_8)));
        // 假设用Bob的私钥解密
        decrypted = alice.decrypt(encrypted,bob.sk);
        //throws javax.crypto.BadPaddingException: Decryption error
        System.out.println(String.format(&quot;decrypted: %s&quot;, new String( decrypted, StandardCharsets.UTF_8)));
    }
}
</code></pre>
<p>RSA的密钥有256/512/1024/2048/4096等长度,跟所有密钥一样,长度越长,生成的密文安全强度越高,但加/解密消耗的时间就会更多.一般地,我们不直接采用RSA加密密文,而是先通过RSA加密AES密钥,然后通过个人私钥解密RSA得到AES密钥,再通过AES去加/解密密文.这样既保证了密钥安全,又保证了加/解密效率.</p>
<p>但需要注意的是:<strong>RSA算法也无法防止中间人攻击</strong>.主要问题还是在于:Bob不能辨认出Alice是真的还是假的,如果有人伪装成Alice,发送假的Alice公钥给Bob,那Bob会用假的Alice的公钥加密AES密钥,无法保证安全.</p>
<h4 id="签名算法">签名算法</h4>
<p>在使用非对称加密算法时,我们有一个基础认知:</p>
<p><strong>每个人持有一对公开的钥匙和私有的钥匙,使用别人的公开钥匙加密内容,公开钥匙的主人就可以通过自己的私有钥匙去解密</strong>.</p>
<p>那存不存在这么一种情况: 有人用私钥加密内容,并公钥去解密内容,那这样大伙都能通过他的公钥取得密文.</p>
<p>这么做的目的或意义在哪?</p>
<p>其实是为了向所有人表明,这条密文就是这个人发的!别人不能伪造,他也不能抵赖.</p>
<p><strong>使用私钥加密原始数据的摘要信息得到密文就是数字签名,想要解密就只能使用公布数字签名所有者的公钥解密.此时的私钥相当于用户身份--即签名,公钥用来给其他用户验证该签名.</strong></p>
<p>为什么要对原始数据的摘要信息进行加密,而不直接使用原始数据?</p>
<p>原因有两点:</p>
<ol>
<li>摘要算法可以压缩原始数据,压缩后的摘要更容易加/解密.</li>
<li>摘要信息不可逆,无法通过摘要信息逆推原始数据.这样保证了如果修改了原始数据,那么修改后的数据得到的摘要信息与解密后得到的摘要数据不一致,说明原始数据被人篡改了.</li>
</ol>
<h5 id="签名算法过程">签名算法过程</h5>
<figure data-type="image" tabindex="3"><img src="http://img.zhengjianru.work/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%B5%81%E7%A8%8B.png" alt="数字签名流程" loading="lazy"></figure>
<p>可以看出<strong>签名算法=Hash算法+非对称加密算法</strong>.</p>
<p>签名过程即:<code>signature = rsaEncrypt(privateKey, hash(message))</code></p>
<p>解签过程即:<code>hash(message) == rsaDecrypt(publicKey,signarture)</code></p>
<h5 id="常用数字签名算法">常用数字签名算法</h5>
<p><strong>RSA数字签名</strong> ：MD5withRSA、SHA1withRSA、SHA256withRSA</p>
<p><strong>DSA数字签名</strong> ：SHAwithDSA、SHA256withDSA、SHA512withDSA</p>
<p><strong>DSA数字签名</strong> ：secp256k1 (比特币的签名算法)</p>
<p>下面是Java中<code>MD5withRSA</code>应用</p>
<pre><code class="language-java">public class SignatureDemo {

    private static class Person {
        String name;
        // 私钥:
        PrivateKey sk;
        // 公钥:
        PublicKey pk;

        public Person(String name) throws GeneralSecurityException {
            this.name = name;
            // 生成公钥／私钥对:
            KeyPairGenerator kpGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);
            kpGen.initialize(1024);
            KeyPair kp = kpGen.generateKeyPair();
            this.sk = kp.getPrivate();
            this.pk = kp.getPublic();
        }
        // 私钥签名
        public byte[] sign(byte[] message) throws GeneralSecurityException {
            Signature md5withRSA = Signature.getInstance(&quot;MD5withRSA&quot;);
            md5withRSA.initSign(sk);
            md5withRSA.update(message);
            return md5withRSA.sign();
        }

        // 公钥解签并验证
        public boolean verify(byte[] message, byte[] signature,PublicKey pk) throws GeneralSecurityException {
            Signature md5withRSA = Signature.getInstance(&quot;MD5withRSA&quot;);
            md5withRSA.initVerify(pk);
            md5withRSA.update(message);
            return md5withRSA.verify(signature);
        }
    }

    public static void main(String[] args) throws UnsupportedEncodingException, GeneralSecurityException {
        // 明文:
        byte[] messages = &quot;hello world&quot;.getBytes(StandardCharsets.UTF_8);
        // 创建公钥／私钥对:
        Person bob = new Person(&quot;Bob&quot;);
        Person alice = new Person(&quot;Alice&quot;);
        Person doug = new Person(&quot;Doug&quot;);//中间人

        // Bob用自己的密钥签名
        byte[] signature = bob.sign(messages);

        //Bob向Alice发送明文+签名+公钥
        boolean verifyResult = alice.verify(messages, signature, bob.pk);
        System.out.println(verifyResult);//true

        //Doug把公钥换成自己的发给Alice
        verifyResult = alice.verify(messages, signature, doug.pk);
        System.out.println(verifyResult);//false

        //Doug把签名换成了自己,但想伪装成bob所以还是用bob的公钥
        verifyResult = alice.verify(messages, doug.sign(messages), bob.pk);
        System.out.println(verifyResult);//false

        //Doug把公开信息篡改了发送给Alice
        messages = &quot;how are you,alice&quot;.getBytes(StandardCharsets.UTF_8);
        verifyResult = alice.verify(messages, signature, bob.pk);
        System.out.println(verifyResult);//false
    }
}
</code></pre>
<h4 id="数字证书">数字证书</h4>
<p>上面的示例代码中缺少一个最极端的情况:Doug将签名换成了自己的,将Alice存储的Bob公钥偷换成了自己的公钥.</p>
<p>这种情况,Alice根本不会发现跟自己通信的人是Doug而是Bob,除非存储的Bob公钥过期了或删掉了,才会发现不对.</p>
<p>终于,当Alice发现不对劲后,让Bob去找<strong>受信任的证书中心(Certificate Authority - CA)</strong>,为公钥做认证.</p>
<p>于是<strong>证书中心(CA)<strong>用自己的私钥+Bob的公钥+其他的认证信息,生成了</strong>数字证书</strong>(Digital Certificate).</p>
<p>Bob拥有了<strong>证书中心(CA)<strong>开具的</strong>数字证书</strong>证明后,在签名的时候附上<strong>数字证书</strong>,传给Alice.</p>
<p>Alice在收到签名后,使用<strong>证书中心(CA)<strong>的公钥去解开</strong>数字证书</strong>,发现了公钥并能成功解密签名,说明这确实是Bob的数字签名.</p>
<p>流程如下:</p>
<figure data-type="image" tabindex="4"><img src="http://img.zhengjianru.work/%E5%B8%A6%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E7%AD%BE%E5%90%8D%E6%B5%81%E7%A8%8B.png" alt="带数字证书的签名流程" loading="lazy"></figure>
<p>最常见的<strong>数字证书</strong>的应用如:HTTPS协议</p>
<p>以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：</p>
<ol>
<li>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</li>
<li>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</li>
<li>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</li>
</ol>
<p>上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。</p>
<p>注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商<a href="https://en.wikipedia.org/wiki/DigiNotar">DigiNotar</a>就发生过私钥泄漏导致公司破产的事故。</p>
<blockquote>
<p>参考资料:<br>
<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943717668160">廖雪峰Java教程</a></p>
</blockquote>
<!-- more -->
<p><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html?from=singlemessage">阮一峰网络日志</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 多线程 - ThreadLocal]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-threadlocal/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-threadlocal/">
        </link>
        <updated>2021-06-10T09:56:11.000Z</updated>
        <content type="html"><![CDATA[<h4 id="threadlocal是什么">ThreadLocal是什么</h4>
<p>ThreadLocal为每个线程提供了一个独立的局部变量,线程间变量隔离,互不冲突.</p>
<h4 id="为什么使用threadlocal">为什么使用ThreadLocal</h4>
<p>ThreadLocal的设计目的在于:为每个线程提供一个局部变量,而不是为了解决并发和共享变量的问题.</p>
<p>当我们想定义一份线程级别的全局变量时(<em>即想在任何类任何方法中都可以获取到当前线程的变量</em>),就可以使用ThreadLocal.</p>
<p>使用场景如:session/cookie存放变量、全局的日志ID用来追踪日志链路</p>
<h4 id="threadlocal的设计">ThreadLocal的设计</h4>
<p>ThreadLocal仅对外提供了四个公有方法：<code>withInitial(Supplier&lt;? extends S&gt; supplier)、get()、set(T value)、remove()</code>,以及默认构造方法.我们从初始化流程/创建/使用/删除流程逐步分析.</p>
<h5 id="threadlocal初始化">ThreadLocal初始化</h5>
<p>ThreadLocal提供两种方式初始化:无参构造方法和使用<code>withInitial(Supplier&lt;? extends S&gt; supplier)</code></p>
<pre><code class="language-java">/**
 * Creates a thread local variable.
 * @see #withInitial(java.util.function.Supplier)
  */
public ThreadLocal() {
}

/**
 * Creates a thread local variable. The initial value of the variable is
 * determined by invoking the {@code get} method on the {@code Supplier}.
 *
 * @param &lt;S&gt; the type of the thread local's value
 * @param supplier the supplier to be used to determine the initial value
 * @return a new thread local variable
 * @throws NullPointerException if the specified supplier is null
 * @since 1.8
 */
public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) {
    return new SuppliedThreadLocal&lt;&gt;(supplier);
}
</code></pre>
<p>无参构造方法内无任何实现,我们重点观察<code>withInitial(Supplier&lt;? extends S&gt; supplier)</code></p>
<p>传入参数为<code>Supplier&lt;? extends S&gt; supplier</code>,Supplier是JDK1.8提供的函数式接口,主要作用为返回一个结果.</p>
<pre><code class="language-java">@FunctionalInterface
public interface Supplier&lt;T&gt; {

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
</code></pre>
<p>返回值为<code>new SuppliedThreadLocal&lt;&gt;(supplier)</code>.<code>SuppliedThreadLocal</code>是ThreadLocal定义的静态内部类,</p>
<p>仅只有一个重写了父类的<code>initialValue()</code>方法,默认使用<code>supplier</code>的<code>get()</code>实现方法,得到<code>get()返回值</code>传递给ThreadLocal.</p>
<pre><code class="language-java">static final class SuppliedThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; {

    private final Supplier&lt;? extends T&gt; supplier;

    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) {
        this.supplier = Objects.requireNonNull(supplier);
    }

    @Override
    protected T initialValue() {
        return supplier.get();
    }
}
</code></pre>
<p>所以我们一般使用如下两种方式初始化ThreadLocal:</p>
<pre><code class="language-java">/**
 * 两种初始化方式
 * 1.使用无参构造,不带初始值
 * 2.使用withInitial()静态方法,实现Supplier接口,带初始值
 */
private static void initThreadLocal() {
    ThreadLocal&lt;Integer&gt; threadLocal1 = new ThreadLocal&lt;&gt;();
    ThreadLocal&lt;Integer&gt; threadLocal2 = ThreadLocal.withInitial(()-&gt; 1);
}
</code></pre>
<h5 id="threadlocal赋值">ThreadLocal赋值</h5>
<p>ThreadLocal提供两种赋值方法:对外的<code>set(T value)</code>与对内的<code>setInitialValue()</code></p>
<pre><code class="language-java">private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}

public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}

ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
</code></pre>
<p>可以从代码看到,主要区别在于<code>setInitialValue()</code>从初始化方法中取值,<code>set()</code>从参数中取值;</p>
<p>共同点在于:都通过<code>getMap()</code>方法取得<code>ThreadLocalMap</code>,并使用<code>ThreadLocalMap</code>保存当前<code>实例对象</code>和<code>传入参数value</code>;</p>
<h5 id="threadlocal取值">ThreadLocal取值</h5>
<p>ThreadLocal仅提供一个对外的取值方法:<code>get()</code></p>
<pre><code class="language-java">public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
</code></pre>
<p>取值逻辑:通过当前线程获取到<code>ThreadLocalMap</code>,如果不为空则返回<code>ThreadLocalMap</code>内部维护的<code>Entry.value</code>.如果为空则返回初始化时赋的值,如果没赋值则返回null.</p>
<h5 id="threadlocal回收">ThreadLocal回收</h5>
<p>通过删除<code>ThreadLocalMap</code>中的当前实例<code>this</code>的引用,达到回收ThreadLocal的目的</p>
<pre><code class="language-java"> public void remove() {
     ThreadLocalMap m = getMap(Thread.currentThread());
     if (m != null)
         m.remove(this);
 }
</code></pre>
<h5 id="threadlocalmap">ThreadLocalMap</h5>
<p>上面的赋值、取值和回收功能都是通过<code>ThreadLocalMap</code>实现的，那让我们看看<code>ThreadLocalMap</code>究竟是什么</p>
<pre><code class="language-java">/**
 * ThreadLocalMap 是一种定制的哈希映射，仅适用于维护线程本地值。 
 * 不会在 ThreadLocal 类之外导出任何操作。 
 * 该类是包私有的，以允许在类 Thread 中声明字段
 */
static class ThreadLocalMap {
    
    /**
     * 一个静态内部类，使用ThreadLocal实例作为key,传入参数为value
     * 继承WeakReference目的在于,key(也就是threadLocal实例对象)在经过gc后会变成null
     */
    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }
    
    private Entry[] table;
    private int size = 0;
    private int threshold; // Default to 0
    
    /**
     * 赋值操作中，createMap就使用该构造器
     */
    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {
        //创建一个大小为16的Entry数组
        table = new Entry[INITIAL_CAPACITY];
        //取模保证i的取值大小在16的循环里，目的是将entry打散，避免哈希冲突
        int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);
        table[i] = new Entry(firstKey, firstValue);
        size = 1;
        //设置阈值，在扩/缩容时起作用
        setThreshold(INITIAL_CAPACITY);
    }
    
    /**
     * threadLocal的赋值逻辑
     */
    private void set(ThreadLocal&lt;?&gt; key, Object value) {
        Entry[] tab = table;
        int len = tab.length;
        int i = key.threadLocalHashCode &amp; (len-1);

        //循环遍历数组Entry
        for (Entry e = tab[i];
             e != null;
             e = tab[i = nextIndex(i, len)]) {
            ThreadLocal&lt;?&gt; k = e.get();
			//如果entry e中记录的this对象与传入key一致，则覆盖e的value
            if (k == key) {
                e.value = value;
                return;
            }
			//如果entry e中记录的是null(可能被gc回收了)，则直接赋值value
            if (k == null) {
                replaceStaleEntry(key, value, i);
                return;
            }
            //如果没有return,则找到数组中下一个e,继续循环,直到e为空
        }
		//空e则直接创建一个新的Entry
        tab[i] = new Entry(key, value);
        int sz = ++size;
        //如果数组元素超过阈值,则扩容
        if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
            rehash();
    }
    
    /**
     * threadLocal的取值逻辑
     */
    private Entry getEntry(ThreadLocal&lt;?&gt; key) {
        int i = key.threadLocalHashCode &amp; (table.length - 1);
        Entry e = table[i];
        if (e != null &amp;&amp; e.get() == key)
            //通过传入的this对象,计算得出它的哈希码对应的数组下标,找到entry,一致则返回
            return e;
        else
            //否则调用getEntryAfterMiss()方法
            return getEntryAfterMiss方法(key, i, e);
    }
    
    private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {
        Entry[] tab = table;
        int len = tab.length;
		
        //如果通过传入的this对象计算哈希码能找到entry,
        //但记录的entry.key又与当前this对象不一致时,进入循环
        while (e != null) {
            ThreadLocal&lt;?&gt; k = e.get();
            //一致时,直接返回
            if (k == key)
                return e;
            //为空时,把此时this计算哈希码槽位上的entry元素删掉,然后把整个数组重新计算哈希分布
            if (k == null)
                expungeStaleEntry(i);
            else
            //当entry既不为空又不一致时,就找到下一个entry,直到找到相同的threadLocal
                i = nextIndex(i, len);
            e = tab[i];
        }
        //否则直接返回null
        return null;
    }
    
    /**
     * threadLocal删除逻辑
     */
    private void remove(ThreadLocal&lt;?&gt; key) {
        Entry[] tab = table;
        int len = tab.length;
        int i = key.threadLocalHashCode &amp; (len-1);
        //和set的循环逻辑一样,都是通过传入this,计算对应的哈希槽位
        //找到对应的entry,判断是否与key相等,不相等则继续找到下一个entry,直到找不到为止
        for (Entry e = tab[i];
             e != null;
             e = tab[i = nextIndex(i, len)]) {
            if (e.get() == key) {
                e.clear();//将value设置为null
                expungeStaleEntry(i);//清除该槽位的entry,然后rehash
                return;
            }
        }
    }
}
</code></pre>
<p>工作流程图:</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/ThreadLocal%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="ThreadLocal流程图" loading="lazy"></figure>
<blockquote>
<p>总结:</p>
<ol>
<li>ThreadLocal本身不存储数据,而是通过内部维护的ThreadLocalMap和Entry来存储.</li>
<li>ThreadLocalMap本质上就是一个哈希数组,下标为threadLocal计算得出的哈希码,元素为Entry.</li>
<li>Entry中key存放this对象(ThreadLocal)的弱引用,value存放值.</li>
<li>threadLocal的赋值/取值/回收操作都是通过操作ThreadLocalMap中的Entry数组实现.</li>
</ol>
</blockquote>
<h4 id="threadlocal的使用">ThreadLocal的使用</h4>
<pre><code class="language-java">public class GlobalID implements AutoCloseable{

    private static final ThreadLocal&lt;AtomicInteger&gt; GLOBAL_ID = ThreadLocal.withInitial(()-&gt;new AtomicInteger(0));

    public int getGlobalID(){
        return GLOBAL_ID.get().incrementAndGet();
    }

    /**
     * try(resource){..} 自动回收
     * @throws Exception
     */
    @Override
    public void close(){
        GLOBAL_ID.remove();
    }
}

@Slf4j(topic = &quot;id&quot;)
public class TestThreadLocal {

    public static void main(String[] args) {
        try (GlobalID globalID = new GlobalID()) {
            Thread threadA = new Thread(() -&gt; {
                log.info(&quot;GlobalID [{}] record :Thread [{}] execute method name:{}&quot;, globalID.getGlobalID(),
                        Thread.currentThread().getName(),
                        Thread.currentThread().getStackTrace()[2].getMethodName());
                log.info(Thread.currentThread().getName() + &quot;开始工作啦!!!!!&quot;);
            }, &quot;thread-a&quot;);

            Thread threadB = new Thread(() -&gt; {
                log.info(&quot;GlobalID [{}] record :Thread [{}] execute method name:{}&quot;, globalID.getGlobalID(),
                        Thread.currentThread().getName(),
                        Thread.currentThread().getStackTrace()[2].getMethodName());
                log.info(Thread.currentThread().getName() + &quot;开始工作啦!!!!!&quot;);
            }, &quot;thread-b&quot;);

            threadA.start();
            threadB.start();

            log.info(&quot;GlobalID [{}] record :Thread [{}] execute method name:{}&quot;, globalID.getGlobalID(),
                    Thread.currentThread().getName(),
                    Thread.currentThread().getStackTrace()[1].getMethodName());
            log.info(Thread.currentThread().getName() + &quot;开始工作啦!!!!!&quot;);

            log.info(&quot;GlobalID [{}] record :Thread [{}] execute method name:{}&quot;, globalID.getGlobalID(),
                    Thread.currentThread().getName(),
                    Thread.currentThread().getStackTrace()[1].getMethodName());
            log.info(Thread.currentThread().getName() + &quot;有完没完啊!!!!!&quot;);
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210610175354.png" alt="截图_选择区域_20210610175354" loading="lazy"></figure>
<blockquote>
<p>ThreadLocal生成的GlobalID相对与每一个线程是全局唯一的.所以我们可以通过线程名和GlobalID追踪日志的工作链路.</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 多线程 - 线程池]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-xian-cheng-chi/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-xian-cheng-chi/">
        </link>
        <updated>2021-06-08T05:49:12.000Z</updated>
        <content type="html"><![CDATA[<h4 id="线程池是什么">线程池是什么</h4>
<p>线程池是一种池化思想,通过池来管理线程.线程池中预先创建了一些线程,当有任务进来时,就会分配预留线程去执行任务,执行完毕后线程又回到线程池,完成了对线程的重用.</p>
<h4 id="为什么使用线程池">为什么使用线程池</h4>
<p>线程池解决的核心问题就是线程资源管理的问题.在并发环境中,系统不能确定会有多少任务需要线程执行.那么他们造成的问题在于</p>
<ul>
<li>频繁创建/销毁线程会造成巨大资源消耗</li>
<li>无限制任务使用无限制线程执行会将资源消耗殆尽</li>
<li>系统无法合理分配任务执行线程数,对线程难以管理</li>
</ul>
<p>使用线程池解决的问题</p>
<ul>
<li>降低资源消耗:通过池化预先创建线程,执行完任务的线程又回到线程池,达到重用的效果</li>
<li>提高响应速度:预先创建的线程直接执行任务,不再等待创建线程</li>
<li>提高管理效率:通过配置线程池创建的核心线程数/最大线程数,管理可用线程的数量</li>
<li>提供拓展能力:线程池具有可拓展性,例如使用SchduledThreadPoolExecutor可以延迟/定期执行任务</li>
</ul>
<h4 id="线程池的设计">线程池的设计</h4>
<p>JDK中,提供了Executor框架来使用线程池.其中Executor提供了一种设计思想:用户无需关心线程的创建流程,也无需关心如何调度线程执行任务.只需要提供Runnable对象,由Executor框架来完成线程调度和执行流程.</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/%E7%BA%BF%E7%A8%8B%E6%B1%A0UML%E7%B1%BB%E5%9B%BE.png" alt="线程池UML类图" loading="lazy"></figure>
<p>从图上可知,ThreadPoolExecutor起到既管理线程池又管理线程和任务的工作.那么我们来研究一下ThreadPoolExecutor的工作流程:</p>
<figure data-type="image" tabindex="2"><img src="https://p0.meituan.net/travelcube/77441586f6b312a54264e3fcf5eebe2663494.png" alt="" loading="lazy"></figure>
<h5 id="工作流程">工作流程</h5>
<h6 id="任务执行流程">任务执行流程</h6>
<ol>
<li><code>ExecutorService threadPool = new ThreadPoolExecutor()</code>初始化线程池</li>
<li><code>threadPool.submit(task)</code>提交任务,<code>threadPoolExecutor.execute()</code>执行任务</li>
<li>通过变量<code>ctl</code>获取到当前<code>Running</code>状态下的工作线程数(<code>workerCount</code>)</li>
<li>通过<code>addWorker()</code>检查线程池状态,如果是关闭状态,采用拒绝策略处理任务,保证线程池处于<code>Running</code>状态</li>
<li>当工作线程数小于核心线程数时(<code>workerCount&lt;corePoolSize</code>),新增工作线程执行任务</li>
<li>当工作线程数大于等于核心线程数时(<code>workerCount&gt;=corePoolSize</code>),且任务阻塞队列(<code>workQueue</code>)中任务不满时,添加任务至任务阻塞队列中.</li>
<li>再次检查<code>ctl</code>,当工作线程数大于等于核心线程数,工作线程数小于最大线程,且任务阻塞队列中任务已满时(<code>corePoolSize&lt;=workerCount&lt;maximumPoolSize &amp;&amp; workerCountOf==0</code>),启动一个线程来执行该任务.</li>
<li>当工作线程数大于等于最大线程数时且任务阻塞队列已满(<code>workerCount&gt;=maximumPoolSize &amp;&amp; workerCountOf==0</code>),采用拒绝策略处理任务.</li>
</ol>
<p>######　任务缓冲</p>
<p>线程池管理任务的核心模块是通过使用阻塞队列将任务和线程解耦(生产者消费者模式).阻塞队列中存放任务,放入任务的线程充当生产者,取出任务的线程充当消费者.</p>
<figure data-type="image" tabindex="3"><img src="https://p1.meituan.net/travelcube/f4d89c87acf102b45be8ccf3ed83352a9497.png" alt="" loading="lazy"></figure>
<p>JDK提供的默认阻塞队列实现:</p>
<figure data-type="image" tabindex="4"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_jetbrains-idea_20210607095619.png" alt="截图_jetbrains-idea_20210607095619" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://p0.meituan.net/travelcube/725a3db5114d95675f2098c12dc331c3316963.png" alt="" loading="lazy"></figure>
<h6 id="任务申请">任务申请</h6>
<p>任务的执行有两种可能:1.线程初创时,直接执行任务.2.线程从阻塞队列中获取任务执行.</p>
<p>获取任务执行逻辑-getTask():</p>
<figure data-type="image" tabindex="6"><img src="https://p0.meituan.net/travelcube/49d8041f8480aba5ef59079fcc7143b996706.png" alt="" loading="lazy"></figure>
<h6 id="任务拒绝">任务拒绝</h6>
<p>当线程池线程个数达到设置最大线程数(maximumPoolsize)或线程池关闭时,新的任务会到来就会触发拒绝策略,保护线程池.<em>默认拒绝策略</em>-<code>AbortPolicy</code></p>
<p>线程池四种内置拒绝策略:</p>
<pre><code class="language-java">/**
 * 1.AbortPolicy
 * 直接抛出RejectedExecutionException
 * 使用场景:当系统超负荷时,需要及时反馈
 */
public static class AbortPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +
                                             &quot; rejected from &quot; +
                                             e.toString());
    }
}

/**
 * 2.CallerRunsPolicy
 * 如果线程池不是关闭状态,则负责该任务的线程直接执行
 * 使用场景:当系统超负荷时,需要所有任务都执行完
 */
public static class CallerRunsPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            r.run();
        }
    }
}

/**
 * 3.DiscardPolicy
 * 啥也不做,负责该任务的线程不执行该任务
 * 使用场景:当系统超负荷时,没有必要再执行新的任务
 */
public static class DiscardPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    }
}

/**
 * 4.DiscardOldestPolicy
 * 如果线程池不是关闭状态,任务阻塞队列中队首任务出队,该任务入队尾
 * 使用场景:当系统超负荷时,需要执行新的任务并不再需要执行老的任务
 */
public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            e.getQueue().poll();
            e.execute(r);
        }
    }
}

/**
 * 5.自定义拒绝策略
 * 实现rejectExecutioin方法,自定义实现拒绝逻辑
 * 使用场景:当以上方案都不能满足需求时,自定义拒绝逻辑处理
 */
public static class CustomPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        //拒绝逻辑
    }
}
</code></pre>
<h5 id="生命周期">生命周期</h5>
<p>线程池状态不由用户设置,而是在线程池运行时,内部维护.通过一个变量<code>ctl</code>维护了两个值:运行状态<code>runState</code>和工作线程数量<code>workerCount</code>.<code>ctl</code>是<code>AtomicInteger</code>类型,4个字节,32个比特位.其中高3位用来维护<code>runState</code>,低29位用来维护<code>workerCount</code>.这样设计的好处在于:通过位运算,计算<code>ctl</code>就可以得出<code>runState</code>和<code>workerCount</code>,在代码中只用维护一个变量<code>ctl</code>,避免了加锁同步两个变量的操作,同时位运算相比于基本运算也会快很多.</p>
<pre><code class="language-java">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;

// runState is stored in the high-order bits
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;

// Packing and unpacking ctl

//计算当前线程池状态
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
//当前线程池工作线程个数
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
//通过runState和workerCount计算得出ctl
private static int ctlOf(int rs, int wc) { return rs | wc; 
</code></pre>
<p>runState五种状态代表意义如下:</p>
<table>
<thead>
<tr>
<th>运行状态</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>RUNNING</td>
<td>运行状态,可接受新的任务,也可处理阻塞队列中的任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>关闭状态,不再接受新任务,但可处理阻塞队列中的任务</td>
</tr>
<tr>
<td>STOP</td>
<td>停止状态,不接受新任务也不处理阻塞队列中的任务,并中断正在运行中的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>完成状态,所有任务被终止,工作线程数为0,将会运行terminated()方法</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态,terminated()运行完成</td>
</tr>
</tbody>
</table>
<p>生命周期转换状态:</p>
<figure data-type="image" tabindex="7"><img src="https://p0.meituan.net/travelcube/582d1606d57ff99aa0e5f8fc59c7819329028.png" alt="" loading="lazy"></figure>
<h5 id="工作线程">工作线程</h5>
<p>线程池为了使内部能够控制线程状态和生命周期,定义了<code>Class Worker</code>的概念.其设计目的在于维护线程运行任务的中断控制状态.它继承了<code>AQS</code>并实现了<code>Runnable</code>接口,在<code>run()</code>方法中执行<code>runWorker()</code>方法,运行处理任务的核心逻辑.继承<code>AQS</code>而不直接使用<code>ReentrantLock</code>的目的在于:在调用一些方法如(<code>setCorePoolSize()</code>时),不希望线程获取锁,所以利用AQS简单实现了一个不可重入互斥锁.</p>
<pre><code class="language-java">private final class Worker extends AbstractQueuedSynchronizer implements Runnable{
    /** Thread this worker is running in.  Null if factory fails. */
    final Thread thread;
    /** Initial task to run.  Possibly null. */
    Runnable firstTask;
    /** Per-thread task counter */
    volatile long completedTasks;
    
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }
}
</code></pre>
<p>thread:线程池通过线程工厂(<code>ThreadFactory</code>)创建线程,用于用于执行任务.</p>
<p>firstTask:初始化任务,如果非空,则创建核心线程(<code>addWorker</code>)并立马执行firstTask;如果为空,则创建一个非核心线程执行任务.</p>
<blockquote>
<p>核心线程和非核心线程区别在于:</p>
<p>核心线程会加入<code>corePoolSize</code>,是最小数量的保持活动状态的工作线程(<code>worker</code>)</p>
<p>非核心线程则不会加入<code>corePoolSize</code>,当超过了<code>keepAliveTime</code>就释放</p>
</blockquote>
<h6 id="工作线程执行任务流程">工作线程执行任务流程</h6>
<p>worker中使用runWorker()方法来执行任务,具体流程如下:</p>
<ol>
<li>通过while循环获取任务(<code>firstTask或着getTask()</code>)</li>
<li>申请非重入锁,如果线程池处理正在运行状态,则执行任务.如果是停止状态,则要保证线程中断.</li>
<li>线程完成任务数+1,释放非重入锁</li>
<li>任务结束,工作线程退出(<code>processWorkerExit()</code>),销毁线程.</li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://p0.meituan.net/travelcube/879edb4f06043d76cea27a3ff358cb1d45243.png" alt="" loading="lazy"></figure>
<h6 id="工作线程增加">工作线程增加</h6>
<p>worker中使用addWorker()方法来增加工作线程,具体流程如下:</p>
<ol>
<li>获取线程池工作线程数量和线程池状态</li>
<li>检查线程池是否关闭,大于等于关闭状态,新增工作队列失败</li>
<li>不在关闭状态下,任务不为空但工作队列为空,新增工作队列失败</li>
<li>获取工作线程数,若工作线程数超过容量或超过核心线程数,新增工作队列失败</li>
<li>CAS操作尝试增加工作线程数</li>
<li>如果增加失败,就继续检查线程池工作状态</li>
<li>如果工作状态不等于之前的状态则回到第2步;如果相等就继续循环,回到第四步</li>
<li>如果增加成功,为当前任务新建一个线程,上锁后检查线程池状态,正常就往worker集合中新增线程,否则就抛出异常,中止程序;</li>
<li>新增线程后释放锁,新增成功启动新增线程,执行任务;启动失败了,则删除worker集合中的新增线程</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://p0.meituan.net/travelcube/49527b1bb385f0f43529e57b614f59ae145454.png" alt="" loading="lazy"></figure>
<h6 id="工作线程回收">工作线程回收</h6>
<p>在执行任务方法中(<code>runWorker()</code>),我们知道工作线程在不断循环获取任务,当工作线程无法再获取到任务时,就会中断循环,进入<code>processWorkerExit()</code>方法,完成线程回收.具体流程如下:</p>
<ol>
<li>判断线程是否异常中断,如果是则CAS减少一个<code>workerCount</code></li>
<li>上锁后worker集合删除该工作线程,然后释放锁 (这一步已经完成了工作线程的回收,通过删除集合中工作线程的引用,利用jvm垃圾回收机制回收线程)</li>
<li>试图关闭线程池,如果线程池工作线程数量为0则关闭,否则不管</li>
<li>继续判断线程池状态,根据新状态，确认是否需要重新分配线程</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://p0.meituan.net/travelcube/90ea093549782945f2c968403fdc39d415386.png" alt="" loading="lazy"></figure>
<h4 id="线程池的使用">线程池的使用</h4>
<p>可以使用ThreadPoolExcutor新建线程池,但JDK推荐使用Excutors利用静态工程方法创建线程池</p>
<pre><code class="language-java">public class ThreadPoolExecutors {

    /**
     * 1.使用threadPoolExecutor构造手动创建线程池
     */
    private static void threadPoolExecutor() {
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 5, 10, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;());
        threadPoolExecutor.submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot; execute print task&quot;);
        });
        threadPoolExecutor.shutdown();
        //输出结果:pool-1-thread-1 execute print task
    }

    /**
     * 2.使用Executors创建固定大小线程池 即corePoolSize==maximumPoolSize
     */
    private static void fixedThreadPool() {
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        executorService.submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot; execute print task&quot;);
        });
        executorService.submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot; execute print task&quot;);
        });
        executorService.submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot; execute print task&quot;);
        });
        executorService.shutdown();//等待线程执行完
        //输出结果
        //pool-1-thread-1 execute print task
        //pool-1-thread-1 execute print task
        //pool-1-thread-2 execute print task
    }

    /**
     * 3.使用Executors创建缓存线程池
     * 即没有核心工作线程,超过60秒不执行任务的线程将会被回收,有执行任务的将会被创建新的线程
     * 线程池最大数量为int最大数即2^31-1
     */
    private static void cachedThreadPool() {
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot; execute print task&quot;);
        });
        // 线程池停止,不再接受新任务也不处理任务队列的任务,并中断正在执行的任务
        executorService.shutdownNow();//不等待线程执行完,立即停止线程池

        // 输出结果:pool-1-thread-1 execute print task
        // 然后抛出异常 java.util.concurrent.RejectedExecutionException
        executorService.submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot; execute print task&quot;);
        });
    }

    /**
     * 4.使用Executors创建单个线程池
     * 只有一个工作线程,corePoolSize==maximumPoolSize==1
     * 等同于Executors.newFixedThreadPool(1);
     */
    private static void singleThreadExecutor() {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        executorService.submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot; execute print task&quot;);
        });
        executorService.submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot; execute print task&quot;);
        });
        executorService.shutdown();
        //输出结果
        //pool-1-thread-1 execute print task
        //pool-1-thread-1 execute print task
    }

    /**
     * 5.使用Executors创建定时任务线程池
     */
    private static void scheduledThreadPool() {
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);
        scheduledExecutorService.schedule(()-&gt;{
            System.out.println(&quot;当前时间:&quot;+ LocalDateTime.now());
            System.out.println(Thread.currentThread().getName()+&quot; execute print task&quot;);
        },5,TimeUnit.SECONDS);
        scheduledExecutorService.shutdown();
        //输出结果
        //当前时间:2021-06-08T13:39:33.041
        //当前时间:2021-06-08T13:39:38.020
        //pool-1-thread-1 execute print task
    }
}
</code></pre>
<h4 id="总结">总结</h4>
<p>线程池工作流程:<br>
新建线程池-&gt;提交任务-&gt;执行任务-&gt;判断线程池核心线程数-&gt;判断任务队列是否已满-&gt;判断线程池最大线程数是否已满-&gt;触发拒绝策略</p>
<figure data-type="image" tabindex="11"><img src="http://img.zhengjianru.work/ThreadPool%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png" alt="ThreadPool工作流程1" loading="lazy"></figure>
<p>工作线程工作流程:</p>
<p>start()线程准备就绪-&gt;run()方法准备执行任务-&gt;runWorker(this)-&gt;循环获取任务-&gt;直至拿不到任务-&gt;工作线程退出-&gt;线程集合删除该工作线程-&gt;尝试关闭线程池</p>
<figure data-type="image" tabindex="12"><img src="http://img.zhengjianru.work/woker%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="woker工作流程" loading="lazy"></figure>
<blockquote>
<p>参考资料:https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 多线程 - 各种锁]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-ge-zhong-suo/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-ge-zhong-suo/">
        </link>
        <updated>2021-06-01T08:08:26.000Z</updated>
        <content type="html"><![CDATA[<p>上篇多线程-进阶-原子性中,介绍了<code>synchronized</code>关键字.指出<code>synchronized</code>是一种<code>互斥锁、内置锁</code>还是<code>可重入锁</code>.那么这些锁是什么意思呢?还有其他锁吗,分别是什么作用,用在什么场景下呢?这一篇我们详细介绍一下各种锁.</p>
<figure data-type="image" tabindex="1"><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png" alt="" loading="lazy"></figure>
<h4 id="1悲观锁与乐观锁">1.悲观锁与乐观锁</h4>
<p>悲观锁:在某一线程操作数据时,总是认为会有其他线程来篡改数据,为了避免这种情况,该线程总是先上锁后再操作数据,确保其他线程不能修改该数据.</p>
<p>乐观锁:在某一线程操作数据时,总是认为不会有其他线程来篡改数据,所以不需要上锁,而是在修改时,一直将预期原值与内存值比较是否相等.相等则更新内存值为新值,否则放弃更新,进行重试/报错等操作.</p>
<figure data-type="image" tabindex="2"><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/c8703cd9.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 锁资源：悲观锁与乐观锁
 * java中的悲观锁实现:synchronized和ReentrantLock
 * 乐观锁实现:native compareAndSwap 操作
 */
public class PesOptLock {

    //悲观锁
    private class PessimisticLock{

        private volatile int count = 0;

        //synchronized方式实现悲观锁
        public int increaseCount(){
            synchronized (this){
                count++;
            }
            return count;
        }

        //ReentrantLock方式实现悲观锁
        private ReentrantLock lock = new ReentrantLock();
        public int decreaseCount(){
            lock.lock();
            try {
                count--;
            }finally {
                lock.unlock();
            }
            return count;
        }
    }

    //乐观锁
    private class OptimisticLock{
        private volatile AtomicInteger count = new AtomicInteger(0);

        public int increaseCount(){
            return count.incrementAndGet();
        }
    }
}
</code></pre>
<p>我们可以看到乐观锁仅用<code>atomicInteger.incrementAndGet()</code>方法就完成了线程间的资源同步.让我们看看其具体实现:</p>
<blockquote>
<p>本文使用的jdk为openjdk-11</p>
</blockquote>
<pre><code class="language-java">public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    /*
     * This class intended to be implemented using VarHandles, but there
     * are unresolved cyclic startup dependencies.
     */
    private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();
    private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, &quot;value&quot;);

    private volatile int value;
    
	/**
     * Atomically increments the current value,
     * with memory effects as specified by {@link VarHandle#getAndAdd}.
     *
     * &lt;p&gt;Equivalent to {@code addAndGet(1)}.
     *
     * @return the updated value
     */
    public final int incrementAndGet() {
        return U.getAndAddInt(this, VALUE, 1) + 1;
    }
}

public final class Unsafe {
    
	 /**
     * Atomically adds the given value to the current value of a field
     * or array element within the given object {@code o}
     * at the given {@code offset}.
     *
     * @param o object/array to update the field/element in
     * @param offset field/element offset
     * @param delta the value to add
     * @return the previous value
     * @since 1.8
     */
    @HotSpotIntrinsicCandidate
    public final int getAndAddInt(Object o, long offset, int delta) {
        int v;
        do {
            v = getIntVolatile(o, offset);
        } while (!weakCompareAndSetInt(o, offset, v, v + delta));
        return v;
    }
    
    @HotSpotIntrinsicCandidate
    public native int getIntVolatile(Object o, long offset);
    
    @HotSpotIntrinsicCandidate
    public final boolean weakCompareAndSetInt(Object o, long offset,
                                              int expected,
                                              int x) {
        return compareAndSetInt(o, offset, expected, x);
        
	/**
     * Atomically updates Java variable to {@code x} if it is currently
     * holding {@code expected}.
     *
     * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
     * and write.  Corresponds to C11 atomic_compare_exchange_strong.
     *
     * @return {@code true} if successful
     */
    @HotSpotIntrinsicCandidate
    public final native boolean compareAndSetInt(Object o, long offset,
                                                 int expected,
                                                 int x);
        
	public long objectFieldOffset(Class&lt;?&gt; c, String name) {
        if (c == null || name == null) {
            throw new NullPointerException();
        }

        return objectFieldOffset1(c, name);
    }
        
   private native long objectFieldOffset1(Class&lt;?&gt; c, String name);
}
</code></pre>
<p>很明显,<code>atomicInteger.incrementAndGet()</code>内部调用了<code>unsafe.getAndAddInt()</code>操作.</p>
<blockquote>
<p>Unsafe是什么?</p>
<p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重</p>
</blockquote>
<p>Unsafe直接操作内存,并使用了大量native方法(JVM中C/C++语言实现的方法),其中<code>compareAndSetInt()</code>方法直接借助了汇编指令<code>lock cmpxchg</code>达到原子操作.</p>
<p>根据<code>compareAndSetInt()</code>的参数规定,比较的关键依赖于四个参数:</p>
<ul>
<li>Object o : <em>包含要修改field的对象</em></li>
<li>long offset : <em>对象中某field的偏移量</em></li>
<li>int expected : 期望值</li>
<li>int x : 更新值</li>
</ul>
<p><code>atomicInteger.incrementAndGet()</code>传入参数<code>unsafe.getAndAddInt(this, VALUE, 1) + 1;</code>:</p>
<ul>
<li>Object o : this (<code>AtomicInteger</code>实例对象)</li>
<li>long offset :  <code>VALUE = unsafe.objectFieldOffset(AtomicInteger.class, &quot;value&quot;);</code> 通过<code>unsafe.objectFieldOffset1</code>计算得出<code>value</code>的内存地址</li>
<li>int expected : <code>v = getIntVolatile(o, offset);</code>内存中该int的值</li>
<li>int x : <code>x = v+delta;delta=1;</code>其实就是内存中该int+1的值</li>
</ul>
<p>但需要注意的是,<code>unsafe.getAndAddInt()</code>返回的值是v,并不是要更新的值,所以在<code>atomicInteger.incrementAndGet()</code>中,对其返回值+1后返回.至此,CAS操作通过Unsafe完成.</p>
<h5 id="悲观锁问题">悲观锁问题</h5>
<p>悲观锁在大量线程尝试获取锁,读取数据/修改数据时,只有单个线程能顺利拿到锁,执行目标代码.这样会造成大量的线程等待,浪费资源,但它能保证数据不会出现被其他线程篡改.</p>
<p>所以它的适用场景:写多读少</p>
<h5 id="乐观锁问题">乐观锁问题</h5>
<p>乐观锁在大量线程尝试获取锁,读取数据/修改数据时,因为在java层面不存在加锁的情况,所以线程均能直接读取数据/修改数据.但是由于<code>unsafe.while (!weakCompareAndSetInt(o, offset, v, v + delta))</code>操作,线程在更新失败时,一直尝试重试更新,浪费CPU资源.</p>
<p>所以它的适用场景:读多写少</p>
<p>缺陷:</p>
<ol>
<li>
<p><strong>ABA问题</strong>:因为<code>unsafe.getIntVolatile(o, offset)</code>返回的是内存中的值,如果有线程A修改了它在内存中的值,然后又有线程B把它改成了原来的值,那么对于其他的线程而言,线程A的操作并不存在,因为他们看到的还是线程B修改后的值(原来的值).这就是ABA问题.</p>
<p>解决思路:添加一个版本号变量,并在更新操作时对版本号+1,过程由<code>1A-2B-1A</code>-&gt;<code>1A-2B-3A</code></p>
<p>解决方案:Java提供了实现类<code>AtomicStampedReference</code>解决该问题,内部维护了一个<code>Pair.stamp</code>变量,<code>compareAndSet(expectedReference, newReference,expectedStamp, newStamp)</code>,在比较时加上了对版本号的校验.</p>
</li>
<li>
<p><strong>循环重试</strong>:更新失败时，会一直自旋比较尝试更新，消化CPU资源.</p>
</li>
<li>
<p><strong>单共享变量原子操作</strong>:在CAS过程中只能对一个共享变量进行原子操作,多个共享变量不保证.</p>
<p>解决思路:将多个共享变量封装到一个对象中,对该对象进行原子操作.</p>
<p>解决方案:Java提供了实现类<code>AtomicReference</code>来保证引用对象的原子操作,可以把多个共享变量都放入该对象中.</p>
</li>
</ol>
<h4 id="2自旋锁与适应性自旋锁">2.自旋锁与适应性自旋锁</h4>
<p>当没有获取到锁时,当前线程是否进入到阻塞状态.</p>
<p>当进入阻塞态时,当前线程会进入休眠状态并等待持有锁线程释放锁,CPU唤起当前线程,然后进行下一轮的锁竞争,若没抢到锁就重复进入休眠状态和后面的操作.</p>
<p>不进入阻塞态时,当前线程不断自旋,判断是否能获取到锁,然后等待持有锁线程释放锁,然后进行下一轮锁竞争,若没有抢到锁就继续自旋和后面的操作.</p>
<figure data-type="image" tabindex="3"><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png" alt="" loading="lazy"></figure>
<h5 id="自旋锁">自旋锁</h5>
<p>目的:自旋锁是为了不放弃CPU执行时间,避免系统在唤起和阻塞线程中来回切换CPU状态,如果能在自旋过程中拿到锁,就避免了CPU切换线程的开销.</p>
<p>缺陷:如果在自选过程中一直拿不到锁,就会不停的重新尝试,占用了大量CPU时间.为了避免出现这种问题,我们给自旋锁一个最大的自旋次数(默认是10次，可以使用-XX:PreBlockSpin来更改)</p>
<p>原理:同样也是CAS操作,如<code>unsafe.while (!weakCompareAndSetInt(o, offset, v, v + delta))</code>操作.</p>
<h5 id="适应性自旋锁">适应性自旋锁</h5>
<p>适应性意味着自旋次数不再固定,如果某线程通过自旋获取到锁,虚拟机会认为该线程下次也会可能成功,增加该线程的自旋次数;如果该线程没有通过自旋获取锁,虚拟机会认为该线程下次也可能获取不到锁,减少该线程的自旋次数,甚至省略掉自旋过程.</p>
<h4 id="3无锁-偏向锁-轻量级锁-重量级锁">3.无锁、偏向锁、轻量级锁、重量级锁</h4>
<p>针对synchronized,JDK在1.6之后做了改进.在JDK1.6之前都是重量级锁,依赖于操作系统的mutex指令实现,存在用户态(应用程序)与内核态(系统)之间的切换,存在明显的性能消化.为了改善这点,在JDK1.6之后,引入了偏向锁和轻量级锁的概念.在了解这些锁之前,需要理解synchronized是如何实现线程同步的.</p>
<h5 id="synchronized存储锁">synchronized存储锁</h5>
<p>在HotSpot虚拟机中,对象在创建后,在内存中保存的结构包括对象头、实例数据、对齐填充</p>
<ul>
<li>对象头：Mark Word(标记字段)、Klass Pointer(Class对象指针)</li>
<li>实例数据：对象的成员变量</li>
<li>对齐填充(可选)：占位符，按8字节对齐</li>
</ul>
<h6 id="对象头">对象头</h6>
<p><strong>Mark Word</strong>:用于记录对象的hashcode、对象分代年龄(GC年龄)、锁标志位信息.这些对于对象数据无关的数据,被设计成为非固定结构,以便于在极小空间内存储更多数据,锁标志位不同,结构就会发生变化.</p>
<blockquote>
<p>简单来说,Mark Word记录着锁信息,会随着锁标志位变化而修改记录的数据.</p>
</blockquote>
<p><strong>Klass Pointer</strong>:用于记录对象的类的元数据指针,JVM靠它来确定该对象的数据类型.</p>
<h6 id="monitor">Monitor</h6>
<p>Monitor:可以被理解为一种同步机制,通常被描述为一个对象,每个Java对象都有对应属于自己的monitor对象.故将monitor称为<strong>内置锁</strong>或<strong>monitor锁</strong>.monitor是线程私有的数据结构,每个线程独立维护着monitor record,和一份全局可用列表.monitor中用owner字段存放当前持有锁的线程,以及在entry set,wait set区域存放等待锁的线程队列.</p>
<blockquote>
<p>简单来说,monitor用owner记录了当前持有锁线程,并在entry set区域记录了Blocked线程队列,wait set区域记录了Wait线程队列.</p>
</blockquote>
<h6 id="无锁">无锁</h6>
<p>不对资源锁定,所有线程均可修改资源,但仅有一个线程能够成功.无锁实现:CAS操作.</p>
<h6 id="偏向锁">偏向锁</h6>
<p>当不存在多线程竞争锁,一直只被同一个线程访问代码块时,该线程就会自动获取锁,降低获取锁代价.通过比较Mark Word中记录的线程ID,与当前线程一致就直接获取锁,不一致就通过CAS尝试更新,成功也直接获取锁,失败说明有其他线程在竞争,此时会等待没有字节码运行时撤销偏向锁,升级为轻量级锁.</p>
<h6 id="轻量级锁">轻量级锁</h6>
<p>当有少量线程竞争锁,且竞争时间很短时,持有偏向锁的线程升级成轻量级锁,其他线程自旋等待.虚拟机在栈帧中创建锁记录(Lock Record)空间,用于拷贝的对象头中Mark Word信息,并将owner指针指向加锁对象.该线程执行到同步代码块时,会通过CAS操作尝试更新Mark Word指向Lock Record.更新成功,说明获取到轻量级锁,并更新Mark Word标志位为00.更新失败,会自旋重尝.失败到一定次数,说明存在大量线程竞争,升级为重量级锁.</p>
<h6 id="重量级锁">重量级锁</h6>
<p>当有大量线程竞争锁,冲突很高时,持有轻量级锁会升级为重量级锁.为了避免线程一直自旋消耗CPU资源,其他未获得锁线程阻塞进入等待队列,然后等待持有锁线程释放锁后再次竞争.使用monitor对象对同步代码块上锁,依赖操作系统指令mutex实现,在操作系统层面进行加锁操作.但会导致在用户态和内核态切换,存在性能损耗.</p>
<blockquote>
<p>锁升级过程流程图:</p>
<figure data-type="image" tabindex="4"><img src="http://img.zhengjianru.work/%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt="锁升级过程" loading="lazy"></figure>
</blockquote>
<h6 id="总结">总结</h6>
<ul>
<li>
<p>在大量读少量写的情况下使用无锁(CAS操作);</p>
</li>
<li>
<p>在单线程情况下,synchronized是偏向锁.通过比较Mark Word的线程ID获取锁.</p>
</li>
<li>
<p>在少量线程竞争情况下,synchronized是轻量级锁.拷贝锁对象Mark Word到Lock Record,通过CAS+自旋比较更新当前锁对象的Mark Word是否指向Lock Record,获取锁.</p>
</li>
<li>
<p>在大量线程竞争情况下,synchronized是重量级锁.随机线程获得锁,通过monitor对象加锁操作,其他线程阻塞进入等待队列.通过系统指令mutex实现操作系统层面的加锁.</p>
</li>
</ul>
<h4 id="4公平锁与非公平锁">4.公平锁与非公平锁</h4>
<h5 id="公平锁">公平锁</h5>
<p>按照多线程请求获取锁顺序来取到锁,先进先出队列,除队首线程外,所有线程阻塞.</p>
<p>优点:队列中的线程不会一直处于等待,迟早会获取到锁.</p>
<p>缺点:请求需要排队,吞吐效率低,等待线程需要被唤醒后取锁,有唤醒开销.</p>
<h5 id="非公平锁">非公平锁</h5>
<p>不按照多线程请求获取锁顺序来取到锁,线程锁请求可以插队,可能会出现后进先出的情况.</p>
<p>优点:请求线程可能会直接获取到锁,无需等待或被唤醒,吞吐效率高.</p>
<p>缺点:在等待队列中可能会有线程一直在等待,获取不到锁.长时间任务得不到执行,等到可以执行时,任务失去意义.</p>
<blockquote>
<p>Lock和Synchronized默认使用非公平锁.</p>
</blockquote>
<h4 id="5可重入锁与不可重入锁">5.可重入锁与不可重入锁</h4>
<h5 id="可重入锁">可重入锁</h5>
<p>当获取到相同锁对象时,从同步代码块进入到另一个同步代码块时(也可以是相同代码块),不需要释放锁就可进入,重入次数(state)加1;当从同步代码块离开时,重入次数(state)减1;当重入次数为0时,释放锁.</p>
<h5 id="不可重入锁">不可重入锁</h5>
<p>当获取相同锁对象时,从同步代码块进入到另一个同步代码块时(也可以是相同代码块),需要先释放当前锁时,然后再获取到当前锁.但是释放当前锁后将无法再继续执行同步代码块,所以无法释放.那么既不能释放锁,又不能再次获取当前锁,就会造成死锁的状态.</p>
<blockquote>
<p>ReentrantLock和Synchronized都是可重入锁.</p>
</blockquote>
<h4 id="6独享锁与共享锁">6.独享锁与共享锁</h4>
<h5 id="独享锁互斥锁-独占锁">独享锁(互斥锁、独占锁)</h5>
<p>指锁一次只能被一个线程占有.如<code>synchronized和java.utils.concurrent.locks.ReentrantLock</code>都是独享锁.</p>
<h5 id="共享锁读写锁">共享锁(读写锁)</h5>
<p>指锁能多个线程占有.如<code>java.utils.concurrent.locks.ReentrantReadWriteLock</code>中<code>ReentrantReadWriteLock.ReadLock</code>是共享锁,而<code>ReentrantReadWriteLock.WriteLock</code>是独享锁.</p>
<p><code>ReadLock</code>读锁共享,即可以使线程高效的并发读.</p>
<p><code>WriteLock</code>写锁独享,即可以使线程安全的操作共享变量.</p>
<blockquote>
<p>参考资料:https://tech.meituan.com/2018/11/15/java-lock.html</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 多线程 - 进阶]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-jin-jie/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-jin-jie/">
        </link>
        <updated>2021-05-20T06:33:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="java内存模型jmm">Java内存模型(JMM)</h4>
<p>在多线程-基础介绍篇章中,我们介绍过线程是进程的子集,一个进程是拥有多线程来处理任务的.这么线程它们共享使用该进程的系统资源给它分配的空间.</p>
<p>系统资源分配进程空间的内容:</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/983343709_1600233897382_4A47A0DB6E60853DEDFCFDF08A5CA249" alt="" loading="lazy"></figure>
<p>图片来源:https://www.nowcoder.com/discuss/512320?channel=-2&amp;source_id=discuss_terminal_discuss_sim</p>
<p>在Java多线程的实现中,使用<code>共享内存</code>模型:</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/v2-455827bbb5173b54463906564870a3ee_720w.jpg" alt="" loading="lazy"></figure>
<p>图片来源:https://zhuanlan.zhihu.com/p/87782307</p>
<ol>
<li>每一个线程享有自己的<strong>独立工作内存</strong>,<strong>共享主内存</strong>,并存有<strong>主内存</strong>的变量副本-<strong>共享变量</strong>.</li>
<li>线程对自己的<strong>工作内存</strong>中的共享变量进行读写操作,然后再同步到<strong>主内存</strong>中.</li>
<li><strong>工作内存</strong>中不能生成新的变量,新增变量只会存在<strong>主内存</strong>中,然后共享.</li>
<li><strong>工作内存</strong>之间无法相互访问变量,只能同步到<strong>主内存</strong>中,访问<strong>主内存</strong>的共享变量.</li>
</ol>
<h4 id="内存的交互操作">内存的交互操作</h4>
<ol>
<li>lock(锁定):作用于主内存的变量,把一个变量标识为一条线程独占状态</li>
<li>unlock(解锁):作用于主内存的变量,把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定</li>
<li>read(读取):作用于主内存变量，把主内存的一个变量读取到工作内存中</li>
<li>load(载入):作用于工作内存，把read操作读取到工作内存的变量载入到工作内存的变量副本中</li>
<li>use(使用):作用于工作内存的变量，把工作内存中的变量值传递给一个执行引擎</li>
<li>assign(赋值):作用于工作内存的变量。把执行引擎接收到的值赋值给工作内存的变量</li>
<li>store(存储):把工作内存的变量的值传递给主内存</li>
<li>write(写入):把store操作的值入到主内存的变量中</li>
</ol>
<h5 id="注意事项">注意事项</h5>
<ol>
<li>不允许read、load、store、write操作之一单独出现</li>
<li>不允许一个线程丢弃assign操作</li>
<li>不允许一个线程不经过assign操作，就把工作内存中的值同步到主内存中</li>
<li>一个新的变量只能在主内存中生成</li>
<li>一个变量同一时刻只允许一条线程对其进行lock操作.但lock操作可以被同一条线程执行多次,只有执行相同次数的unlock操作,变量才会解锁</li>
<li>如果对一个变量进行lock操作,将会清空工作内存中此变量的值,在执行引擎使用这个变量前,需要重新执行load或者assign操作初始化变量的值</li>
<li>如果一个变量没有被锁定,不允许对其执行unlock操作,也不允许unlock一个被其他线程锁定的变量</li>
<li>对一个变量执行unlock操作之前,需要将该变量同步回主内存中</li>
</ol>
<blockquote>
<p>为了使我们能正确的操作线程,我们需要理解如下概念:可见性、原子性、线程封闭、不可变性</p>
</blockquote>
<h4 id="可见性">可见性</h4>
<p>可见性:指当某一个线程修改了变量,其他的线程能立刻看到修改后的变量.(<strong>针对变量</strong>)</p>
<p>Java提供了关键字<code>volatile</code>来实现可见性,其保证如下效果:</p>
<ol>
<li>每次访问变量时,总是获取主内存的最新值.</li>
<li>每次修改变量时,立刻写回到主内存.</li>
<li>防止指令重排(指令重排:程序执行的时候，CPU、编译器可能会<strong>对执行顺序做一些优化调整</strong>，导致执行的顺序并不是从上往下的)</li>
</ol>
<pre><code class="language-java">/**
 * volatile:
 * 某线程修改变量时,该变量对其他线程可见
 */
public class VolatileLearn {

    private volatile boolean isRunning = true;

    private static void useVolatile() throws InterruptedException {
        VolatileLearn volatileLearn = new VolatileLearn();

        Thread thread = new Thread(() -&gt; {
            while (volatileLearn.isRunning) {//thread线程读isRunning状态
                System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;volatile-thread-a&quot;);

        thread.start();
        Thread.sleep(1000);
        volatileLearn.isRunning = false;//main线程写isRunning状态
        thread.join();
        System.out.println(thread.getState());
    }

    public static void main(String[] args) throws InterruptedException {
        useVolatile();
        //执行结果:
        //volatile-thread-a is running
		//volatile-thread-a is running
		//TERMINATED
    }
}
</code></pre>
<blockquote>
<p>如果不保证，仍以x86架构为例，JVM对volatile变量的处理如下：</p>
<ul>
<li>在写volatile变量v之后，插入一个sfence。这样，sfence之前的所有store（包括写v）不会被重排序到sfence之后，sfence之后的所有store不会被重排序到sfence之前，禁用跨sfence的store重排序；且sfence之前修改的值都会被写回缓存，并标记其他CPU中的缓存失效。</li>
<li>在读volatile变量v之前，插入一个lfence。这样，lfence之后的load（包括读v）不会被重排序到lfence之前，lfence之前的load不会被重排序到lfence之后，禁用跨lfence的load重排序；且lfence之后，会首先刷新无效缓存，从而得到最新的修改值，与sfence配合保证内存可见性。</li>
</ul>
<p>在另外一些平台上，JVM使用mfence代替sfence与lfence，实现更强的语义。</p>
<p>二者结合，共同实现了Happens-Before关系中的volatile变量规则。</p>
</blockquote>
<h4 id="原子性">原子性</h4>
<p>原子性:指一个或一系列的不可中断的操作.(<strong>针对方法</strong>)</p>
<p>Java提供了关键字<code>synchronized</code>来实现原子性,其保证如下效果:</p>
<ol>
<li><code>synchronized是一种互斥锁</code>,当修饰方法时,保证只允许一个线程能运行该方法直至运行结束释放锁.</li>
<li><code>synchronized是一种内置锁</code>,当修饰对象时,保证只运行一个线程能运行该代码块的内容直至运行结束释放锁.</li>
<li>被修饰的方法/代码块顺序执行,修改后变量对其他线程可见.</li>
</ol>
<pre><code class="language-java">/**
 * synchronized:
 * 修饰方法时,为互斥锁,只允许一个线程运行该方法直至运行结束释放锁
 * 修饰对象时,为内置锁,只允许一个线程运行该代码块的内容直至运行结束释放锁
 */
public class SynchronizedLearn {

    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Thread threadA = new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                counter.increase();
            }
        }, &quot;synchronized-thread-a&quot;);
        Thread threadB = new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                counter.decrease();
            }
        }, &quot;synchronized-thread-b&quot;);
        threadA.start();
        threadB.start();
        threadA.join();
        threadB.join();
        System.out.println(&quot;最后的总数:&quot; + counter.getCount());
    }

    private static class Counter {
        static int count = 0;

        public void decrease() {
            synchronized (this) {//锁住当前实例对象
                System.out.println(Thread.currentThread().getName() + &quot;执行decrease方法&quot;);
                System.out.println(Thread.currentThread().getName() + &quot;进行count--&quot;);
                count--;
            }
        }

        public void increase() {
            synchronized (this) {//锁住当前实例对象
                System.out.println(Thread.currentThread().getName() + &quot;执行increase方法&quot;);
                System.out.println(Thread.currentThread().getName() + &quot;进行count++&quot;);
                count++;
            }
        }

        public int getCount() {
            System.out.println(Thread.currentThread().getName() + &quot;获取count&quot;);
            return count;
        }

        /**
         * 锁住当前方法
         * 当使用synchronized (this) {//所有代码}时,其实等价于直接使用synchronized修饰方法
         * decrease() == synDecrease()
         */
        public synchronized void synDecrease() {
            System.out.println(Thread.currentThread().getName() + &quot;进行count--&quot;);
            count--;
        }

        /**
         * 锁住当前方法
         * increase() == synIncrease()
         */
        public synchronized void synIncrease() {
            System.out.println(Thread.currentThread().getName() + &quot;进行count++&quot;);
            count++;
        }
    }
}
</code></pre>
<p>运行结果如图所示:</p>
<figure data-type="image" tabindex="3"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210519144243.png" alt="截图_选择区域_20210519144243" loading="lazy"></figure>
<blockquote>
<p>为什么会出现一会thread-a操作一会thread-b操作,count还等于-5?不是已经通过synchronized (this)锁住了代码块,保证count的加减操作都是原子性的吗?</p>
<p>解答:</p>
<p>问题1:先是thread-a然后thread-b操作</p>
<p>答:因为系统调度线程是随机的,所以出现了线程A和线程B交替执行的情况.synchronized只保证代码块的内容会依次从上至下顺序执行,不保证线程按顺序调度.</p>
<p>问题2:count==-5?</p>
<p>答:虽然通过synchronized保证了Counter的加减操作是原子性的,但是整个main方法不是原子性操作,其中存在三个线程thread-a/b和main线程.而最后输出时,main线程获取到Counter的count值,此时并不能保证thread-a/b已经执行完,所以取到的count值并不等于0.为了获取到正确的值,其实很简单,等待thread-a/b直接完成就可以了:在输出语句前加上<code>threadA.join();threadB.join();</code>,就能取得正确count值.</p>
<figure data-type="image" tabindex="4"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210519145858.png" alt="截图_选择区域_20210519145858" loading="lazy"></figure>
</blockquote>
<p><em>注意事项</em>:</p>
<ul>
<li>当使用<code>synchronized</code>修饰方法时,等价于方法体内使用<code>synchronized(this){//所有代码}</code>写法,但是静态方法中是不存在<code>this</code>对象的,所以在静态方法中等价于方法体内使用<code>synchronized(Class.class){//所有代码}</code>的写法.</li>
<li>所有方法默认不使用<code>synchronized</code>修饰,所有变量默认不使用<code>volatile</code>修饰,即:除了特殊说明外,一般的类默认是线程不安全的.</li>
</ul>
<h4 id="线程封闭">线程封闭</h4>
<p>由上面的两个例子可以看出,因为操作共享变量带来了诸多问题,才引入关键字来保证多线程能够正确的读写共享变量.既然如此,为了保证线程安全,各个线程不读写共享变量,只在自己的线程中读写自己的变量(<code>局部变量</code>),那就没有干扰了:这种方式称为<code>线程封闭</code>.</p>
<pre><code class="language-java">public class ClosedThreadLearn {

    public int countNumber(){
        int count = 0;

        for (int i = 0; i &lt; 10; i++) {
            count++;//非原子操作,但只对局部变量count有影响,count在方法体外不起作用
        }
        for (int i = 0; i &lt; 10; i++) {
            count--;
        }
        return count;
    }

    public static void main(String[] args){
        ClosedThreadLearn closedThreadLearn = new ClosedThreadLearn();
        Thread threadA = new Thread(() -&gt; {
            int count = closedThreadLearn.countNumber();
            System.out.println(Thread.currentThread().getName()+&quot; count = &quot;+count);
        }, &quot;closed-thread-a&quot;);
        Thread threadB = new Thread(() -&gt; {
            int count = closedThreadLearn.countNumber();
            System.out.println(Thread.currentThread().getName()+&quot; count = &quot;+count);
        }, &quot;closed-thread-b&quot;);
        threadA.start();
        threadB.start();
        //输出结果:
        //closed-thread-b count = 0
        //closed-thread-a count = 0
    }
}
</code></pre>
<h4 id="不可变性">不可变性</h4>
<p>除了使用局部变量的方式,我们还可以使用<code>final</code>关键字来修饰共享变量,来保证该变量是<code>不可变</code>变量.</p>
<pre><code class="language-java">public final class ImmutableVariableLearn {//被final修饰的类不可被继承

    private final int count = 100;//被final修饰的变量必须被初始化,不被能修改
    private final List&lt;Integer&gt; list;//虽然list对象不能被重新赋值(执行新的引用),但是不能避免list对象内部的值发生变化

    public ImmutableVariableLearn(List&lt;Integer&gt; list) {
        this.list = list;
    }

    public final int countNumber() {//被final修饰的方法不可被重写
        //count++; Cannot assign a value to final variable 'count'
        return count;
    }

    public final List&lt;Integer&gt; addElement(){
        list.add(count);//虽然被final修饰,仍然可以add元素
        return list;
    }

    public static void main(String[] args){
        ImmutableVariableLearn immutableVariableLearn = new ImmutableVariableLearn(new ArrayList&lt;&gt;());
        Thread threadA = new Thread(() -&gt; {
            int count = immutableVariableLearn.count;
            System.out.println(Thread.currentThread().getName() + &quot; count:&quot; + count);
            for (Integer integer : immutableVariableLearn.addElement()) {
                System.out.println(Thread.currentThread().getName()+&quot; list element:&quot;+integer);
            }
        }, &quot;immutableVary-thread-a&quot;);

        Thread threadB = new Thread(() -&gt; {
            int count = immutableVariableLearn.count;
            System.out.println(Thread.currentThread().getName() + &quot; count:&quot; + count);
            for (Integer integer : immutableVariableLearn.addElement()) {
                System.out.println(Thread.currentThread().getName()+&quot; list element:&quot;+integer);
            }
        }, &quot;immutableVary-thread-b&quot;);
        threadA.start();
        threadB.start();
    }
}
</code></pre>
<p>结果如图所示:</p>
<figure data-type="image" tabindex="5"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210519170357.png" alt="截图_选择区域_20210519170357" loading="lazy"></figure>
<blockquote>
<p>为什么被final修饰的addElement()方法会出现两个thread-a list element(100),而且thread-b会抛出异常?</p>
<p>问题1:遍历addElement(),返回了2个thread-a list element(100)</p>
<p>答:final修饰方法既不能保证addElement()方法具有原子性,也不会为方法上锁,而addElement中调用了list.add()方法,list属于ArrayList,它不是线程安全的类,add()方法线程不安全.</p>
<p>所以当thread-b为list新增了一个元素后,thread-a又为list新增了一个元素,所以在thread-a中遍历出现了2个element(100),但thread-b第一次新增元素还来得及执行输出语句时,就已经检测到异常并抛出了</p>
<p>问题2:thread-b抛出异常</p>
<p>答:在使用foreach遍历list时,java语法糖隐式调用了Iterator迭代器,使用Iterator.hasNext()和Iterator.next()进行遍历.查看ArrayList中Iterator.next()实现,modCount != expectedModCount时会抛出该异常.由于thread-b读取到的expectedModCount=1,而thread-a又对集合添加了元素,modCount=2,所以导致modCount!=expectedModCount,抛出异常.</p>
<pre><code>public E next() {
 checkForComodification();
 int i = cursor;
 if (i &gt;= size)
 throw new NoSuchElementException();
 Object[] elementData = ArrayList.this.elementData;
 if (i &gt;= elementData.length)
 throw new ConcurrentModificationException();
 cursor = i + 1;
 return (E) elementData[lastRet = i];
}
     
final void checkForComodification() {
 if (modCount != expectedModCount)
     throw new ConcurrentModificationException();
}
</code></pre>
<p>字节码文件中,foreach隐式调用Iterator迭代器模式进行遍历:</p>
<figure data-type="image" tabindex="6"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210519164154.png" alt="截图_选择区域_20210519164154" loading="lazy"></figure>
</blockquote>
<p>正确的做法应该是:当使用final修饰变量时,使用线程安全的类.</p>
<pre><code class="language-java">public final class ImmutableVariableLearn {//被final修饰的类不可被继承

    private final int count = 100;//被final修饰的变量必须被初始化,不被能修改
    private final CopyOnWriteArrayList&lt;Integer&gt; list;//虽然list对象不能被重新赋值(执行新的引用),但是不能避免list对象内部的值发生变化

    public ImmutableVariableLearn(CopyOnWriteArrayList&lt;Integer&gt; list) {
        this.list = list;
    }

    public final int countNumber() {//被final修饰的方法不可被重写
        //count++; Cannot assign a value to final variable 'count'
        return count;
    }

    public final List&lt;Integer&gt; addElement(){
        list.add(count);//虽然被final修饰,仍然可以add元素
        return list;
    }

    public static void main(String[] args){
        ImmutableVariableLearn immutableVariableLearn = new ImmutableVariableLearn(new CopyOnWriteArrayList&lt;&gt;());
        Thread threadA = new Thread(() -&gt; {
            int count = immutableVariableLearn.count;
            System.out.println(Thread.currentThread().getName() + &quot; count:&quot; + count);
            for (Integer integer : immutableVariableLearn.addElement()) {
                System.out.println(Thread.currentThread().getName()+&quot; list element:&quot;+integer);
            }
        }, &quot;immutableVary-thread-a&quot;);

        Thread threadB = new Thread(() -&gt; {
            int count = immutableVariableLearn.count;
            System.out.println(Thread.currentThread().getName() + &quot; count:&quot; + count);
            for (Integer integer : immutableVariableLearn.addElement()) {
                System.out.println(Thread.currentThread().getName()+&quot; list element:&quot;+integer);
            }
        }, &quot;immutableVary-thread-b&quot;);
        threadA.start();
        threadB.start();
    }
}
</code></pre>
<p>结果如图所示,没有异常抛出.</p>
<figure data-type="image" tabindex="7"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210519170812.png" alt="截图_选择区域_20210519170812" loading="lazy"></figure>
<blockquote>
<p>不可变性是函数式编程的重要思想和基石.<em>共享变量就不可变,可变变量就不共享</em>.</p>
<p>想要改变一个不可变对象时,利用修改后的值,创建一个新的对象并指向它.(参见java.lang.String)</p>
</blockquote>
<h4 id="死锁">死锁</h4>
<p>死锁：两个或两个以上的线程交叉执行,互相持有对方的锁并一直不释放,造成永久等待.</p>
<pre><code class="language-java">/**
 * 死锁条件:
 * 1.多个线程交替执行
 * 2.相互持有锁且不释放.永久等待
 */
public class DeadLock {

    private  final Object lockA = new Object();
    private  final Object lockB = new Object();
    private  int sum = 0;
    
    public int increase(int num) throws InterruptedException {
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
        synchronized (lockA){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
            synchronized (lockB){
                System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
                sum+=num;
                Thread.sleep(1000);
            }
            System.out.println(Thread.currentThread().getName()+&quot;:释放lock b&quot;);
        }
        System.out.println(Thread.currentThread().getName()+&quot;:释放lock a&quot;);
        return sum;
    }
    
    public int decrease(int num) throws InterruptedException {
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
        synchronized (lockB){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
            synchronized (lockA){
                System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
                sum-=num;
                Thread.sleep(1000);
            }
            System.out.println(Thread.currentThread().getName()+&quot;:释放lock a&quot;);
        }
        System.out.println(Thread.currentThread().getName()+&quot;:释放lock b&quot;);
        return sum;
    }
    
    public static void main(String[] args){
        DeadLock deadLock = new DeadLock();
        Thread threadA = new Thread(() -&gt; {
            int sum = 0;
            try {
                sum = deadLock.increase(5);
                System.out.println(Thread.currentThread().getName() + &quot; 增加后的sum=&quot; + sum);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, &quot;dead-thread-a&quot;);

        Thread threadB = new Thread(() -&gt; {
            int sum = 0;
            try {
                sum = deadLock.decrease(5);
                System.out.println(Thread.currentThread().getName() + &quot; 减少后的sum=&quot; + sum);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, &quot;dead-thread-b&quot;);

        threadA.start();
        threadB.start();
    }
}
</code></pre>
<p>结果如图所示:</p>
<figure data-type="image" tabindex="8"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210520111457.png" alt="截图_选择区域_20210520111457" loading="lazy"></figure>
<p>在thread-a/b执行到试图获取lock b/a时,就开始一直等待,形成了死锁.此时,只能通过结束进程来释放资源.</p>
<h5 id="避免死锁">避免死锁</h5>
<ol>
<li>固定加锁顺序 (针对<code>互相持有</code>)</li>
<li>开放调用(细化锁力度,减少锁面积)</li>
<li>使用定时锁(针对<code>一直等待</code>)</li>
</ol>
<pre><code class="language-java">/**
 * 1.固定加锁顺序
 * 仍然是这两个操作,只不过调整了increase和decrease都是先获取lockA,然后获取lockB,接着释放lockB,最后释放lockA
 */
public int increased(int num) throws InterruptedException {
    System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
    synchronized (lockA){
        System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
        Thread.sleep(1000);
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
        synchronized (lockB){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
            sum+=num;
            Thread.sleep(1000);
        }
        System.out.println(Thread.currentThread().getName()+&quot;:释放lock b&quot;);
    }
    System.out.println(Thread.currentThread().getName()+&quot;:释放lock a&quot;);
    return sum;
}

public int decrease(int num) throws InterruptedException {
    System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
    synchronized (lockA){
        System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
        Thread.sleep(1000);
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
        synchronized (lockB){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
            sum-=num;
            Thread.sleep(1000);
        }
        System.out.println(Thread.currentThread().getName()+&quot;:释放lock b&quot;);
    }
    System.out.println(Thread.currentThread().getName()+&quot;:释放lock a&quot;);
    return sum;
}
</code></pre>
<p>结果如图所示:</p>
<figure data-type="image" tabindex="9"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210520134610.png" alt="截图_选择区域_20210520134610" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 使用定时锁
 * 仍然是这两个操作
 * 同样是先某线程在increase中先获取lock a,再获取lock b,另一个线程在decrease中先获取lock b, 再获取lock a
 * 区别在于我们不再无限获取锁,如果等待时间内还是获取不到另一把锁,我们放弃获取另一把锁
 */
public int increase(int num) throws InterruptedException {
    System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
    if (lockA.tryLock(5, TimeUnit.SECONDS)){
        System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
        Thread.sleep(1000);
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
        if(lockB.tryLock(3, TimeUnit.SECONDS)){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
            sum+=num;
            Thread.sleep(1000);
        }else{
            System.out.println(Thread.currentThread().getName()+&quot;:放弃获取lock b&quot;);
        }
    }else{
        System.out.println(Thread.currentThread().getName()+&quot;:放弃获取lock a&quot;);
    }
    return sum;
}

public int decrease(int num) throws InterruptedException {
    System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
    if(lockB.tryLock(5, TimeUnit.SECONDS)){
        System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
        Thread.sleep(1000);
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
        if(lockA.tryLock(5, TimeUnit.SECONDS)){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
            sum-=num;
            Thread.sleep(1000);
        }else{
            System.out.println(Thread.currentThread().getName()+&quot;:放弃获取lock a&quot;);
        }
    }else {
        System.out.println(Thread.currentThread().getName()+&quot;:放弃获取lock b&quot;);
    }
    return sum;
}
</code></pre>
<p>结果如图所示:</p>
<figure data-type="image" tabindex="10"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210520142850.png" alt="截图_选择区域_20210520142850" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 多线程 - 基础介绍]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-ji-chu-jie-shao/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-ji-chu-jie-shao/">
        </link>
        <updated>2021-05-18T06:33:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1线程是什么">1.线程是什么</h4>
<p>进程:一个运行中的应用程序,如(一个浏览器,一个QQ,一个java程序).</p>
<p>线程:一个应用程序的子任务,如(浏览器:浏览页面,刷新页面,另开标签页,播放视频/音乐).</p>
<p>可以从介绍中得出结论:</p>
<ol>
<li>可以同时存在多个进程,一个进程中包含至少一个线程,可以包含多个线程.</li>
<li>应用程序的单位是进程(浏览器),即操作系统资源分配最小单位是进程.</li>
<li>执行任务的单位是线程(浏览页面),即操作系统任务调度最小单位是线程.</li>
</ol>
<h4 id="2线程与进程的区别">2.线程与进程的区别</h4>
<p>进程:</p>
<ol>
<li>操作系统为每个进程分配了独立的内存空间和系统资源.</li>
<li>在进行多进程间切换时,会消耗大量的时间和空间(进程的创建、撤消和切换).</li>
<li>在进行多进程间通信时,相对于线程而言较慢.</li>
<li>在进程崩溃时,不会影响到其他的进程.(QQ崩溃了不妨碍看网页)</li>
</ol>
<p>线程:</p>
<ol>
<li>线程属于进程,是任务的执行单位.属于一个进程的多线程,在系统给进程分配的同一块内存空间中工作,资源共享.</li>
<li>在进行多线程间切换时,因为共享同一块系统资源(内存空间和数据),所以切换时消耗的时间和空间较少.</li>
<li>在进行多线程间通信时,因为资源共享,所以相对于进程更快.</li>
<li>在线程崩溃时,进程也会崩溃.(QQ发起多人视频时卡死,QQ崩溃)</li>
</ol>
<h4 id="3为什么要使用多线程">3.为什么要使用多线程</h4>
<p>我们可以从上面的结论看到,一个进程起码分配了一个线程,操作系统由线程执行任务.</p>
<p>当我们使用单线程执行任务时,也就是让一个进程只使用一个线程执行任务:一个CPU同时运行一个浏览器,一个QQ,一个java程序.由于CPU运行速度非常快，会让人产生CPU在同时执行浏览器、QQ、Java程序的错觉.其实是一个CPU在某一个时刻,只能运行一个任务.</p>
<blockquote>
<p>计算机组件运行时间对比:</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/image-20210517160458592.png" alt="image-20210517160458592" loading="lazy"></figure>
</blockquote>
<p>为了能使得进程(QQ)能有更多的任务在CPU中执行,我们就需要创建多个线程来增加抢占CPU执行权的概率,让CPU更多的执行该进程(QQ)的任务.</p>
<p><strong>本质上讲:使用多线程就是为了提高利用系统资源率,抢占CPU执行权</strong>.</p>
<h4 id="4并发与并行">4.并发与并行</h4>
<p>并发:1个CPU在<strong>某一段时间</strong>执行<strong>多个</strong>任务.</p>
<p>并行:多个CPU在<strong>某一刻时间</strong>执行<strong>多个</strong>任务.</p>
<h4 id="5线程的使用">5.线程的使用</h4>
<h5 id="创建线程">创建线程</h5>
<pre><code class="language-java">/**
 * JDK中Thread类的注释:
 * java.lang public class Thread extends Object implements Runnable
 * 线程是程序中的执行线程。 Java虚拟机允许应用程序具有多个并发运行的执行线程。
 * 每个线程都有一个优先级。 具有较高优先级的线程优先于具有较低优先级的线程执行。
 * 每个线程可能会也可能不会被标记为守护程序。 当在某个线程中运行的代码创建新的Thread对象时，新线程的优先级最初设置为与创建线程的优先级相等，
 * 并且当且仅当创建线程是守护程序时，该线程才是守护程序线程。
 * Java虚拟机启动时，通常只有一个非守护程序线程（通常调用某些指定类的名为main的方法）。 Java虚拟机将继续执行线程，直到发生以下任何一种情况：
 * 调用了Runtime类的exit方法，并且安全管理器允许进行退出操作。
 * 不是守护程序线程的所有线程都已死，要么通过从调用返回到run方法，要么抛出异常传播到run方法之外
 */
public class MyThread {

    public static void main(String[] args){
        //使用start()方法唤起新线程
        createThread().start();//输出:我是继承Thread线程
        createThread2().start();//输出:我是实现Runnable线程
        createThread3().start();//我是匿名内部类实现的Runnable线程
    	//run()方法仅仅只是一个普通类的方法调用,并不会创建新线程
    }

    /**
     * 三种创建线程的方式:
     * 其一:继承Thread类
     * @return
     */
    private static Thread createThread() {
        Thread thread = new Thread1();
        thread.setPriority(1);
        return thread;
    }
    
    /**
     * 继承Thread类,重写run方法
     */
    private static class Thread1 extends Thread{
        @Override
        public void run() {
            System.out.println(&quot;我是继承Thread线程&quot;);;
        }
    }

    /**
     * 三种创建线程的方式:
     * 其二:实现Runnable接口, 使用Thread(Runnable target)构造方法创建Thread对象
     * @return
     */
    private static Thread createThread2() {
        Thread thread = new Thread(new Thread2());
        thread.setPriority(2);
        return thread;
    }

    /**
     * 实现Runnable接口,重写run方法
     */
    private static class Thread2 implements Runnable {
        @Override
        public void run() {
            System.out.println(&quot;我是实现Runnable线程&quot;);;
        }
    }
    
    /**
     * 三种创建线程的方式:
     * 其三:使用Thread(Runnable target)构造方法,利用匿名内部类实现Runnable接口,重写run方法
     * @return
     */
    private static Thread createThread3() {
        Thread thread = new Thread(() -&gt; System.out.println(&quot;我是匿名内部类实现的Runnable线程&quot;));
        thread.setPriority(3);
        return thread;
    }

}
</code></pre>
<p>输出结果:</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/image-20210517165629377.png" alt="image-20210517165629377" loading="lazy"></figure>
<p>结论:并不是较高优先级的线程一定会优先于具有较低优先级的线程执行,只是增加了执行概率.</p>
<h5 id="线程状态">线程状态</h5>
<p><code>java.lang.Thread</code>中<code>State</code>定义了六种状态:</p>
<pre><code class="language-java">/**
 * 线程状态。 线程可以处于以下状态之一：
 * NEW 尚未启动的线程处于此状态。
 * RUNNABLE 在Java虚拟机中执行的线程处于这种状态。
 * BLOCKED 在等待监视器锁定的情况下被阻塞的线程处于此状态。
 * WAITING 无限期地等待另一个线程执行特定操作的线程处于此状态。
 * TIMED_WAITING 正在等待另一个线程执行操作的线程最多达到指定的等待时间，该线程处于此状态。
 * TERMINATED 退出的线程处于此状态。
 * 在给定的时间点，线程只能处于一种状态。 这些状态是虚拟机状态，不反映任何操作系统线程状态
 */
public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * &lt;ul&gt;
         *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
         *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * &lt;p&gt;A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called {@code Object.wait()}
         * on an object is waiting for another thread to call
         * {@code Object.notify()} or {@code Object.notifyAll()} on
         * that object. A thread that has called {@code Thread.join()}
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * &lt;ul&gt;
         *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
         *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
         *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
         * &lt;/ul&gt;
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://img.zhengjianru.work/20190314085808279.png" alt="image-20210517170432312" loading="lazy"></figure>
<pre><code class="language-java">private static void threadState() {
    Object lock = new Object();

    //Thread.state.NEW
    Thread thread = new Thread(()-&gt;{
        synchronized (lock){//Thread.state.BLOCKED
            Thread currentThread = Thread.currentThread();
            try {
                lock.wait();//Thread.state.WAITING
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;这是第一个线程:&quot;+currentThread.getName());
        }
    },&quot;block-thread-1&quot;);
    Thread thread2 = new Thread(()-&gt;{
        synchronized (lock){//Thread.state.BLOCKED
            try {
                Thread.sleep(500);//Thread.state.TIMED_WAITING
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;这是第二个线程:&quot;+Thread.currentThread().getName());
        }
    },&quot;block-thread-2&quot;);

    //Thread.state.RUNNABLE
    thread.start();
    thread2.start();

    //Thread.state.TERMINATED
    System.out.println(thread.getState());
    System.out.println(thread2.getState());
}
</code></pre>
<h5 id="中断线程">中断线程</h5>
<pre><code class="language-java">/**
 * 中断此线程。
 * 除非始终允许当前线程中断自身，否则将一直调用此线程的checkAccess方法，这可能导致引发SecurityException 。
 * 如果在调用Object类的wait() ， wait(long)或wait(long, int)方法或join() ， join(long) ， join(long, int)方法时阻塞了该线程， sleep(long)或sleep(long, int)此类的方法，则其中断状态将被清除，并将收到InterruptedException 。
 * 如果此线程在InterruptibleChannel的I / O操作中被阻止，则该通道将被关闭，该线程的中断状态将被设置，并且该线程将收到java.nio.channels.ClosedByInterruptException 。
 * 如果此线程在java.nio.channels.Selector被阻塞，则将设置该线程的中断状态，并且它将立即从选择操作中返回（可能具有非零值），就像调用选择器的wakeup方法一样。
 * 如果上述条件均不成立，则将设置该线程的中断状态。
 * 中断未运行的线程不会产生任何效果。
 */
private static void interruptThread() throws InterruptedException {
    Thread thread = new Thread(() -&gt; {//thread-&gt;Thread.state.NEW
        int n = 0;
        try {
            Thread.sleep(10);//thread-&gt;Thread.state.TIMED_WAITING
            while (!Thread.interrupted()) {//非中断状态,计数并输出
                System.out.printf(&quot;第%s次打印:hello thread%n&quot;, ++n);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, &quot;interrupt-thread-a&quot;);
    thread.start();//thread-&gt;Thread.state.RUNNABLE
    Thread.sleep(50);//mainThread-&gt;Thread.state.TIMED_WAITING
    thread.interrupt();//中断thread
    thread.join();//thread-&gt;Thread.state.WAITING
    System.out.println(thread.getState());//thread-&gt;Thread.state.TERMINATED
}
</code></pre>
<h5 id="守护线程">守护线程</h5>
<pre><code class="language-java">/**
 * 将此线程标记为守护程序线程或用户线程。 
 * 当所有正在运行的线程都是守护程序线程时，Java虚拟机将退出。
 * 必须在线程启动之前调用此方法
 */
private static Thread daemonThread() {
    Thread thread = new Thread(() -&gt; {
        while(true){
            System.out.println(LocalTime.now());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                break;
            }
        }
    }, &quot;daemon-thread-a&quot;);
    thread.setDaemon(true);//将thread标记为守护线程
    thread.start();
    return thread;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 泛型]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-fan-xing/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-fan-xing/">
        </link>
        <updated>2021-05-14T02:10:06.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1泛型是什么">1.泛型是什么</h4>
<p>在java中,泛型是指:参数化类型-即把类型当做参数传递,当调用类/方法时,传递指定类型.是一种通用的代码模板处理手段,利用泛型,可以使一套代码,多种使用方式.</p>
<h4 id="2为什么要使用泛型">2.为什么要使用泛型</h4>
<ol>
<li>使代码更加简洁，不必进行强制类型转换，避免了<code>ClassCastException</code>异常。</li>
<li>使代码更具有通用性，避免了重复代码。</li>
</ol>
<h4 id="3使用泛型">3.使用泛型</h4>
<h5 id="定义泛型">定义泛型</h5>
<pre><code class="language-java">/**
 * 泛型类
 * @param &lt;K&gt; key的类型
 * @param &lt;V&gt; value的类型
 */
public class Pair &lt;K,V&gt;{
    
    private final K key;
    private final V value;
    //编译器提示出错:org.pzzhang.generics.Pair.this' cannot be referenced from a static context,泛型使用不能在静态成员变量上
    //private static K staticProperty;

    /**
     * 无法直接通过new K/V()的方式进行初始化
     * this.key = new K(); type parameter 'K' cannot be instantiated directly
     *  his.value = new V(); type parameter 'V' cannot be instantiated directly
     *  可以采用如下两种方式进行初始化
     */

    //1.通过Object强制转换为目标类型
    public Pair() {
        this.key = (K) new Object();
        this.value = (V) new Object();
    }

    //2.通过指定K,V的class,使用Class.newInstance()方法
    public Pair(Class&lt;K&gt; kClass,Class&lt;V&gt; vClass) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        this.key = kClass.getDeclaredConstructor().newInstance();
        this.value = vClass.getDeclaredConstructor().newInstance();
    }

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    /**
     * 注意:此处的createPairs的方法与下面createPari方法并不一致
     * 此处定义的泛型K,V跟Pair.class定义的泛型K,V没有关系
     * 此处定义的泛型由返回值前面定义的&lt;K,V&gt;相关,它也可以是&lt;T,B&gt; 效果是相等的
     * 而createPair方法参数类型的K,V才是由Pair.class定义的泛型K,V,它不能是T,B,编译器会提示Cannot resolve symbol 'T,B'
     * 所以createPairs == createPairs2 != createPair
     * @return
     */
    public static &lt;K,V&gt; Pair&lt;K,V&gt; createPairs(K key,V value){
        return new Pair&lt;&gt;(key,value);
    }

    /**
     * 泛型方法 - 使用由类定义的泛型K,V
     * @param key
     * @param value
     * @return
     */
    public  Pair&lt;K,V&gt; createPair(K key, V value){
        return new Pair&lt;&gt;(key,value);
    }

    /**
     * 静态泛型方法 - 使用由方法中返回值前定义的泛型T,B;与类定义的泛型无关
     * @param key
     * @param value
     * @param &lt;T&gt;
     * @param &lt;B&gt;
     * @return
     */
    public static &lt;T,B&gt; Pair&lt;T,B&gt; createPairs2(T key,B value){
        return new Pair&lt;&gt;(key,value);
    }
    
    /*
    编译器出错,提示Cannot resolve symbol 'T,B'
    public static Pair&lt;T,B&gt; createPairs3(T key,B value){
        return new Pair&lt;&gt;(key,value);
    }*/

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }
}
</code></pre>
<h5 id="使用泛型">使用泛型</h5>
<pre><code class="language-java">public static void main(String[] args){
  Pair&lt;String, Object&gt; pair = new Pair&lt;&gt;(&quot;charles&quot;,123);
  //泛型限制了传入K,V类型只能是String,Object
  System.out.println(String.format(&quot;key:%s,value:%s&quot;,pair.getKey(),pair.getValue()));
  //key:charles,value:123
    
  Pair&lt;String, String&gt; pair2 = new Pair&lt;&gt;(&quot;锁&quot;,&quot;钥匙&quot;);
  //泛型限制了传入K,V类型只能是String,String
  System.out.println(String.format(&quot;key:%s,value:%s&quot;,pair2.getKey(),pair2.getValue()));
  //key:锁,value:钥匙
    
  Pair&lt;String, Integer&gt; pair3 = Pair.createPairs2(&quot;锁密码&quot;, 123);
  //静态泛型方法参数决定了返回值类型为String,Integer
  System.out.println(String.format(&quot;key:%s,value:%s&quot;,pair3.getKey(),pair3.getValue()));
  //key:锁密码,value:123
}
</code></pre>
<h4 id="4泛型擦除">4.泛型擦除</h4>
<h5 id="泛型擦除定义">泛型擦除定义</h5>
<p>泛型擦除是什么?泛型擦除其实就是Java实现泛型的方式.在编译阶段,编译器已经强制转型为目标类型了,如:<code>Pair&lt;K.class,V.class&gt; pair = (Pair&lt;K.class,V.class&gt;)new Pair&lt;Object,Object&gt;();</code>,在运行阶段,JVM看不到K,V了,只有Pair.class.让我们看一个例子:</p>
<pre><code class="language-java">public static void main(String[] args){
    Pair&lt;String,Object&gt; pairEx1 = new Pair&lt;&gt;();
	Pair&lt;Integer,String&gt; pairEx2 = new Pair&lt;&gt;();
	System.out.println(Pair.getClass().equals(Pair.getClass()));//true
}
//class在JVM中只有独一份,结果等于true.
//说明在运行期间JVM认为Pair&lt;String,Object&gt;==Pair&lt;Integer,String&gt;.
//即只存在一个PairExClass.
</code></pre>
<h5 id="泛型擦除后的信息">泛型擦除后的信息</h5>
<p>那么又产生了一个新的问题:发生了泛型擦除,那我在运行期还能否获取到泛型的具体类型呢?看下面的例子</p>
<pre><code class="language-java">public static void main(String[] args){
    Type pairExType = PairExClass.class.getGenericSuperclass();
    if(pairExType instanceof ParameterizedType){//判断父类Class是否是参数化类型(泛型类)
        for (Type actualTypeArgument : ((ParameterizedType) pairExType).getActualTypeArguments()) {
            System.out.println(actualTypeArgument.getTypeName());
            //输出K,V
        }
    }

    Type pairEx1Type = PairExClass1.class.getGenericSuperclass();
    if(pairEx1Type instanceof ParameterizedType){//判断父类Class是否是参数化类型(泛型类)
        for (Type actualTypeArgument : ((ParameterizedType) pairEx1Type).getActualTypeArguments()) {
            System.out.println(actualTypeArgument.getTypeName()); 
            //输出java.lang.String;java.lang.Object;
        }
    }
}
</code></pre>
<p>从上述输出结果中可以明确看到,在运行期又可以拿到泛型的信息.这是为什么?</p>
<blockquote>
<p>Pair字节码文件:</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_jetbrains-idea_20210513153421.png" alt="截图_jetbrains-idea_20210513153421" loading="lazy"></figure>
<p>可以从Pair的字节码文件中观察到:class信息上没有了泛型的信息.</p>
<p>上面的注释中signature标明了Pair的泛型信息为(K:java.lang.Object,V:java.lang.Object).</p>
<p>而declaration标明了类信息为:Pair&lt;K,V&gt;</p>
</blockquote>
<blockquote>
<p>PairExClass字节码文件:</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_jetbrains-idea_20210513153948.png" alt="截图_jetbrains-idea_20210513153948" loading="lazy"></figure>
<p>可以从PairExClass的字节码文件中观察到:class信息上没有了泛型的信息.</p>
<p>上面的注释中signature标明了PairExClass的泛型信息为(K:java.lang.Object,V:java.lang.Object).Pair的泛型信息为&lt;TK,TV&gt;</p>
<p>而declaration标明了类的继承关系:PairExClass&lt;K,V&gt; extends Pair&lt;K,V&gt;</p>
</blockquote>
<p>所以在字节码文件中,signature可以取到泛型的具体类型.如果是K,V类型没有指定的情况,返回java.lang.Object;否则返回具体的指定类型.</p>
<h5 id="不恰当的覆写方法">不恰当的覆写方法</h5>
<p>当我们编写equals方法时,编译器提示:</p>
<pre><code class="language-java">/**
 * 编译不通过,编译提示:
 * 'equals(K)' in 'org.pzzhang.generics.Pair' clashes with 'equals(Object)' in    
 * 'java.lang.Object'; both methods have same erasure, yet neither overrides the other
 * @param o
 * @return
 */
public boolean equals(K o) {
    return this == o;
}

/**
 * 编译通过
 */
public boolean equals(String str){
    return this.toString().equals(str);
}
</code></pre>
<p>可是问题是,我们的类型K又不一定会是Object,这应该算是方法的重载而不是重写.为什么会出现这样的情况?</p>
<p>是因为在发生了泛型擦除之后,没有指定的K类型如上述所说会被编译成java.lang.Object;则equals方法就和父类Object中的equals方法完全一致.那么正确的的做法是什么?</p>
<pre><code class="language-java">/**
 * 编译通过
 * 方法名不一致,避免了冲突,则自然不会重写父类的方法
 */
public boolean isSame(K v){
	return this == v;
}
</code></pre>
<h5 id="泛型的限制">泛型的限制</h5>
<p>正因为泛型擦除的存在,在编译时将泛型类型擦除为了Object,那么就会存在如下问题</p>
<ol>
<li>
<p>泛型类型不能为基础数据类型</p>
<pre><code class="language-java">/**
 * 编译不通过
 * 编译错误:Type argument cannot be of primitive type
 * class PairExClass3 extends Pair&lt;int&gt;{}
 */
</code></pre>
</li>
<li>
<p>无法获取到泛型的Class</p>
<pre><code class="language-java">Type pairEx1Type = PairExClass1.class.getGenericSuperclass();
if(pairEx1Type instanceof ParameterizedType){//判断父类Class是否是参数化类型(泛型类)
    for (Type actualTypeArgument : ((ParameterizedType) pairEx1Type).getActualTypeArguments()) {
        System.out.println(&quot;class :&quot;+actualTypeArgument.getClass());
        //输出java.lang.String;java.lang.Object;
    }
}
</code></pre>
</li>
<li>
<p>无法判断带泛型的类型</p>
<pre><code class="language-java">/**
 * 无法通过编译:Illegal generic type for instanceof
 * PairExClass&lt;String,Object&gt; pairExClass = new PairExClass&lt;&gt;();
 * System.out.println(pairExClass instanceof PairExClass&lt;String, Object&gt;);
 */
</code></pre>
</li>
<li>
<p>不能直接实例化泛型类型</p>
<pre><code class="language-java">/**
 * 无法通过编译:type parameter 'K,V' cannot be instantiated directly
 * this.key = new K();
 * this.value = new V();
 */
</code></pre>
</li>
</ol>
<h4 id="5泛型的继承关系">5.泛型的继承关系</h4>
<p>我们知道,Java中提供了关键字extends表示类的继承关系.那么能否直接通过extends继承泛型类呢?</p>
<pre><code class="language-java">/**
 * 编译通过
 * @param &lt;K&gt; 指定泛型类型为K
 * @param &lt;V&gt; 指定泛型类型为V
 */
public class PairExClass&lt;K,V&gt; extends Pair&lt;K,V&gt;{

    @Override
    public Pair&lt;K, V&gt; createPair(K key, V value) {
        return super.createPair(key, value);
    }
}

/**
 * 编译通过
 * K:指定泛型类型为String
 * V:指定泛型类型为Object
 */
class PairExClass1 extends Pair&lt;String,Object&gt;{

    /**
     * Pair的父类方法中,所有的泛型K类型都变成了String,泛型V变成了Object
     * @param key
     * @param value
     * @return
     */
    @Override
    public Pair&lt;String, Object&gt; createPair(String key, Object value) {
        return super.createPair(key, value);
    }
}

/**
 * 编译不通过
 * 编译错误:Cannot resolve symbol 'K,V'
 * class PairExClass2 extends Pair&lt;K,V&gt;{
 *     @Override
 *     public Pair&lt;K, V&gt; createPair(K key, V value) {
 *         return super.createPair(key, value);
 *     }
 * }
 */
</code></pre>
<h4 id="6泛型的通配符">6.泛型的通配符</h4>
<h5 id="extends通配符">extends通配符</h5>
<pre><code class="language-java">/**
 * extends定义泛型类
 * 泛型限制传入参数类型必须继承于Number
 * @param &lt;N&gt; 参数类型
 */
public class PairGenericExClass &lt;N extends Number&gt;{

    private final N key;

    public PairGenericExClass(N key) {
        this.key = key;
    }

     /**
     * extends定义泛型方法参数
     */
    public boolean containKeyOrAddKey(List&lt;? extends Integer&gt; list){
        for (Integer integer : list) {
            if(integer.equals(key)) return true;
        }
        // 编译错误,无法添加: Required type:capture of ? extends Integer
        //Integer key = (Integer) this.key;
        //list.add(key);
        return false;
    }
    
    public static void main(String[] args){
        PairGenericExClass&lt;Integer&gt; integerPair = new PairGenericExClass&lt;&gt;(123);
        PairGenericExClass&lt;Double&gt; doublePair = new PairGenericExClass&lt;&gt;(123d);
        //编译错误,Type parameter 'java.lang.String' is not within its bound; should extend 'java.lang.Number'
        //PairGenericExClass&lt;String&gt; stringPair = new PairGenericExClass&lt;&gt;(&quot;123&quot;);
       System.out.println(integerPair.containKeyOrAddKey(Arrays.asList(123,456)));//true
    } 
}
</code></pre>
<p>显而易见:</p>
<ol>
<li>
<p>在使用extends修饰泛型类时,限制了泛型类型只能是Number以及Number的子类,String无法通过编译;</p>
</li>
<li>
<p>在使用extends修饰方法泛型参数时,可以获取到list所有元素,但限制了对list元素进行修改操作.(只读)</p>
</li>
</ol>
<h5 id="super通配符">super通配符</h5>
<pre><code class="language-java">/**
 * 编译错误:不支持的语法
 * class PairGenericSuClass2 &lt;P super Number&gt;{}
 */
public class PairGenericSuClass{

    private final Integer key;
    private final Integer value;

    public PairGenericSuClass(Integer key, Integer value) {
        this.key = key;
        this.value = value;
    }

    public Pair resetPair(Pair&lt;? super Integer,? super Integer&gt; pair) {
        return pair.createPair(key,value);
    }


    public static void main(String[] args){
        PairGenericSuClass pairGenericSuClass = new PairGenericSuClass(5, 7);
        Pair pair = pairGenericSuClass.resetPair(new Pair&lt;&gt;());
        System.out.println(&quot;pair key:&quot;+pair.getKey()+&quot;,pair value:&quot;+pair.getValue());
        //pair key:5,pair value:7
        Pair pair2 = pairGenericSuClass.resetPair(new Pair&lt;&gt;());
        System.out.println(&quot;pair2 key:&quot;+pair2.getKey()+&quot;,pair2 value:&quot;+pair2.getValue());
        //pair2 key:5,pair2 value:7

        //虽然我们明确知道pair.getKey()的值是int类型,但由于它既可能是int类型,还可以是Number类型,甚至是Object类型
        //所以我们只能通过Object去接受它,否则编译器会提示Provide type:Object,Required type:Integer,无法通过编译
        //Integer key = pair.getKey();
    }
}
</code></pre>
<p>显而易见:</p>
<ol>
<li>
<p>super无法像extends那样修饰泛型类</p>
</li>
<li>
<p>super修饰方法泛型参数时,可以修改原Pair泛型为&lt;? super Integer&gt;的key,value值.但无法正确接收key,value,只能用Object类型接收.(只写)</p>
</li>
</ol>
<h5 id="pecs原则">PECS原则</h5>
<p>为了方便记忆extends与super的区别,我们引入一个概念<code>PECS:Producer Extends Consumer Super</code>.</p>
<p>即:如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符.</p>
<pre><code class="language-java">public class Collections {
    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
        for (int i=0; i&lt;src.size(); i++) {
            T t = src.get(i); // src是producer
            dest.add(t); // dest是consumer
        }
    }
}
</code></pre>
<h5 id="通配符">? 通配符</h5>
<pre><code class="language-java">/**
 * 编译错误:不支持的语法
 * class PairGenericUnlimitedClass &lt;?&gt;{}
 */
public class PairGenericUnlimitedClass&lt;T&gt; {

    private final List&lt;T&gt; list;

    public PairGenericUnlimitedClass(List&lt;T&gt; list) {
        this.list = list;
    }

    public static boolean isEmpty(List&lt;?&gt; list){
        return list.size() == 0;
    }

    public static void addElementIfEmpty(List&lt;?&gt; list){
        if(isEmpty(list)){
            //无法通过编译:Required type:capture of ? Provided:int
            //list.add(123);
        }
        Object o = list.get(1);//无法拿任何类型去接受它,只有Object
    }

    public static void main(String[] args){
        PairGenericUnlimitedClass&lt;Integer&gt; pair = new PairGenericUnlimitedClass&lt;&gt;(Arrays.asList(123, 456, 789));
        PairGenericUnlimitedClass&lt;?&gt; newPair = pair;//编译通过
    }
}
</code></pre>
<p>结论:</p>
<ol>
<li>?不能修饰泛型类</li>
<li>?是泛型T的超类</li>
<li>?具有<code>extends</code>和<code>super</code>的特征(无法写;无法读),因为无法读写,一般只能用来判空,所以我们一般用的更多的是直接使用<code>泛型T</code>替代<code>?</code>通配符;</li>
</ol>
<h5 id="不可读与不可写">不可读与不可写</h5>
<p>关于读写问题解读,我的理解是:</p>
<p><strong>不可写</strong>:</p>
<p>可读:当使用<code>? extends T</code>时,<code>泛型T</code>为所有的类型顶点,所有类型都可以向上转型至<code>T类型</code>,我们可以直接这样写<code>T t = ?</code>,拿<code>T类型</code>去接收实例,跟面向接口编程的思想一致,都拿接口去接收实例.那自然都可读,都当做<code>T类型</code>处理.</p>
<p>不可写:假设<code>T类型</code>为<code>Number类型</code>,那么我即可以写入<code>Integer类型</code>,也可以写入<code>Double类型</code>,但是很明显<code>T类型(Number)</code>它不可能同时既是<code>Integer类型</code>又是<code>Double类型</code>,所以说不可写.</p>
<p><strong>不可读</strong>:</p>
<p>可写:当使用<code>? super T</code>时,<code>泛型T</code>为所有类型的底点,<code>T类型</code>是继承于他们的.假设<code>T类型</code>为<code>Integer类型</code>,那我们只能写入<code>Integer类型,Number类型,Object类型</code>.我们可以把他们都转型转为<code>Obejct类型</code>写入.</p>
<p>不可读:正因为我们可以把他们都转型为<code>Object类型</code>写入,那我们最终只能拿<code>Object类型</code>接收,否则你根本不知道你写入的到底是<code>Integer类型</code>和<code>Number类型</code>,所以说不可读.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 反射]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-fan-she/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-fan-she/">
        </link>
        <updated>2021-05-12T06:00:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1反射是什么">1.反射是什么</h4>
<p>在Java中,反射是指：可以通过程序在系统运行时(RetentionPolicy.Runtime描述过)，拿到指定对象所有信息。</p>
<h4 id="2为什么需要使用到反射">2.为什么需要使用到反射</h4>
<p>当程序运行时，我们并不知道这个指定对象是否存在，是否有目标属性，目标方法时，就可以通过反射去取得该对象的信息。</p>
<h4 id="3如何使用反射">3.如何使用反射</h4>
<h5 id="javalang提供类">java.lang提供类</h5>
<p>反射的核心包：java.lang.reflect，需要掌握如下标红的几个类</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/image-20210511171129193.png" alt="image-20210511171129193" loading="lazy"></figure>
<p>以及核心的java.lang.Class类。该类提供了在运行时可以获取到类的所有信息。</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/image-20210511171251795.png" alt="image-20210511171251795" loading="lazy"></figure>
<h5 id="掌握内容">掌握内容</h5>
<pre><code class="language-java">	获取Class类对象的三种方式：
    	1.实例对象.getClass();
		2.类名.class;
		3.Class.forName(&quot;实例对象完整类名&quot;);
​	判断Class对象是否相等或有继承关系：
    	1.使用 instanceof 关键字
    	2.使用 class.isAssignableFrom(Class&lt;?&gt; cls)方法
        //使用此方法时需要注意,参数(cls)是被检查对象,看cls是否能强制转型为class对象
        //如:Object.class.isAssignableFrom(Integer.class) == true
        //Integer.class.isAssignableFrom(Object.class) == false
​	获取类对象的属性、构造器、方法：
    	属性：	
    		1.获取类所有public属性(包括父类的所有public属性):class.getFields();
			2.获取类所有属性(不包括父类属性):class.getDeclaredFields();
			3.设置属性的访问权限:Field.setAccessible(boolean flag);
			4.取得/修改属性值:Field.get(属性名);/Filed.set(属性名,属性值);
		构造器：
            //构造器不被继承,所以取不到父类构造器,可以通过getSuperClass获取到父类对象再获取 
            1.获取类所有public构造方法:class.getConstructors();
            2.获取类所有构造方法:class.getDeclaredConstructors();
            3.设置构造器的访问权限:Constructor.setAccessible(boolean flag);
			4.新建构造器:class.getDeclaredConstructor(Paramater.class).newInstance();
		方法:
			1.获取类所有public方法(包括父类的所有public方法):class.getMethods();
			2.获取类所有方法(不包括父类方法):class.getDeclaredMethods();
			3.设置方法的访问权限:Method.setAccessible(boolean flag);
			4.调用方法:Method.invoke(Object obj,Object...args);
			//如果是静态实例,则obj=null,否则需要传入实例;如果是无参方法,则args=null,否则需要传入参数
			//如果是多态实例,则总是调用的是传入实例的覆写方法,而不是父类方法
​	动态加载：
    	JVM并不会一次性加载所有的class文件至内存,而是会在运行时第一次碰到了需要的class文件就加载.
</code></pre>
<h5 id="使用场景">使用场景</h5>
<p>利用动态加载的特性,在JVM运行时判断Class文件是否存在,动态配置JDBC驱动/日志库等</p>
<pre><code class="language-java">/**
 * 根据classpath下是否存在mysql/oracle驱动,选择连接哪个库
 * @throws SQLException
 */
public static void dynamicConnectJDBCDriver() throws SQLException {
    Connection connection = null;
    if(isPresentClass(&quot;com.mysql.jdbc.Driver&quot;)){
        connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;,&quot;test&quot;,&quot;test&quot;);
    }else if(isPresentClass(&quot;oracle.jdbc.driver.OracleDriver&quot;)){
        connection = DriverManager.getConnection(&quot;jdbc:oracle:thin@localhost:1521/test&quot;,&quot;test&quot;,&quot;test&quot;);
    }else{
        //todo:其他库
    }
    Statement statement = connection.createStatement();
    statement.executeQuery(&quot;select * from user&quot;);
    statement.close();
    connection.close();
}

/**
 * 类似commons logging和slf4j的作用-&gt;日志接口,动态检测并使用日志模块
 * 日志接口具体的实现对应关系:commons logging(接口)使用log4j(实现);slf4j(接口)使用logback(实现)
 */
public static void dynamicDispositionLogFactory(){
    LogFactory factory = null;
    if (isPresentClass(&quot;ch.qos.logback.classic.LoggerContext&quot;)) {//logback库
        factory = createLogback();
    } else if(isPresentClass(&quot;org.apache.logging.log4j.Logger&quot;)){//log4j库
        factory = createLog4j();
    }else{//jdk log库
        factory = createJdkLog();
    }
}

/**
 * 不能使用Class.forName()==null来判断是否存在,找不到只会直接抛出ClassNotFoundException异常
 * @param clazzName
 * @return
 */
public static boolean isPresentClass(String clazzName){
    try {
        Class.forName(clazzName);
        return true;
    }catch (ClassNotFoundException e){
        return false;
    }
}
</code></pre>
<p>SpringMVC利用反射给JavaBean(提供private属性,get/set方法)动态赋值,通过请求参数,反射查找JavaBean的属性,调用set方法赋值.</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/test&quot;)
@ResponseBody
public String test(TestVO testVO) { 
  String name= testVO.getName();
}
</code></pre>
<h4 id="4动态代理">4.动态代理</h4>
<h5 id="定义">定义</h5>
<p>动态代理指的是:当jvm运行时,动态创建某个接口(interface)的实例.</p>
<p>(没有.java文件,只有生成的.class文件:public class $Proxy0 extends Proxy implements 接口)</p>
<h5 id="使用方式">使用方式</h5>
<pre><code class="language-java">/**
 * 反射实现动态代理三部曲
 * 1.创建InvocationHandler对象,通过匿名内部类实现invoke方法
 * 2.通过Proxy.newInstance创建Proxy代理对象,传入代理类的classloader,代理类的class数组,和刚刚实现的invoke()方法
 * 3.通过返回的代理对象Object,强制向下转型,调用方法
 */
public class DynamicProxy {

    /**
     * 实现代理对象的抽象方法
     * @return
     */
    public static InvocationHandler invoke(){
        return (proxy, method, args) -&gt; {
            //public abstract void org.pzzhang.reflection.DynamicProxy$Hello.hello()
            System.out.println(method);
            if(Hello.class.getMethod(&quot;hello&quot;).equals(method)){
                System.out.println(&quot;hello world&quot;);
            }
            if(Hello.class.getMethod(&quot;hey&quot;, String.class).equals(method)){
                System.out.println(&quot;hey,&quot;+args[0]);
            }
            return null;
        };
    }
    
    /**
     * 创建代理对象,其中代理对象的方法已经通过InvocationHandler实现
     * 直接将代理对象强制转型为目标对象,调用目标对象的方法即可
     */
    public static void proxyHandler(){
        Hello proxyInstance = (Hello)Proxy.newProxyInstance(Hello.class.getClassLoader(), new Class[]{Hello.class}, invoke());
        proxyInstance.hello();
        proxyInstance.hey(&quot;charles&quot;);
    }

}
interface Hello{
    void hello();
    void hey(String name);
}
</code></pre>
<p>等价于如下静态代理实现类</p>
<pre><code class="language-java">class DynamicProxyStaticImplements implements Hello{

    private final InvocationHandler invocationHandler;

    public DynamicProxyStaticImplements(InvocationHandler invocationHandler) {
        this.invocationHandler = invocationHandler;
    }

    @Override
    public void hello() {
        try {
            invocationHandler.invoke(this,Hello.class.getMethod(&quot;hello&quot;),null);//没有参数,所以args=null
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }

    @Override
    public void hey(String name) {
        try {
            invocationHandler.invoke(this,Hello.class.getMethod(&quot;hey&quot;, String.class),new Object[]{name});
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }

    public static void main(String[] args){
        DynamicProxyStaticImplements staticImplements = new DynamicProxyStaticImplements((proxy, method, args1) -&gt; {
            if (Hello.class.getMethod(&quot;hello&quot;).equals(method)) {
                System.out.println(&quot;hello world&quot;);
            }
            if (Hello.class.getMethod(&quot;hey&quot;, String.class).equals(method)) {
                System.out.println(&quot;hey,&quot; + args1[0]);
            }
            return null;
        });
        staticImplements.hello();
        staticImplements.hey(&quot;charles&quot;);
    }
}
</code></pre>
<h5 id="使用场景-2">使用场景</h5>
<p>利用动态代理,对方法增强.在方法执行前后执行事务/输出日志等操作</p>
<pre><code class="language-java">public interface SQL {

    void executeSQL();
}

class Executor implements SQL{

    @Override
    public void executeSQL() {
        Logger.getGlobal().info(&quot;select * from user&quot;);
    }
}

/**
 * 三部曲:
 * 1.创建InvokeHandler对象,处理method方法,进行方法加强(开启/关闭事务,打印输出日志)
 * 2.通过Proxy.newInstance创建代理对象,传入参数
 * 3.转化成实际对象,执行目标方法
 */
class Test{

    private static Logger global = Logger.getGlobal();

    public static InvocationHandler invoke(){
        return (proxy, method, args) -&gt; {
            if(method.equals(SQL.class.getMethod(&quot;executeSQL&quot;))){
                global.info(&quot;开启数据库连接&quot;);
                Connection conn = openConnection();//创建数据库连接
                global.info(&quot;开启事务&quot;);
                conn.setAutoCommit(false);//关闭自动提交
                method.invoke(new Executor());//执行目标SQL
                global.info(&quot;事务处理完毕,提交事务&quot;);
                conn.commit();//提交事务
                global.info(&quot;关闭数据库连接&quot;);
                conn.close();
            }
            return null;
        };
    }

     private static Connection openConnection() {
        try {
            return  DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;,&quot;root&quot;,&quot;123456&quot;);
        } catch (SQLException throwables) {
            throwables.printStackTrace();
            return null;
        }
    }
    
    public static void main(String[] args){
        SQL sql = (SQL)Proxy.newProxyInstance(SQL.class.getClassLoader(), new Class[]{SQL.class}, invoke());
        sql.executeSQL();
    }
}
</code></pre>
<p>执行结果:</p>
<figure data-type="image" tabindex="3"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210512135749.png" alt="截图_选择区域_20210512135749" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 注解]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-zhu-jie/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-zhu-jie/">
        </link>
        <updated>2021-05-07T09:05:28.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1注解是什么">1.注解是什么</h4>
<p>注释: 说明文字,给人看的.</p>
<p>注解: 修饰数据的元数据,给JVM看的.</p>
<p>元注解: 修饰注解的注解.</p>
<h4 id="2为什么要使用注解">2.为什么要使用注解</h4>
<p>当我们希望描述一种数据时,使它能有更多的内容(如修饰词一样).</p>
<h4 id="3如何使用注解">3.如何使用注解</h4>
<p>在使用注解之前,先了解一下几个常见注解.</p>
<h5 id="基本注解javalang包下">基本注解(java.lang包下)</h5>
<p>3.1 @Deprecated</p>
<blockquote>
<p>注释为@Deprecated的程序元素是不鼓励程序员使用的元素。 某个元素可能由于多种原因而被弃用，例如，其使用可能会导致错误； 可能无法兼容地进行更改，或者在将来的版本中将其删除； 它已被更新的，通常更可取的替代方法所取代； 否则它已经过时了。     								  -</p>
<p>​		--来源java.lang.Deprecated注释描述</p>
</blockquote>
<p>简而言之:Deprecated注解用于<strong>标记程序为过时的</strong>.</p>
<p>@FunctionalInterface</p>
<blockquote>
<p>信息性注释类型，用于指示接口类型声明旨在成为Java语言规范定义的功能接口。 从概念上讲，功能接口仅具有一种抽象方法。 由于默认方法具有实现，因此它们不是抽象的。 如果接口声明了一个覆盖java.lang.Object的公共方法之一的抽象方法，则该方法也不计入接口的抽象方法计数，因为该接口的任何实现都将具有java.lang.Object或其他地方的实现。</p>
<p>​		---来源java.lang.FunctionalInterface注释描述</p>
</blockquote>
<p>简而言之:FunctionalInterface注解用于<strong>标记接口为函数式接口</strong>.</p>
<p>3.3 @Override</p>
<blockquote>
<p>指示方法声明旨在覆盖超类型中的方法声明。 如果使用此注释类型对方法进行注释，则除非至少满足以下条件之一，否则要求编译器生成错误消息：<br>
该方法的确覆盖或实现了在超类型中声明的方法。<br>
该方法的签名与Object中声明的任何公共方法的签名等效。</p>
<p>​		---来源java.lang.Override注释描述</p>
</blockquote>
<p>简而言之:Override注解用于<strong>重写父类的方法</strong>.</p>
<p>3.4 @SafeVarargs</p>
<blockquote>
<p>程序员断言带注释的方法或构造函数的主体不会对其varargs参数执行潜在的不安全操作。 将此注释应用于方法或构造函数可抑制有关非可调整变量Arity （vararg）类型的未经检查的警告，并抑制有关在调用站点创建参数化数组的未经检查的警告。<br>
除了其@Target元注释所施加的使用限制外，还要求编译器对此注释类型实施附加的使用限制。 如果用@SafeVarargs批注对方法或构造函数声明进行批注，则编译时错误，并且：<br>
声明是固定的arity方法或构造函数<br>
声明是可变的arity方法，既非static也非final或private 。</p>
<p>@SafeVarargs // Not actually safe!<br>
static void m(List<String>... stringLists) {<br>
Object[] array = stringLists;<br>
List<Integer> tmpList = Arrays.asList(42);<br>
array[0] = tmpList; // Semantically invalid, but compiles without warnings<br>
String s = stringLists[0].get(0); // Oh no, ClassCastException at runtime!<br>
}</p>
<p>​		---来源java.lang.SafeVarargs注释描述</p>
</blockquote>
<p>简而言之:SafeVarargs注解用于<strong>当一个非泛型集合(如Object[])赋值给泛型集合时,发生堆污染</strong>.</p>
<p>3.5 @SuppressWarnings</p>
<blockquote>
<p>指示应在带注释的元素（以及带注释的元素中包含的所有程序元素）中禁止命名的编译器警告。 请注意，在给定元素中禁止显示的警告集是在所有包含元素中禁止显示的警告的超集。 例如，如果您注释一个类以禁止一个警告，并注释一个方法以禁止另一个警告，则两种警告将在该方法中被抑制。 但是，请注意，如果在module-info文件中禁止显示警告，则该禁止适用于文件中的元素，而不适用于模块中包含的类型。<br>
作为样式问题，程序员应始终在最有效嵌套的最深层元素上使用此注释。 如果要在特定方法中禁止显示警告，则应注释该方法而不是其类。</p>
<p>​		---来源java.lang.SuppressWarnings注释描述</p>
</blockquote>
<p>简而言之:SuppressWarnings用于<strong>抑制编译器警告</strong>.</p>
<h5 id="元注解javalangannotation包下">元注解(java.lang.annotation包下)</h5>
<p>3.6 @Documented</p>
<blockquote>
<p>如果注释@Documented出现在注释类型A的声明中，则元素上的任何@A注释@A视为元素公共合同的一部分。 更详细地，当注释类型A与注释Documented ，存在和类型A的注释的值是元素A注释的公共合同的一部分。 相反，如果注释类型B没有带注释Documented ，存在和B的注释的值都不是元件B注释的公共合同的一部分。 具体来说，如果注释类型用Documented注释，则默认情况下，像javadoc这样的工具将在其输出中显示该类型的注释，而没有Documented的注释类型的注释将不显示。</p>
<p>​		---来源java.lang.annotation.Documented注释描述</p>
</blockquote>
<p>简而言之:Documented用于<strong>被@Documented修饰的注解会被javadoc工具输出成文档</strong>.</p>
<p>3.7 @Inherited</p>
<blockquote>
<p>指示注释类型是自动继承的。 如果注释类型声明中存在继承的元注释，并且用户在类声明中查询该注释类型，并且该类声明中没有该类型的注释，则将自动查询该类的超类以获取注释类型。 重复此过程，直到找到该类型的注释或到达类层次结构（对象）的顶部为止。 如果没有超类对此类型进行注释，则查询将指示所讨论的类没有此类注释。<br>
请注意，如果带注释的类型用于注释除类之外的任何内容，则此元注释类型无效。 还要注意，此元注释仅使注释从超类继承； 已实现的接口上的注释无效。</p>
<p>​		---来源java.lang.annotation.Inherited注释描述</p>
</blockquote>
<p>简而言之:Inherited用于<strong>被修饰的注解将会被子类继承</strong>.</p>
<p>3.8 @Repeatable</p>
<blockquote>
<p>注释类型java.lang.annotation.Repeatable用于指示其声明（元（meta-））注释的注释类型可重复。 @Repeatable的值表示可重复注释类型的包含注释类型。</p>
<p>​		---来源java.lang.annotation.Repeatable注释描述</p>
</blockquote>
<p>简而言之：Repeatable用于<strong>被修饰的注解可以重复使用</strong>.</p>
<p>3.9 @Retention</p>
<blockquote>
<p>指示带注释类型的注释将保留多长时间。 如果注释类型声明上没有保留注释，则保留策略默认为RetentionPolicy.CLASS 。<br>
仅当元注释类型直接用于注释时，保留元注释才有效。 如果将元注释类型用作另一注释类型的成员类型，则无效。</p>
<p>​		---来源java.lang.annotation.Retention注释描述</p>
</blockquote>
<p>简而言之：Retention用于<strong>决定被修饰的注解的生命周期</strong>.</p>
<p>3.10 @Target</p>
<blockquote>
<p>指示注释类型适用的上下文。 在JLS 9.6.4.1中指定了可以在其中应用注释类型的声明上下文和类型上下文，并在源代码中用java.lang.annotation.ElementType的枚举常量表示。<br>
如果在注释类型T上不存在@Target元注释，则可以将类型T的注释写为除类型参数声明之外的任何声明的修饰符。<br>
如果存在@Target元注释，则编译器将强制执行ElementType枚举常量指示的使用限制，以符合JLS 9.7.4的要求。</p>
<p>​		---来源java.lang.annotation.Target注释描述</p>
</blockquote>
<p>简而言之：Target用于<strong>指定被修饰的注解用在可以修饰的地方</strong>.</p>
<h5 id="补充说明">补充说明</h5>
<p>上述说到，Retention用于<strong>决定被修饰的注解的生命周期</strong>.其中RetentionPolicy定义了三个生命阶段</p>
<pre><code class="language-java">public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}
</code></pre>
<p>RetentionPolicy.SOURCE：注解被编译器使用，只存在于.java文件，不会进入到.class文件，被编译后(javac)成.class文件后擦除。</p>
<p>RetentionPolicy.CLASS：注解被.class文件使用，不会进入到JRE(Java Runtime Environment)中。</p>
<p>RetentionPolicy.RUNTIME：注解会在程序运行时读取到，一直存在于JVM中，也是我们最常用以及自定义注解时需要指明的注解生命周期。</p>
<p>Java文件的编译流程：</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/dyo3u7g3go.png" alt="dyo3u7g3go" loading="lazy"></figure>
<p>其中source-&gt;compiler过程：</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/321arjo9gz.png" alt="321arjo9gz" loading="lazy"></figure>
<p>整个编译-&gt;执行过程：source(java源代码)-&gt;parse(分析和输入到符号表)-&gt;processor(注解处理器)-&gt;analyse(分析语义)-&gt;generate(生成文件)-&gt;javac(编译)-&gt;字节码-&gt;classload(类加载)-&gt;JIT-&gt;机器码-&gt;目标机器执行</p>
<p>如果想在RetentionPolicy.class周期时获取到注解信息，需要继承AbstractProcessor类，实现process功能.(Lombok 生成get/set方法实现方式)</p>
<h5 id="自定义注解">自定义注解</h5>
<p>元注解：</p>
<pre><code class="language-java">/**
 * 元注解:修饰注解的注解
 * 即Target为ElementType.ANNOTATION_TYPE
 * 对注解进行标记,说明
 * JDK提供的元注解在java.lang.annotation包下,一共有5个      			(Documented,Inherited,Repeatable,Retention,Target)
 * 其中Native注解较为特殊,使用@Target(ElementType.FIELD)
 * 另外:所有注解都隐式继承java.lang.annotation.Annotation接口
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface MetaAnnotation {
}
</code></pre>
<p>普通注解：</p>
<pre><code class="language-java">/**
 * 注解:修饰数据的元数据
 * 即Target为除了(ElementType.ANNOTATION_TYPE)之外的ElementType
 * 对数据进行标记,说明
 * JDK提供的注解在java.lang包下
 */
@Retention(RetentionPolicy.RUNTIME) //Retention注解决定了该注解的生命周期,默认值RetentionPolicy.CLASS,详见Retention.class注释
@Target({ElementType.CONSTRUCTOR,ElementType.PARAMETER}) //target注解决定了该注解的使用范围
@MetaAnnotation
public @interface MyAnnotation {

    /**
     * 注解不能使用除(String,基本数据类型,Class,枚举,数组,注解)以外的数据类型
     */

    String name();

    int age() default 18; //default指定了缺省值

    //Class clazz();
    //ElementType TYPE();
    //int[] numbs();
    //Retention RETENTION();
    //Integer age();  无法通过编译
}
</code></pre>
<p>特殊注解：</p>
<pre><code class="language-java">/**
 * 当注解只有一个成员变量,且属性名为value时,赋值时不用显示声明value=XX
 */
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation2 {

    String value();
}
</code></pre>
<h5 id="使用注解">使用注解</h5>
<pre><code class="language-java">public class Human {

    private String name;

    private int age;

    @MyAnnotation(name = &quot;jarvis&quot;)
    public Human() {
        for (Constructor&lt;?&gt; constructor : Human.class.getConstructors()) {
            if (constructor.isAnnotationPresent(MyAnnotation.class)) {
                MyAnnotation annotation = constructor.getAnnotation(MyAnnotation.class);
                this.name = annotation.name();
                this.age = annotation.age();
            }
        }
    }

    public Human(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Human resetHuman(@MyAnnotation(name = &quot;huffman&quot;, age = 22) Human human) throws NoSuchMethodException {
        Method resetHuman = Human.class.getMethod(&quot;resetHuman&quot;, Human.class);
        for (Annotation[] parameterAnnotation : resetHuman.getParameterAnnotations()) {
            for (Annotation annotation : parameterAnnotation) {
                if (annotation instanceof MyAnnotation) {
                    MyAnnotation myAnnotation = (MyAnnotation) annotation;
                    String name = myAnnotation.name();
                    int age = myAnnotation.age();
                    return new Human(name, age);
                }
            }
        }
        return null;
    }

    @MyAnnotation2(&quot;test&quot;)
    public String getValue() throws NoSuchMethodException {
        Method getValue = Human.class.getMethod(&quot;getValue&quot;);
        return getValue.getAnnotation(MyAnnotation2.class).value();
    }

    @Override
    public String toString() {
        return &quot;Human{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }

    public static void main(String[] args) throws NoSuchMethodException {
        Human human = new Human();
        //System.out.println(human); 输出Human{name='jarvis', age=18}
        human = human.resetHuman(human);
        //System.out.println(human); 输出Human{name='huffman', age=22}
        //System.out.println(human.getValue()); 输出test
    }
}
</code></pre>
<h4 id="4总结">4.总结</h4>
<p>1.注解是用于修饰数据的一种特殊标记，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p>
<p>2.当我们需要给程序添加标注时，可以使用注解。</p>
<p>3.java.lang包提供了基础注解和元注解，元注解用于修饰注解。</p>
<p>4.注解有三个生命周期：源码时(source)，Class文件时(class)，运行时(Runtime)。我们常常自定义注解需要在运行时通过反射获取，通过程序对获取到的注解实现相应功能。</p>
<p>5.如果想利用java文件在编译过程中，利用注解实现功能，可以考虑通过继承AbstractProcessor类，实现process功能来完成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零开始学算法 - 队列]]></title>
        <id>https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-dui-lie/</id>
        <link href="https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-dui-lie/">
        </link>
        <updated>2021-04-09T02:42:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">/**
 * Functional Purpose - 队列 先进先出数据结构 FIFO(first in first out)
 * @date:2021-04-08 下午4:01
 * @author huffman
*/
public interface Queue&lt;E&gt; {

    /**
     * 元素入队尾
     * @param e
     */
    void enqueue(E e);

    /**
     * 元素出队首
     * @return
     */
    E dequeue();

    /**
     * 获取队首元素
     * @return
     */
    E getFront();

    /**
     * 获取队列元素总个数
     * @return
     */
    int getSize();

    /**
     * 判断队列元素是否为空
     * @return
     */
    boolean isEmpty();
}

/**
 * Functional Purpose - 动态数组实现队列
 *
 * @author huffman
 * @date:2021-04-08 下午4:05
 */
public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; {

    private Arrays&lt;E&gt; data;

    public ArrayQueue() {
        data = new Arrays();
    }

    public ArrayQueue(int capacity) {
        data = new Arrays(capacity);
    }

    @Override
    public void enqueue(E e) {
        data.addLast(e);
    }

    @Override
    public E dequeue() {
        return data.removeFirst();
    }

    @Override
    public E getFront() {
        return data.getFirstElement();
    }

    @Override
    public boolean isEmpty() {
        return data.isEmpty();
    }

    @Override
    public int getSize() {
        return data.getSize();
    }

    public int getCapacity(){
        return data.getCapacity();
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format(&quot;ArrayQueue: size = %d , capacity = %d\n&quot;,getSize(),getCapacity()));
        res.append(&quot;front:[&quot;);
        for (int i = 0; i &lt; getSize(); i++) {
            res.append(data.getElement(i));
            if(i!=getSize()-1){
                res.append(&quot; ,&quot;);
            }
        }
        res.append(&quot;]tail&quot;);
        return res.toString();
    }

    public static void main(String[] args) {
        Queue&lt;Integer&gt; queue = new ArrayQueue&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            queue.enqueue(i);
            System.out.println(queue);
            if (i % 3 == 2) {
                queue.dequeue();
                System.out.println(queue);
            }
        }
    }
}

/**
 * Functional Purpose -  循环队列
 * 以牺牲一个空间,头部和尾部索引循环,得到循环队列
 * 当头部等于尾部时,认为该队列为空;当头部等于(尾部+1)/总容量时,认为该队列已满
 *
 * @author huffman
 * @date:2021-04-08 下午4:55
 */
public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; {

    /**
     * 数组存储元素
     */
    private E[] data;

    /**
     * 下标的头部,尾部
     */
    private int front, tail;

    /**
     * 元素总个数
     */
    private int size;

    /**
     * 扩容因子
     */
    private int resizeFactor = 2;

    public LoopQueue(int capacity) {
        data = (E[]) new Object[capacity + 1];
        front = 0;
        tail = 0;
        size = 0;
    }

    public LoopQueue() {
        this(10);
    }

    @Override
    public void enqueue(E e) {
        //先看容量大小,需不需要扩容
        if ((tail + 1) % data.length == front) {
            resize(resizeFactor * getCapacity());
        }
        //维护队尾下标和元素总数
        data[tail] = e;
        tail = (tail + 1) % data.length;
        size++;
    }

    @Override
    public E dequeue() {
        //如果容器中无元素,则直接抛出异常
        if (isEmpty()) {
            throw new IllegalArgumentException(&quot;The queue is empty,no element can be dequeue&quot;);
        }
        //维护队首下标和元素总数
        E e = data[front];
        data[front] = null;
        front = (front + 1) % data.length;
        size--;
        //看容量大小,需不需要扩容,这里也采用懒缩容的方式,避免复杂度震荡,增加复杂度
        if (size == getCapacity() / resizeFactor / 2) {
            resize(getCapacity() / resizeFactor);
        }
        return e;
    }

    @Override
    public E getFront() {
        if (isEmpty()) {
            throw new IllegalArgumentException(&quot;The queue is empty.&quot;);
        }
        return data[front];
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return front == tail;
    }

    public int getCapacity() {
        return data.length - 1;
    }

    private void resize(int newCapacity) {
        E[] newData = (E[]) new Object[newCapacity + 1];
        //挪动元素
        for (int i = 0; i &lt; size; i++) {
            newData[i] = data[(front + i) % data.length];
        }
        data = newData;
        front = 0;//头下标 从0开始
        tail = size;//尾下标 从最后的元素开始
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format(&quot;LoopQueue: size = %d , capacity = %d\n&quot;, getSize(), getCapacity()));
        res.append(String.format(&quot;front [&quot;));
        for (int i = front; i != tail; i = (i + 1) % data.length) {
            res.append(data[i]);
            if ((i + 1) % data.length != tail) {
                res.append(&quot;, &quot;);
            }
        }
        res.append(String.format(&quot;] tail&quot;));
        return res.toString();
    }

    public static void main(String[] args) {
        Queue&lt;Integer&gt; queue = new LoopQueue&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            queue.enqueue(i);
            System.out.println(queue);
            if (i % 3 == 2) {
                queue.dequeue();
                System.out.println(queue);
            }
        }
    }
}
</code></pre>
<blockquote>
<p>注意事项:</p>
<p>1.同样的,无论队列的数据结构实现是什么,用户并不关心,只用知道如何操作队列元素即可(入队:enqueue;出队:dequeue;查看队首元素:front).</p>
<p>2.此处队列提供了两种实现方式:以动态数组的方式实现与以循环数组的方式实现.</p>
<p>优缺点比较:</p>
<p>动态数组优点:直接采用动态数组为底层数据结构,直接复用Arrays代码,通过Arrays的增加/删除元素操作队列进行入队/出队操作.实现起来十分简单.</p>
<p>动态数组缺点:进行出队操作时,需要将头元素以后的元素往前挪一位,时间复杂度表现为O(n),性能较差.</p>
<p>循环数组优点:进行出队操作时,只需维护Front头元素的下标信息,指向下一个下标即可,时间复杂度表现为O(1),性能优秀.</p>
<p>循环数组缺点:需要实现新的数据结构-循环数组,在进行出队/入队操作时,需要维护front/tail信息,增加了理解难度.</p>
<p>3.循环数组的实现逻辑:可以想象一个时钟,刻度为12(capacity),头元素为0,尾元素最大值为11(capacity-1),当尾元素到达12时,也同时指向0. 可以理解为该时钟又从零开始 : 即 当头元素=尾元素时,该数组为空;当尾元素=11(capacity-1)时,最大,同时该数组应该扩容. 注意:capacity+1 = length!</p>
<p>4.循环数组牺牲了一个空间,为了保证该数组容积大小等于初始化时的容积大小,故在初始化时需要将指定容积大小+1,所以当获取该容积时,需要将数组长度-1时,才能符合用户预期输入时的容积大小.进行循环时,实际还是得除以数组的实际容积大小,才能保证循环.</p>
<p>5.循环操作:front = (front+1)/length;tail = (tail+1)/length.  只有除以了length,才能保证front、tail永远小于length,故在一个数组长度内进行循环</p>
</blockquote>
]]></content>
    </entry>
</feed>