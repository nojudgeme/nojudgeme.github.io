<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nojudgeme.github.io</id>
    <title>Huffman&apos;s Study Area</title>
    <updated>2021-05-20T06:37:59.450Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nojudgeme.github.io"/>
    <link rel="self" href="https://nojudgeme.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://nojudgeme.github.io/images/avatar.png</logo>
    <icon>https://nojudgeme.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Huffman&apos;s Study Area</rights>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 多线程 - 进阶]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-jin-jie/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-jin-jie/">
        </link>
        <updated>2021-05-20T06:33:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="java内存模型jmm">Java内存模型(JMM)</h4>
<p>在多线程-基础介绍篇章中,我们介绍过线程是进程的子集,一个进程是拥有多线程来处理任务的.这么线程它们共享使用该进程的系统资源给它分配的空间.</p>
<p>系统资源分配进程空间的内容:</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/983343709_1600233897382_4A47A0DB6E60853DEDFCFDF08A5CA249" alt="" loading="lazy"></figure>
<p>图片来源:https://www.nowcoder.com/discuss/512320?channel=-2&amp;source_id=discuss_terminal_discuss_sim</p>
<p>在Java多线程的实现中,使用<code>共享内存</code>模型:</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/v2-455827bbb5173b54463906564870a3ee_720w.jpg" alt="" loading="lazy"></figure>
<p>图片来源:https://zhuanlan.zhihu.com/p/87782307</p>
<ol>
<li>每一个线程享有自己的<strong>独立工作内存</strong>,<strong>共享主内存</strong>,并存有<strong>主内存</strong>的变量副本-<strong>共享变量</strong>.</li>
<li>线程对自己的<strong>工作内存</strong>中的共享变量进行读写操作,然后再同步到<strong>主内存</strong>中.</li>
<li><strong>工作内存</strong>中不能生成新的变量,新增变量只会存在<strong>主内存</strong>中,然后共享.</li>
<li><strong>工作内存</strong>之间无法相互访问变量,只能同步到<strong>主内存</strong>中,访问<strong>主内存</strong>的共享变量.</li>
</ol>
<h4 id="内存的交互操作">内存的交互操作</h4>
<ol>
<li>lock(锁定):作用于主内存的变量,把一个变量标识为一条线程独占状态</li>
<li>unlock(解锁):作用于主内存的变量,把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定</li>
<li>read(读取):作用于主内存变量，把主内存的一个变量读取到工作内存中</li>
<li>load(载入):作用于工作内存，把read操作读取到工作内存的变量载入到工作内存的变量副本中</li>
<li>use(使用):作用于工作内存的变量，把工作内存中的变量值传递给一个执行引擎</li>
<li>assign(赋值):作用于工作内存的变量。把执行引擎接收到的值赋值给工作内存的变量</li>
<li>store(存储):把工作内存的变量的值传递给主内存</li>
<li>write(写入):把store操作的值入到主内存的变量中</li>
</ol>
<h5 id="注意事项">注意事项</h5>
<ol>
<li>不允许read、load、store、write操作之一单独出现</li>
<li>不允许一个线程丢弃assign操作</li>
<li>不允许一个线程不经过assign操作，就把工作内存中的值同步到主内存中</li>
<li>一个新的变量只能在主内存中生成</li>
<li>一个变量同一时刻只允许一条线程对其进行lock操作.但lock操作可以被同一条线程执行多次,只有执行相同次数的unlock操作,变量才会解锁</li>
<li>如果对一个变量进行lock操作,将会清空工作内存中此变量的值,在执行引擎使用这个变量前,需要重新执行load或者assign操作初始化变量的值</li>
<li>如果一个变量没有被锁定,不允许对其执行unlock操作,也不允许unlock一个被其他线程锁定的变量</li>
<li>对一个变量执行unlock操作之前,需要将该变量同步回主内存中</li>
</ol>
<blockquote>
<p>为了使我们能正确的操作线程,我们需要理解如下概念:可见性、原子性、线程封闭、不可变性</p>
</blockquote>
<h4 id="可见性">可见性</h4>
<p>可见性:指当某一个线程修改了变量,其他的线程能立刻看到修改后的变量.(<strong>针对变量</strong>)</p>
<p>Java提供了关键字<code>volatile</code>来实现可见性,其保证如下效果:</p>
<ol>
<li>每次访问变量时,总是获取主内存的最新值.</li>
<li>每次修改变量时,立刻写回到主内存.</li>
<li>防止指令重排(指令重排:程序执行的时候，CPU、编译器可能会<strong>对执行顺序做一些优化调整</strong>，导致执行的顺序并不是从上往下的)</li>
</ol>
<pre><code class="language-java">/**
 * volatile:
 * 某线程修改变量时,该变量对其他线程可见
 */
public class VolatileLearn {

    private volatile boolean isRunning = true;

    private static void useVolatile() throws InterruptedException {
        VolatileLearn volatileLearn = new VolatileLearn();

        Thread thread = new Thread(() -&gt; {
            while (volatileLearn.isRunning) {//thread线程读isRunning状态
                System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;volatile-thread-a&quot;);

        thread.start();
        Thread.sleep(1000);
        volatileLearn.isRunning = false;//main线程写isRunning状态
        thread.join();
        System.out.println(thread.getState());
    }

    public static void main(String[] args) throws InterruptedException {
        useVolatile();
        //执行结果:
        //volatile-thread-a is running
		//volatile-thread-a is running
		//TERMINATED
    }
}
</code></pre>
<blockquote>
<p>如果不保证，仍以x86架构为例，JVM对volatile变量的处理如下：</p>
<ul>
<li>在写volatile变量v之后，插入一个sfence。这样，sfence之前的所有store（包括写v）不会被重排序到sfence之后，sfence之后的所有store不会被重排序到sfence之前，禁用跨sfence的store重排序；且sfence之前修改的值都会被写回缓存，并标记其他CPU中的缓存失效。</li>
<li>在读volatile变量v之前，插入一个lfence。这样，lfence之后的load（包括读v）不会被重排序到lfence之前，lfence之前的load不会被重排序到lfence之后，禁用跨lfence的load重排序；且lfence之后，会首先刷新无效缓存，从而得到最新的修改值，与sfence配合保证内存可见性。</li>
</ul>
<p>在另外一些平台上，JVM使用mfence代替sfence与lfence，实现更强的语义。</p>
<p>二者结合，共同实现了Happens-Before关系中的volatile变量规则。</p>
</blockquote>
<h4 id="原子性">原子性</h4>
<p>原子性:指一个或一系列的不可中断的操作.(<strong>针对方法</strong>)</p>
<p>Java提供了关键字<code>synchronized</code>来实现原子性,其保证如下效果:</p>
<ol>
<li><code>synchronized是一种互斥锁</code>,当修饰方法时,保证只允许一个线程能运行该方法直至运行结束释放锁.</li>
<li><code>synchronized是一种内置锁</code>,当修饰对象时,保证只运行一个线程能运行该代码块的内容直至运行结束释放锁.</li>
<li>被修饰的方法/代码块顺序执行,修改后变量对其他线程可见.</li>
</ol>
<pre><code class="language-java">/**
 * synchronized:
 * 修饰方法时,为互斥锁,只允许一个线程运行该方法直至运行结束释放锁
 * 修饰对象时,为内置锁,只允许一个线程运行该代码块的内容直至运行结束释放锁
 */
public class SynchronizedLearn {

    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Thread threadA = new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                counter.increase();
            }
        }, &quot;synchronized-thread-a&quot;);
        Thread threadB = new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                counter.decrease();
            }
        }, &quot;synchronized-thread-b&quot;);
        threadA.start();
        threadB.start();
        threadA.join();
        threadB.join();
        System.out.println(&quot;最后的总数:&quot; + counter.getCount());
    }

    private static class Counter {
        static int count = 0;

        public void decrease() {
            synchronized (this) {//锁住当前实例对象
                System.out.println(Thread.currentThread().getName() + &quot;执行decrease方法&quot;);
                System.out.println(Thread.currentThread().getName() + &quot;进行count--&quot;);
                count--;
            }
        }

        public void increase() {
            synchronized (this) {//锁住当前实例对象
                System.out.println(Thread.currentThread().getName() + &quot;执行increase方法&quot;);
                System.out.println(Thread.currentThread().getName() + &quot;进行count++&quot;);
                count++;
            }
        }

        public int getCount() {
            System.out.println(Thread.currentThread().getName() + &quot;获取count&quot;);
            return count;
        }

        /**
         * 锁住当前方法
         * 当使用synchronized (this) {//所有代码}时,其实等价于直接使用synchronized修饰方法
         * decrease() == synDecrease()
         */
        public synchronized void synDecrease() {
            System.out.println(Thread.currentThread().getName() + &quot;进行count--&quot;);
            count--;
        }

        /**
         * 锁住当前方法
         * increase() == synIncrease()
         */
        public synchronized void synIncrease() {
            System.out.println(Thread.currentThread().getName() + &quot;进行count++&quot;);
            count++;
        }
    }
}
</code></pre>
<p>运行结果如图所示:</p>
<figure data-type="image" tabindex="3"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210519144243.png" alt="截图_选择区域_20210519144243" loading="lazy"></figure>
<blockquote>
<p>为什么会出现一会thread-a操作一会thread-b操作,count还等于-5?不是已经通过synchronized (this)锁住了代码块,保证count的加减操作都是原子性的吗?</p>
<p>解答:</p>
<p>问题1:先是thread-a然后thread-b操作</p>
<p>答:因为系统调度线程是随机的,所以出现了线程A和线程B交替执行的情况.synchronized只保证代码块的内容会依次从上至下顺序执行,不保证线程按顺序调度.</p>
<p>问题2:count==-5?</p>
<p>答:虽然通过synchronized保证了Counter的加减操作是原子性的,但是整个main方法不是原子性操作,其中存在三个线程thread-a/b和main线程.而最后输出时,main线程获取到Counter的count值,此时并不能保证thread-a/b已经执行完,所以取到的count值并不等于0.为了获取到正确的值,其实很简单,等待thread-a/b直接完成就可以了:在输出语句前加上<code>threadA.join();threadB.join();</code>,就能取得正确count值.</p>
<figure data-type="image" tabindex="4"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210519145858.png" alt="截图_选择区域_20210519145858" loading="lazy"></figure>
</blockquote>
<p><em>注意事项</em>:</p>
<ul>
<li>当使用<code>synchronized</code>修饰方法时,等价于方法体内使用<code>synchronized(this){//所有代码}</code>写法,但是静态方法中是不存在<code>this</code>对象的,所以在静态方法中等价于方法体内使用<code>synchronized(Class.class){//所有代码}</code>的写法.</li>
<li>所有方法默认不使用<code>synchronized</code>修饰,所有变量默认不使用<code>volatile</code>修饰,即:除了特殊说明外,一般的类默认是线程不安全的.</li>
</ul>
<h4 id="线程封闭">线程封闭</h4>
<p>由上面的两个例子可以看出,因为操作共享变量带来了诸多问题,才引入关键字来保证多线程能够正确的读写共享变量.既然如此,为了保证线程安全,各个线程不读写共享变量,只在自己的线程中读写自己的变量(<code>局部变量</code>),那就没有干扰了:这种方式称为<code>线程封闭</code>.</p>
<pre><code class="language-java">public class ClosedThreadLearn {

    public int countNumber(){
        int count = 0;

        for (int i = 0; i &lt; 10; i++) {
            count++;//非原子操作,但只对局部变量count有影响,count在方法体外不起作用
        }
        for (int i = 0; i &lt; 10; i++) {
            count--;
        }
        return count;
    }

    public static void main(String[] args){
        ClosedThreadLearn closedThreadLearn = new ClosedThreadLearn();
        Thread threadA = new Thread(() -&gt; {
            int count = closedThreadLearn.countNumber();
            System.out.println(Thread.currentThread().getName()+&quot; count = &quot;+count);
        }, &quot;closed-thread-a&quot;);
        Thread threadB = new Thread(() -&gt; {
            int count = closedThreadLearn.countNumber();
            System.out.println(Thread.currentThread().getName()+&quot; count = &quot;+count);
        }, &quot;closed-thread-b&quot;);
        threadA.start();
        threadB.start();
        //输出结果:
        //closed-thread-b count = 0
        //closed-thread-a count = 0
    }
}
</code></pre>
<h4 id="不可变性">不可变性</h4>
<p>除了使用局部变量的方式,我们还可以使用<code>final</code>关键字来修饰共享变量,来保证该变量是<code>不可变</code>变量.</p>
<pre><code class="language-java">public final class ImmutableVariableLearn {//被final修饰的类不可被继承

    private final int count = 100;//被final修饰的变量必须被初始化,不被能修改
    private final List&lt;Integer&gt; list;//虽然list对象不能被重新赋值(执行新的引用),但是不能避免list对象内部的值发生变化

    public ImmutableVariableLearn(List&lt;Integer&gt; list) {
        this.list = list;
    }

    public final int countNumber() {//被final修饰的方法不可被重写
        //count++; Cannot assign a value to final variable 'count'
        return count;
    }

    public final List&lt;Integer&gt; addElement(){
        list.add(count);//虽然被final修饰,仍然可以add元素
        return list;
    }

    public static void main(String[] args){
        ImmutableVariableLearn immutableVariableLearn = new ImmutableVariableLearn(new ArrayList&lt;&gt;());
        Thread threadA = new Thread(() -&gt; {
            int count = immutableVariableLearn.count;
            System.out.println(Thread.currentThread().getName() + &quot; count:&quot; + count);
            for (Integer integer : immutableVariableLearn.addElement()) {
                System.out.println(Thread.currentThread().getName()+&quot; list element:&quot;+integer);
            }
        }, &quot;immutableVary-thread-a&quot;);

        Thread threadB = new Thread(() -&gt; {
            int count = immutableVariableLearn.count;
            System.out.println(Thread.currentThread().getName() + &quot; count:&quot; + count);
            for (Integer integer : immutableVariableLearn.addElement()) {
                System.out.println(Thread.currentThread().getName()+&quot; list element:&quot;+integer);
            }
        }, &quot;immutableVary-thread-b&quot;);
        threadA.start();
        threadB.start();
    }
}
</code></pre>
<p>结果如图所示:</p>
<figure data-type="image" tabindex="5"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210519170357.png" alt="截图_选择区域_20210519170357" loading="lazy"></figure>
<blockquote>
<p>为什么被final修饰的addElement()方法会出现两个thread-a list element(100),而且thread-b会抛出异常?</p>
<p>问题1:遍历addElement(),返回了2个thread-a list element(100)</p>
<p>答:final修饰方法既不能保证addElement()方法具有原子性,也不会为方法上锁,而addElement中调用了list.add()方法,list属于ArrayList,它不是线程安全的类,add()方法线程不安全.</p>
<p>所以当thread-b为list新增了一个元素后,thread-a又为list新增了一个元素,所以在thread-a中遍历出现了2个element(100),但thread-b第一次新增元素还来得及执行输出语句时,就已经检测到异常并抛出了</p>
<p>问题2:thread-b抛出异常</p>
<p>答:在使用foreach遍历list时,java语法糖隐式调用了Iterator迭代器,使用Iterator.hasNext()和Iterator.next()进行遍历.查看ArrayList中Iterator.next()实现,modCount != expectedModCount时会抛出该异常.由于thread-b读取到的expectedModCount=1,而thread-a又对集合添加了元素,modCount=2,所以导致modCount!=expectedModCount,抛出异常.</p>
<pre><code>public E next() {
 checkForComodification();
 int i = cursor;
 if (i &gt;= size)
 throw new NoSuchElementException();
 Object[] elementData = ArrayList.this.elementData;
 if (i &gt;= elementData.length)
 throw new ConcurrentModificationException();
 cursor = i + 1;
 return (E) elementData[lastRet = i];
}
     
final void checkForComodification() {
 if (modCount != expectedModCount)
     throw new ConcurrentModificationException();
}
</code></pre>
<p>字节码文件中,foreach隐式调用Iterator迭代器模式进行遍历:</p>
<figure data-type="image" tabindex="6"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210519164154.png" alt="截图_选择区域_20210519164154" loading="lazy"></figure>
</blockquote>
<p>正确的做法应该是:当使用final修饰变量时,使用线程安全的类.</p>
<pre><code class="language-java">public final class ImmutableVariableLearn {//被final修饰的类不可被继承

    private final int count = 100;//被final修饰的变量必须被初始化,不被能修改
    private final CopyOnWriteArrayList&lt;Integer&gt; list;//虽然list对象不能被重新赋值(执行新的引用),但是不能避免list对象内部的值发生变化

    public ImmutableVariableLearn(CopyOnWriteArrayList&lt;Integer&gt; list) {
        this.list = list;
    }

    public final int countNumber() {//被final修饰的方法不可被重写
        //count++; Cannot assign a value to final variable 'count'
        return count;
    }

    public final List&lt;Integer&gt; addElement(){
        list.add(count);//虽然被final修饰,仍然可以add元素
        return list;
    }

    public static void main(String[] args){
        ImmutableVariableLearn immutableVariableLearn = new ImmutableVariableLearn(new CopyOnWriteArrayList&lt;&gt;());
        Thread threadA = new Thread(() -&gt; {
            int count = immutableVariableLearn.count;
            System.out.println(Thread.currentThread().getName() + &quot; count:&quot; + count);
            for (Integer integer : immutableVariableLearn.addElement()) {
                System.out.println(Thread.currentThread().getName()+&quot; list element:&quot;+integer);
            }
        }, &quot;immutableVary-thread-a&quot;);

        Thread threadB = new Thread(() -&gt; {
            int count = immutableVariableLearn.count;
            System.out.println(Thread.currentThread().getName() + &quot; count:&quot; + count);
            for (Integer integer : immutableVariableLearn.addElement()) {
                System.out.println(Thread.currentThread().getName()+&quot; list element:&quot;+integer);
            }
        }, &quot;immutableVary-thread-b&quot;);
        threadA.start();
        threadB.start();
    }
}
</code></pre>
<p>结果如图所示,没有异常抛出.</p>
<figure data-type="image" tabindex="7"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210519170812.png" alt="截图_选择区域_20210519170812" loading="lazy"></figure>
<blockquote>
<p>不可变性是函数式编程的重要思想和基石.<em>共享变量就不可变,可变变量就不共享</em>.</p>
<p>想要改变一个不可变对象时,利用修改后的值,创建一个新的对象并指向它.(参见java.lang.String)</p>
</blockquote>
<h4 id="死锁">死锁</h4>
<p>死锁：两个或两个以上的线程交叉执行,互相持有对方的锁并一直不释放,造成永久等待.</p>
<pre><code class="language-java">/**
 * 死锁条件:
 * 1.多个线程交替执行
 * 2.相互持有锁且不释放.永久等待
 */
public class DeadLock {

    private  final Object lockA = new Object();
    private  final Object lockB = new Object();
    private  int sum = 0;
    
    public int increase(int num) throws InterruptedException {
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
        synchronized (lockA){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
            synchronized (lockB){
                System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
                sum+=num;
                Thread.sleep(1000);
            }
            System.out.println(Thread.currentThread().getName()+&quot;:释放lock b&quot;);
        }
        System.out.println(Thread.currentThread().getName()+&quot;:释放lock a&quot;);
        return sum;
    }
    
    public int decrease(int num) throws InterruptedException {
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
        synchronized (lockB){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
            synchronized (lockA){
                System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
                sum-=num;
                Thread.sleep(1000);
            }
            System.out.println(Thread.currentThread().getName()+&quot;:释放lock a&quot;);
        }
        System.out.println(Thread.currentThread().getName()+&quot;:释放lock b&quot;);
        return sum;
    }
    
    public static void main(String[] args){
        DeadLock deadLock = new DeadLock();
        Thread threadA = new Thread(() -&gt; {
            int sum = 0;
            try {
                sum = deadLock.increase(5);
                System.out.println(Thread.currentThread().getName() + &quot; 增加后的sum=&quot; + sum);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, &quot;dead-thread-a&quot;);

        Thread threadB = new Thread(() -&gt; {
            int sum = 0;
            try {
                sum = deadLock.decrease(5);
                System.out.println(Thread.currentThread().getName() + &quot; 减少后的sum=&quot; + sum);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, &quot;dead-thread-b&quot;);

        threadA.start();
        threadB.start();
    }
}
</code></pre>
<p>结果如图所示:</p>
<figure data-type="image" tabindex="8"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210520111457.png" alt="截图_选择区域_20210520111457" loading="lazy"></figure>
<p>在thread-a/b执行到试图获取lock b/a时,就开始一直等待,形成了死锁.此时,只能通过结束进程来释放资源.</p>
<h5 id="避免死锁">避免死锁</h5>
<ol>
<li>固定加锁顺序 (针对<code>互相持有</code>)</li>
<li>开放调用(细化锁力度,减少锁面积)</li>
<li>使用定时锁(针对<code>一直等待</code>)</li>
</ol>
<pre><code class="language-java">/**
 * 1.固定加锁顺序
 * 仍然是这两个操作,只不过调整了increase和decrease都是先获取lockA,然后获取lockB,接着释放lockB,最后释放lockA
 */
public int increased(int num) throws InterruptedException {
    System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
    synchronized (lockA){
        System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
        Thread.sleep(1000);
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
        synchronized (lockB){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
            sum+=num;
            Thread.sleep(1000);
        }
        System.out.println(Thread.currentThread().getName()+&quot;:释放lock b&quot;);
    }
    System.out.println(Thread.currentThread().getName()+&quot;:释放lock a&quot;);
    return sum;
}

public int decrease(int num) throws InterruptedException {
    System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
    synchronized (lockA){
        System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
        Thread.sleep(1000);
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
        synchronized (lockB){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
            sum-=num;
            Thread.sleep(1000);
        }
        System.out.println(Thread.currentThread().getName()+&quot;:释放lock b&quot;);
    }
    System.out.println(Thread.currentThread().getName()+&quot;:释放lock a&quot;);
    return sum;
}
</code></pre>
<p>结果如图所示:</p>
<figure data-type="image" tabindex="9"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210520134610.png" alt="截图_选择区域_20210520134610" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 使用定时锁
 * 仍然是这两个操作
 * 同样是先某线程在increase中先获取lock a,再获取lock b,另一个线程在decrease中先获取lock b, 再获取lock a
 * 区别在于我们不再无限获取锁,如果等待时间内还是获取不到另一把锁,我们放弃获取另一把锁
 */
public int increase(int num) throws InterruptedException {
    System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
    if (lockA.tryLock(5, TimeUnit.SECONDS)){
        System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
        Thread.sleep(1000);
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
        if(lockB.tryLock(3, TimeUnit.SECONDS)){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
            sum+=num;
            Thread.sleep(1000);
        }else{
            System.out.println(Thread.currentThread().getName()+&quot;:放弃获取lock b&quot;);
        }
    }else{
        System.out.println(Thread.currentThread().getName()+&quot;:放弃获取lock a&quot;);
    }
    return sum;
}

public int decrease(int num) throws InterruptedException {
    System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock b&quot;);
    if(lockB.tryLock(5, TimeUnit.SECONDS)){
        System.out.println(Thread.currentThread().getName()+&quot;:获取到lock b&quot;);
        Thread.sleep(1000);
        System.out.println(Thread.currentThread().getName()+&quot;:试图获取lock a&quot;);
        if(lockA.tryLock(5, TimeUnit.SECONDS)){
            System.out.println(Thread.currentThread().getName()+&quot;:获取到lock a&quot;);
            sum-=num;
            Thread.sleep(1000);
        }else{
            System.out.println(Thread.currentThread().getName()+&quot;:放弃获取lock a&quot;);
        }
    }else {
        System.out.println(Thread.currentThread().getName()+&quot;:放弃获取lock b&quot;);
    }
    return sum;
}
</code></pre>
<p>结果如图所示:</p>
<figure data-type="image" tabindex="10"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210520142850.png" alt="截图_选择区域_20210520142850" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 多线程 - 基础介绍]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-ji-chu-jie-shao/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-duo-xian-cheng-ji-chu-jie-shao/">
        </link>
        <updated>2021-05-18T06:33:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1线程是什么">1.线程是什么</h4>
<p>进程:一个运行中的应用程序,如(一个浏览器,一个QQ,一个java程序).</p>
<p>线程:一个应用程序的子任务,如(浏览器:浏览页面,刷新页面,另开标签页,播放视频/音乐).</p>
<p>可以从介绍中得出结论:</p>
<ol>
<li>可以同时存在多个进程,一个进程中包含至少一个线程,可以包含多个线程.</li>
<li>应用程序的单位是进程(浏览器),即操作系统资源分配最小单位是进程.</li>
<li>执行任务的单位是线程(浏览页面),即操作系统任务调度最小单位是线程.</li>
</ol>
<h4 id="2线程与进程的区别">2.线程与进程的区别</h4>
<p>进程:</p>
<ol>
<li>操作系统为每个进程分配了独立的内存空间和系统资源.</li>
<li>在进行多进程间切换时,会消耗大量的时间和空间(进程的创建、撤消和切换).</li>
<li>在进行多进程间通信时,相对于线程而言较慢.</li>
<li>在进程崩溃时,不会影响到其他的进程.(QQ崩溃了不妨碍看网页)</li>
</ol>
<p>线程:</p>
<ol>
<li>线程属于进程,是任务的执行单位.属于一个进程的多线程,在系统给进程分配的同一块内存空间中工作,资源共享.</li>
<li>在进行多线程间切换时,因为共享同一块系统资源(内存空间和数据),所以切换时消耗的时间和空间较少.</li>
<li>在进行多线程间通信时,因为资源共享,所以相对于进程更快.</li>
<li>在线程崩溃时,进程也会崩溃.(QQ发起多人视频时卡死,QQ崩溃)</li>
</ol>
<h4 id="3为什么要使用多线程">3.为什么要使用多线程</h4>
<p>我们可以从上面的结论看到,一个进程起码分配了一个线程,操作系统由线程执行任务.</p>
<p>当我们使用单线程执行任务时,也就是让一个进程只使用一个线程执行任务:一个CPU同时运行一个浏览器,一个QQ,一个java程序.由于CPU运行速度非常快，会让人产生CPU在同时执行浏览器、QQ、Java程序的错觉.其实是一个CPU在某一个时刻,只能运行一个任务.</p>
<blockquote>
<p>计算机组件运行时间对比:</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/image-20210517160458592.png" alt="image-20210517160458592" loading="lazy"></figure>
</blockquote>
<p>为了能使得进程(QQ)能有更多的任务在CPU中执行,我们就需要创建多个线程来增加抢占CPU执行权的概率,让CPU更多的执行该进程(QQ)的任务.</p>
<p><strong>本质上讲:使用多线程就是为了提高利用系统资源率,抢占CPU执行权</strong>.</p>
<h4 id="4并发与并行">4.并发与并行</h4>
<p>并发:1个CPU在<strong>某一段时间</strong>执行<strong>多个</strong>任务.</p>
<p>并行:多个CPU在<strong>某一刻时间</strong>执行<strong>多个</strong>任务.</p>
<h4 id="5线程的使用">5.线程的使用</h4>
<h5 id="创建线程">创建线程</h5>
<pre><code class="language-java">/**
 * JDK中Thread类的注释:
 * java.lang public class Thread extends Object implements Runnable
 * 线程是程序中的执行线程。 Java虚拟机允许应用程序具有多个并发运行的执行线程。
 * 每个线程都有一个优先级。 具有较高优先级的线程优先于具有较低优先级的线程执行。
 * 每个线程可能会也可能不会被标记为守护程序。 当在某个线程中运行的代码创建新的Thread对象时，新线程的优先级最初设置为与创建线程的优先级相等，
 * 并且当且仅当创建线程是守护程序时，该线程才是守护程序线程。
 * Java虚拟机启动时，通常只有一个非守护程序线程（通常调用某些指定类的名为main的方法）。 Java虚拟机将继续执行线程，直到发生以下任何一种情况：
 * 调用了Runtime类的exit方法，并且安全管理器允许进行退出操作。
 * 不是守护程序线程的所有线程都已死，要么通过从调用返回到run方法，要么抛出异常传播到run方法之外
 */
public class MyThread {

    public static void main(String[] args){
        //使用start()方法唤起新线程
        createThread().start();//输出:我是继承Thread线程
        createThread2().start();//输出:我是实现Runnable线程
        createThread3().start();//我是匿名内部类实现的Runnable线程
    	//run()方法仅仅只是一个普通类的方法调用,并不会创建新线程
    }

    /**
     * 三种创建线程的方式:
     * 其一:继承Thread类
     * @return
     */
    private static Thread createThread() {
        Thread thread = new Thread1();
        thread.setPriority(1);
        return thread;
    }
    
    /**
     * 继承Thread类,重写run方法
     */
    private static class Thread1 extends Thread{
        @Override
        public void run() {
            System.out.println(&quot;我是继承Thread线程&quot;);;
        }
    }

    /**
     * 三种创建线程的方式:
     * 其二:实现Runnable接口, 使用Thread(Runnable target)构造方法创建Thread对象
     * @return
     */
    private static Thread createThread2() {
        Thread thread = new Thread(new Thread2());
        thread.setPriority(2);
        return thread;
    }

    /**
     * 实现Runnable接口,重写run方法
     */
    private static class Thread2 implements Runnable {
        @Override
        public void run() {
            System.out.println(&quot;我是实现Runnable线程&quot;);;
        }
    }
    
    /**
     * 三种创建线程的方式:
     * 其三:使用Thread(Runnable target)构造方法,利用匿名内部类实现Runnable接口,重写run方法
     * @return
     */
    private static Thread createThread3() {
        Thread thread = new Thread(() -&gt; System.out.println(&quot;我是匿名内部类实现的Runnable线程&quot;));
        thread.setPriority(3);
        return thread;
    }

}
</code></pre>
<p>输出结果:</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/image-20210517165629377.png" alt="image-20210517165629377" loading="lazy"></figure>
<p>结论:并不是较高优先级的线程一定会优先于具有较低优先级的线程执行,只是增加了执行概率.</p>
<h5 id="线程状态">线程状态</h5>
<p><code>java.lang.Thread</code>中<code>State</code>定义了六种状态:</p>
<pre><code class="language-java">/**
 * 线程状态。 线程可以处于以下状态之一：
 * NEW 尚未启动的线程处于此状态。
 * RUNNABLE 在Java虚拟机中执行的线程处于这种状态。
 * BLOCKED 在等待监视器锁定的情况下被阻塞的线程处于此状态。
 * WAITING 无限期地等待另一个线程执行特定操作的线程处于此状态。
 * TIMED_WAITING 正在等待另一个线程执行操作的线程最多达到指定的等待时间，该线程处于此状态。
 * TERMINATED 退出的线程处于此状态。
 * 在给定的时间点，线程只能处于一种状态。 这些状态是虚拟机状态，不反映任何操作系统线程状态
 */
public enum State {
        /**
         * Thread state for a thread which has not yet started.
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * &lt;ul&gt;
         *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
         *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * &lt;p&gt;A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called {@code Object.wait()}
         * on an object is waiting for another thread to call
         * {@code Object.notify()} or {@code Object.notifyAll()} on
         * that object. A thread that has called {@code Thread.join()}
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * &lt;ul&gt;
         *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
         *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
         *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
         * &lt;/ul&gt;
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://img.zhengjianru.work/20190314085808279.png" alt="image-20210517170432312" loading="lazy"></figure>
<pre><code class="language-java">private static void threadState() {
    Object lock = new Object();

    //Thread.state.NEW
    Thread thread = new Thread(()-&gt;{
        synchronized (lock){//Thread.state.BLOCKED
            Thread currentThread = Thread.currentThread();
            try {
                lock.wait();//Thread.state.WAITING
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;这是第一个线程:&quot;+currentThread.getName());
        }
    },&quot;block-thread-1&quot;);
    Thread thread2 = new Thread(()-&gt;{
        synchronized (lock){//Thread.state.BLOCKED
            try {
                Thread.sleep(500);//Thread.state.TIMED_WAITING
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;这是第二个线程:&quot;+Thread.currentThread().getName());
        }
    },&quot;block-thread-2&quot;);

    //Thread.state.RUNNABLE
    thread.start();
    thread2.start();

    //Thread.state.TERMINATED
    System.out.println(thread.getState());
    System.out.println(thread2.getState());
}
</code></pre>
<h5 id="中断线程">中断线程</h5>
<pre><code class="language-java">/**
 * 中断此线程。
 * 除非始终允许当前线程中断自身，否则将一直调用此线程的checkAccess方法，这可能导致引发SecurityException 。
 * 如果在调用Object类的wait() ， wait(long)或wait(long, int)方法或join() ， join(long) ， join(long, int)方法时阻塞了该线程， sleep(long)或sleep(long, int)此类的方法，则其中断状态将被清除，并将收到InterruptedException 。
 * 如果此线程在InterruptibleChannel的I / O操作中被阻止，则该通道将被关闭，该线程的中断状态将被设置，并且该线程将收到java.nio.channels.ClosedByInterruptException 。
 * 如果此线程在java.nio.channels.Selector被阻塞，则将设置该线程的中断状态，并且它将立即从选择操作中返回（可能具有非零值），就像调用选择器的wakeup方法一样。
 * 如果上述条件均不成立，则将设置该线程的中断状态。
 * 中断未运行的线程不会产生任何效果。
 */
private static void interruptThread() throws InterruptedException {
    Thread thread = new Thread(() -&gt; {//thread-&gt;Thread.state.NEW
        int n = 0;
        try {
            Thread.sleep(10);//thread-&gt;Thread.state.TIMED_WAITING
            while (!Thread.interrupted()) {//非中断状态,计数并输出
                System.out.printf(&quot;第%s次打印:hello thread%n&quot;, ++n);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, &quot;interrupt-thread-a&quot;);
    thread.start();//thread-&gt;Thread.state.RUNNABLE
    Thread.sleep(50);//mainThread-&gt;Thread.state.TIMED_WAITING
    thread.interrupt();//中断thread
    thread.join();//thread-&gt;Thread.state.WAITING
    System.out.println(thread.getState());//thread-&gt;Thread.state.TERMINATED
}
</code></pre>
<h5 id="守护线程">守护线程</h5>
<pre><code class="language-java">/**
 * 将此线程标记为守护程序线程或用户线程。 
 * 当所有正在运行的线程都是守护程序线程时，Java虚拟机将退出。
 * 必须在线程启动之前调用此方法
 */
private static Thread daemonThread() {
    Thread thread = new Thread(() -&gt; {
        while(true){
            System.out.println(LocalTime.now());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                break;
            }
        }
    }, &quot;daemon-thread-a&quot;);
    thread.setDaemon(true);//将thread标记为守护线程
    thread.start();
    return thread;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 泛型]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-fan-xing/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-fan-xing/">
        </link>
        <updated>2021-05-14T02:10:06.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1泛型是什么">1.泛型是什么</h4>
<p>在java中,泛型是指:参数化类型-即把类型当做参数传递,当调用类/方法时,传递指定类型.是一种通用的代码模板处理手段,利用泛型,可以使一套代码,多种使用方式.</p>
<h4 id="2为什么要使用泛型">2.为什么要使用泛型</h4>
<ol>
<li>使代码更加简洁，不必进行强制类型转换，避免了<code>ClassCastException</code>异常。</li>
<li>使代码更具有通用性，避免了重复代码。</li>
</ol>
<h4 id="3使用泛型">3.使用泛型</h4>
<h5 id="定义泛型">定义泛型</h5>
<pre><code class="language-java">/**
 * 泛型类
 * @param &lt;K&gt; key的类型
 * @param &lt;V&gt; value的类型
 */
public class Pair &lt;K,V&gt;{
    
    private final K key;
    private final V value;
    //编译器提示出错:org.pzzhang.generics.Pair.this' cannot be referenced from a static context,泛型使用不能在静态成员变量上
    //private static K staticProperty;

    /**
     * 无法直接通过new K/V()的方式进行初始化
     * this.key = new K(); type parameter 'K' cannot be instantiated directly
     *  his.value = new V(); type parameter 'V' cannot be instantiated directly
     *  可以采用如下两种方式进行初始化
     */

    //1.通过Object强制转换为目标类型
    public Pair() {
        this.key = (K) new Object();
        this.value = (V) new Object();
    }

    //2.通过指定K,V的class,使用Class.newInstance()方法
    public Pair(Class&lt;K&gt; kClass,Class&lt;V&gt; vClass) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        this.key = kClass.getDeclaredConstructor().newInstance();
        this.value = vClass.getDeclaredConstructor().newInstance();
    }

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    /**
     * 注意:此处的createPairs的方法与下面createPari方法并不一致
     * 此处定义的泛型K,V跟Pair.class定义的泛型K,V没有关系
     * 此处定义的泛型由返回值前面定义的&lt;K,V&gt;相关,它也可以是&lt;T,B&gt; 效果是相等的
     * 而createPair方法参数类型的K,V才是由Pair.class定义的泛型K,V,它不能是T,B,编译器会提示Cannot resolve symbol 'T,B'
     * 所以createPairs == createPairs2 != createPair
     * @return
     */
    public static &lt;K,V&gt; Pair&lt;K,V&gt; createPairs(K key,V value){
        return new Pair&lt;&gt;(key,value);
    }

    /**
     * 泛型方法 - 使用由类定义的泛型K,V
     * @param key
     * @param value
     * @return
     */
    public  Pair&lt;K,V&gt; createPair(K key, V value){
        return new Pair&lt;&gt;(key,value);
    }

    /**
     * 静态泛型方法 - 使用由方法中返回值前定义的泛型T,B;与类定义的泛型无关
     * @param key
     * @param value
     * @param &lt;T&gt;
     * @param &lt;B&gt;
     * @return
     */
    public static &lt;T,B&gt; Pair&lt;T,B&gt; createPairs2(T key,B value){
        return new Pair&lt;&gt;(key,value);
    }
    
    /*
    编译器出错,提示Cannot resolve symbol 'T,B'
    public static Pair&lt;T,B&gt; createPairs3(T key,B value){
        return new Pair&lt;&gt;(key,value);
    }*/

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }
}
</code></pre>
<h5 id="使用泛型">使用泛型</h5>
<pre><code class="language-java">public static void main(String[] args){
  Pair&lt;String, Object&gt; pair = new Pair&lt;&gt;(&quot;charles&quot;,123);
  //泛型限制了传入K,V类型只能是String,Object
  System.out.println(String.format(&quot;key:%s,value:%s&quot;,pair.getKey(),pair.getValue()));
  //key:charles,value:123
    
  Pair&lt;String, String&gt; pair2 = new Pair&lt;&gt;(&quot;锁&quot;,&quot;钥匙&quot;);
  //泛型限制了传入K,V类型只能是String,String
  System.out.println(String.format(&quot;key:%s,value:%s&quot;,pair2.getKey(),pair2.getValue()));
  //key:锁,value:钥匙
    
  Pair&lt;String, Integer&gt; pair3 = Pair.createPairs2(&quot;锁密码&quot;, 123);
  //静态泛型方法参数决定了返回值类型为String,Integer
  System.out.println(String.format(&quot;key:%s,value:%s&quot;,pair3.getKey(),pair3.getValue()));
  //key:锁密码,value:123
}
</code></pre>
<h4 id="4泛型擦除">4.泛型擦除</h4>
<h5 id="泛型擦除定义">泛型擦除定义</h5>
<p>泛型擦除是什么?泛型擦除其实就是Java实现泛型的方式.在编译阶段,编译器已经强制转型为目标类型了,如:<code>Pair&lt;K.class,V.class&gt; pair = (Pair&lt;K.class,V.class&gt;)new Pair&lt;Object,Object&gt;();</code>,在运行阶段,JVM看不到K,V了,只有Pair.class.让我们看一个例子:</p>
<pre><code class="language-java">public static void main(String[] args){
    Pair&lt;String,Object&gt; pairEx1 = new Pair&lt;&gt;();
	Pair&lt;Integer,String&gt; pairEx2 = new Pair&lt;&gt;();
	System.out.println(Pair.getClass().equals(Pair.getClass()));//true
}
//class在JVM中只有独一份,结果等于true.
//说明在运行期间JVM认为Pair&lt;String,Object&gt;==Pair&lt;Integer,String&gt;.
//即只存在一个PairExClass.
</code></pre>
<h5 id="泛型擦除后的信息">泛型擦除后的信息</h5>
<p>那么又产生了一个新的问题:发生了泛型擦除,那我在运行期还能否获取到泛型的具体类型呢?看下面的例子</p>
<pre><code class="language-java">public static void main(String[] args){
    Type pairExType = PairExClass.class.getGenericSuperclass();
    if(pairExType instanceof ParameterizedType){//判断父类Class是否是参数化类型(泛型类)
        for (Type actualTypeArgument : ((ParameterizedType) pairExType).getActualTypeArguments()) {
            System.out.println(actualTypeArgument.getTypeName());
            //输出K,V
        }
    }

    Type pairEx1Type = PairExClass1.class.getGenericSuperclass();
    if(pairEx1Type instanceof ParameterizedType){//判断父类Class是否是参数化类型(泛型类)
        for (Type actualTypeArgument : ((ParameterizedType) pairEx1Type).getActualTypeArguments()) {
            System.out.println(actualTypeArgument.getTypeName()); 
            //输出java.lang.String;java.lang.Object;
        }
    }
}
</code></pre>
<p>从上述输出结果中可以明确看到,在运行期又可以拿到泛型的信息.这是为什么?</p>
<blockquote>
<p>Pair字节码文件:</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_jetbrains-idea_20210513153421.png" alt="截图_jetbrains-idea_20210513153421" loading="lazy"></figure>
<p>可以从Pair的字节码文件中观察到:class信息上没有了泛型的信息.</p>
<p>上面的注释中signature标明了Pair的泛型信息为(K:java.lang.Object,V:java.lang.Object).</p>
<p>而declaration标明了类信息为:Pair&lt;K,V&gt;</p>
</blockquote>
<blockquote>
<p>PairExClass字节码文件:</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_jetbrains-idea_20210513153948.png" alt="截图_jetbrains-idea_20210513153948" loading="lazy"></figure>
<p>可以从PairExClass的字节码文件中观察到:class信息上没有了泛型的信息.</p>
<p>上面的注释中signature标明了PairExClass的泛型信息为(K:java.lang.Object,V:java.lang.Object).Pair的泛型信息为&lt;TK,TV&gt;</p>
<p>而declaration标明了类的继承关系:PairExClass&lt;K,V&gt; extends Pair&lt;K,V&gt;</p>
</blockquote>
<p>所以在字节码文件中,signature可以取到泛型的具体类型.如果是K,V类型没有指定的情况,返回java.lang.Object;否则返回具体的指定类型.</p>
<h5 id="不恰当的覆写方法">不恰当的覆写方法</h5>
<p>当我们编写equals方法时,编译器提示:</p>
<pre><code class="language-java">/**
 * 编译不通过,编译提示:
 * 'equals(K)' in 'org.pzzhang.generics.Pair' clashes with 'equals(Object)' in    
 * 'java.lang.Object'; both methods have same erasure, yet neither overrides the other
 * @param o
 * @return
 */
public boolean equals(K o) {
    return this == o;
}

/**
 * 编译通过
 */
public boolean equals(String str){
    return this.toString().equals(str);
}
</code></pre>
<p>可是问题是,我们的类型K又不一定会是Object,这应该算是方法的重载而不是重写.为什么会出现这样的情况?</p>
<p>是因为在发生了泛型擦除之后,没有指定的K类型如上述所说会被编译成java.lang.Object;则equals方法就和父类Object中的equals方法完全一致.那么正确的的做法是什么?</p>
<pre><code class="language-java">/**
 * 编译通过
 * 方法名不一致,避免了冲突,则自然不会重写父类的方法
 */
public boolean isSame(K v){
	return this == v;
}
</code></pre>
<h5 id="泛型的限制">泛型的限制</h5>
<p>正因为泛型擦除的存在,在编译时将泛型类型擦除为了Object,那么就会存在如下问题</p>
<ol>
<li>
<p>泛型类型不能为基础数据类型</p>
<pre><code class="language-java">/**
 * 编译不通过
 * 编译错误:Type argument cannot be of primitive type
 * class PairExClass3 extends Pair&lt;int&gt;{}
 */
</code></pre>
</li>
<li>
<p>无法获取到泛型的Class</p>
<pre><code class="language-java">Type pairEx1Type = PairExClass1.class.getGenericSuperclass();
if(pairEx1Type instanceof ParameterizedType){//判断父类Class是否是参数化类型(泛型类)
    for (Type actualTypeArgument : ((ParameterizedType) pairEx1Type).getActualTypeArguments()) {
        System.out.println(&quot;class :&quot;+actualTypeArgument.getClass());
        //输出java.lang.String;java.lang.Object;
    }
}
</code></pre>
</li>
<li>
<p>无法判断带泛型的类型</p>
<pre><code class="language-java">/**
 * 无法通过编译:Illegal generic type for instanceof
 * PairExClass&lt;String,Object&gt; pairExClass = new PairExClass&lt;&gt;();
 * System.out.println(pairExClass instanceof PairExClass&lt;String, Object&gt;);
 */
</code></pre>
</li>
<li>
<p>不能直接实例化泛型类型</p>
<pre><code class="language-java">/**
 * 无法通过编译:type parameter 'K,V' cannot be instantiated directly
 * this.key = new K();
 * this.value = new V();
 */
</code></pre>
</li>
</ol>
<h4 id="5泛型的继承关系">5.泛型的继承关系</h4>
<p>我们知道,Java中提供了关键字extends表示类的继承关系.那么能否直接通过extends继承泛型类呢?</p>
<pre><code class="language-java">/**
 * 编译通过
 * @param &lt;K&gt; 指定泛型类型为K
 * @param &lt;V&gt; 指定泛型类型为V
 */
public class PairExClass&lt;K,V&gt; extends Pair&lt;K,V&gt;{

    @Override
    public Pair&lt;K, V&gt; createPair(K key, V value) {
        return super.createPair(key, value);
    }
}

/**
 * 编译通过
 * K:指定泛型类型为String
 * V:指定泛型类型为Object
 */
class PairExClass1 extends Pair&lt;String,Object&gt;{

    /**
     * Pair的父类方法中,所有的泛型K类型都变成了String,泛型V变成了Object
     * @param key
     * @param value
     * @return
     */
    @Override
    public Pair&lt;String, Object&gt; createPair(String key, Object value) {
        return super.createPair(key, value);
    }
}

/**
 * 编译不通过
 * 编译错误:Cannot resolve symbol 'K,V'
 * class PairExClass2 extends Pair&lt;K,V&gt;{
 *     @Override
 *     public Pair&lt;K, V&gt; createPair(K key, V value) {
 *         return super.createPair(key, value);
 *     }
 * }
 */
</code></pre>
<h4 id="6泛型的通配符">6.泛型的通配符</h4>
<h5 id="extends通配符">extends通配符</h5>
<pre><code class="language-java">/**
 * extends定义泛型类
 * 泛型限制传入参数类型必须继承于Number
 * @param &lt;N&gt; 参数类型
 */
public class PairGenericExClass &lt;N extends Number&gt;{

    private final N key;

    public PairGenericExClass(N key) {
        this.key = key;
    }

     /**
     * extends定义泛型方法参数
     */
    public boolean containKeyOrAddKey(List&lt;? extends Integer&gt; list){
        for (Integer integer : list) {
            if(integer.equals(key)) return true;
        }
        // 编译错误,无法添加: Required type:capture of ? extends Integer
        //Integer key = (Integer) this.key;
        //list.add(key);
        return false;
    }
    
    public static void main(String[] args){
        PairGenericExClass&lt;Integer&gt; integerPair = new PairGenericExClass&lt;&gt;(123);
        PairGenericExClass&lt;Double&gt; doublePair = new PairGenericExClass&lt;&gt;(123d);
        //编译错误,Type parameter 'java.lang.String' is not within its bound; should extend 'java.lang.Number'
        //PairGenericExClass&lt;String&gt; stringPair = new PairGenericExClass&lt;&gt;(&quot;123&quot;);
       System.out.println(integerPair.containKeyOrAddKey(Arrays.asList(123,456)));//true
    } 
}
</code></pre>
<p>显而易见:</p>
<ol>
<li>
<p>在使用extends修饰泛型类时,限制了泛型类型只能是Number以及Number的子类,String无法通过编译;</p>
</li>
<li>
<p>在使用extends修饰方法泛型参数时,可以获取到list所有元素,但限制了对list元素进行修改操作.(只读)</p>
</li>
</ol>
<h5 id="super通配符">super通配符</h5>
<pre><code class="language-java">/**
 * 编译错误:不支持的语法
 * class PairGenericSuClass2 &lt;P super Number&gt;{}
 */
public class PairGenericSuClass{

    private final Integer key;
    private final Integer value;

    public PairGenericSuClass(Integer key, Integer value) {
        this.key = key;
        this.value = value;
    }

    public Pair resetPair(Pair&lt;? super Integer,? super Integer&gt; pair) {
        return pair.createPair(key,value);
    }


    public static void main(String[] args){
        PairGenericSuClass pairGenericSuClass = new PairGenericSuClass(5, 7);
        Pair pair = pairGenericSuClass.resetPair(new Pair&lt;&gt;());
        System.out.println(&quot;pair key:&quot;+pair.getKey()+&quot;,pair value:&quot;+pair.getValue());
        //pair key:5,pair value:7
        Pair pair2 = pairGenericSuClass.resetPair(new Pair&lt;&gt;());
        System.out.println(&quot;pair2 key:&quot;+pair2.getKey()+&quot;,pair2 value:&quot;+pair2.getValue());
        //pair2 key:5,pair2 value:7

        //虽然我们明确知道pair.getKey()的值是int类型,但由于它既可能是int类型,还可以是Number类型,甚至是Object类型
        //所以我们只能通过Object去接受它,否则编译器会提示Provide type:Object,Required type:Integer,无法通过编译
        //Integer key = pair.getKey();
    }
}
</code></pre>
<p>显而易见:</p>
<ol>
<li>
<p>super无法像extends那样修饰泛型类</p>
</li>
<li>
<p>super修饰方法泛型参数时,可以修改原Pair泛型为&lt;? super Integer&gt;的key,value值.但无法正确接收key,value,只能用Object类型接收.(只写)</p>
</li>
</ol>
<h5 id="pecs原则">PECS原则</h5>
<p>为了方便记忆extends与super的区别,我们引入一个概念<code>PECS:Producer Extends Consumer Super</code>.</p>
<p>即:如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符.</p>
<pre><code class="language-java">public class Collections {
    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {
        for (int i=0; i&lt;src.size(); i++) {
            T t = src.get(i); // src是producer
            dest.add(t); // dest是consumer
        }
    }
}
</code></pre>
<h5 id="通配符">? 通配符</h5>
<pre><code class="language-java">/**
 * 编译错误:不支持的语法
 * class PairGenericUnlimitedClass &lt;?&gt;{}
 */
public class PairGenericUnlimitedClass&lt;T&gt; {

    private final List&lt;T&gt; list;

    public PairGenericUnlimitedClass(List&lt;T&gt; list) {
        this.list = list;
    }

    public static boolean isEmpty(List&lt;?&gt; list){
        return list.size() == 0;
    }

    public static void addElementIfEmpty(List&lt;?&gt; list){
        if(isEmpty(list)){
            //无法通过编译:Required type:capture of ? Provided:int
            //list.add(123);
        }
        Object o = list.get(1);//无法拿任何类型去接受它,只有Object
    }

    public static void main(String[] args){
        PairGenericUnlimitedClass&lt;Integer&gt; pair = new PairGenericUnlimitedClass&lt;&gt;(Arrays.asList(123, 456, 789));
        PairGenericUnlimitedClass&lt;?&gt; newPair = pair;//编译通过
    }
}
</code></pre>
<p>结论:</p>
<ol>
<li>?不能修饰泛型类</li>
<li>?是泛型T的超类</li>
<li>?具有<code>extends</code>和<code>super</code>的特征(无法写;无法读),因为无法读写,一般只能用来判空,所以我们一般用的更多的是直接使用<code>泛型T</code>替代<code>?</code>通配符;</li>
</ol>
<h5 id="不可读与不可写">不可读与不可写</h5>
<p>关于读写问题解读,我的理解是:</p>
<p><strong>不可写</strong>:</p>
<p>可读:当使用<code>? extends T</code>时,<code>泛型T</code>为所有的类型顶点,所有类型都可以向上转型至<code>T类型</code>,我们可以直接这样写<code>T t = ?</code>,拿<code>T类型</code>去接收实例,跟面向接口编程的思想一致,都拿接口去接收实例.那自然都可读,都当做<code>T类型</code>处理.</p>
<p>不可写:假设<code>T类型</code>为<code>Number类型</code>,那么我即可以写入<code>Integer类型</code>,也可以写入<code>Double类型</code>,但是很明显<code>T类型(Number)</code>它不可能同时既是<code>Integer类型</code>又是<code>Double类型</code>,所以说不可写.</p>
<p><strong>不可读</strong>:</p>
<p>可写:当使用<code>? super T</code>时,<code>泛型T</code>为所有类型的底点,<code>T类型</code>是继承于他们的.假设<code>T类型</code>为<code>Integer类型</code>,那我们只能写入<code>Integer类型,Number类型,Object类型</code>.我们可以把他们都转型转为<code>Obejct类型</code>写入.</p>
<p>不可读:正因为我们可以把他们都转型为<code>Object类型</code>写入,那我们最终只能拿<code>Object类型</code>接收,否则你根本不知道你写入的到底是<code>Integer类型</code>和<code>Number类型</code>,所以说不可读.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 反射]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-fan-she/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-fan-she/">
        </link>
        <updated>2021-05-12T06:00:00.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1反射是什么">1.反射是什么</h4>
<p>在Java中,反射是指：可以通过程序在系统运行时(RetentionPolicy.Runtime描述过)，拿到指定对象所有信息。</p>
<h4 id="2为什么需要使用到反射">2.为什么需要使用到反射</h4>
<p>当程序运行时，我们并不知道这个指定对象是否存在，是否有目标属性，目标方法时，就可以通过反射去取得该对象的信息。</p>
<h4 id="3如何使用反射">3.如何使用反射</h4>
<h5 id="javalang提供类">java.lang提供类</h5>
<p>反射的核心包：java.lang.reflect，需要掌握如下标红的几个类</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/image-20210511171129193.png" alt="image-20210511171129193" loading="lazy"></figure>
<p>以及核心的java.lang.Class类。该类提供了在运行时可以获取到类的所有信息。</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/image-20210511171251795.png" alt="image-20210511171251795" loading="lazy"></figure>
<h5 id="掌握内容">掌握内容</h5>
<pre><code class="language-java">	获取Class类对象的三种方式：
    	1.实例对象.getClass();
		2.类名.class;
		3.Class.forName(&quot;实例对象完整类名&quot;);
​	判断Class对象是否相等或有继承关系：
    	1.使用 instanceof 关键字
    	2.使用 class.isAssignableFrom(Class&lt;?&gt; cls)方法
        //使用此方法时需要注意,参数(cls)是被检查对象,看cls是否能强制转型为class对象
        //如:Object.class.isAssignableFrom(Integer.class) == true
        //Integer.class.isAssignableFrom(Object.class) == false
​	获取类对象的属性、构造器、方法：
    	属性：	
    		1.获取类所有public属性(包括父类的所有public属性):class.getFields();
			2.获取类所有属性(不包括父类属性):class.getDeclaredFields();
			3.设置属性的访问权限:Field.setAccessible(boolean flag);
			4.取得/修改属性值:Field.get(属性名);/Filed.set(属性名,属性值);
		构造器：
            //构造器不被继承,所以取不到父类构造器,可以通过getSuperClass获取到父类对象再获取 
            1.获取类所有public构造方法:class.getConstructors();
            2.获取类所有构造方法:class.getDeclaredConstructors();
            3.设置构造器的访问权限:Constructor.setAccessible(boolean flag);
			4.新建构造器:class.getDeclaredConstructor(Paramater.class).newInstance();
		方法:
			1.获取类所有public方法(包括父类的所有public方法):class.getMethods();
			2.获取类所有方法(不包括父类方法):class.getDeclaredMethods();
			3.设置方法的访问权限:Method.setAccessible(boolean flag);
			4.调用方法:Method.invoke(Object obj,Object...args);
			//如果是静态实例,则obj=null,否则需要传入实例;如果是无参方法,则args=null,否则需要传入参数
			//如果是多态实例,则总是调用的是传入实例的覆写方法,而不是父类方法
​	动态加载：
    	JVM并不会一次性加载所有的class文件至内存,而是会在运行时第一次碰到了需要的class文件就加载.
</code></pre>
<h5 id="使用场景">使用场景</h5>
<p>利用动态加载的特性,在JVM运行时判断Class文件是否存在,动态配置JDBC驱动/日志库等</p>
<pre><code class="language-java">/**
 * 根据classpath下是否存在mysql/oracle驱动,选择连接哪个库
 * @throws SQLException
 */
public static void dynamicConnectJDBCDriver() throws SQLException {
    Connection connection = null;
    if(isPresentClass(&quot;com.mysql.jdbc.Driver&quot;)){
        connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;,&quot;test&quot;,&quot;test&quot;);
    }else if(isPresentClass(&quot;oracle.jdbc.driver.OracleDriver&quot;)){
        connection = DriverManager.getConnection(&quot;jdbc:oracle:thin@localhost:1521/test&quot;,&quot;test&quot;,&quot;test&quot;);
    }else{
        //todo:其他库
    }
    Statement statement = connection.createStatement();
    statement.executeQuery(&quot;select * from user&quot;);
    statement.close();
    connection.close();
}

/**
 * 类似commons logging和slf4j的作用-&gt;日志接口,动态检测并使用日志模块
 * 日志接口具体的实现对应关系:commons logging(接口)使用log4j(实现);slf4j(接口)使用logback(实现)
 */
public static void dynamicDispositionLogFactory(){
    LogFactory factory = null;
    if (isPresentClass(&quot;ch.qos.logback.classic.LoggerContext&quot;)) {//logback库
        factory = createLogback();
    } else if(isPresentClass(&quot;org.apache.logging.log4j.Logger&quot;)){//log4j库
        factory = createLog4j();
    }else{//jdk log库
        factory = createJdkLog();
    }
}

/**
 * 不能使用Class.forName()==null来判断是否存在,找不到只会直接抛出ClassNotFoundException异常
 * @param clazzName
 * @return
 */
public static boolean isPresentClass(String clazzName){
    try {
        Class.forName(clazzName);
        return true;
    }catch (ClassNotFoundException e){
        return false;
    }
}
</code></pre>
<p>SpringMVC利用反射给JavaBean(提供private属性,get/set方法)动态赋值,通过请求参数,反射查找JavaBean的属性,调用set方法赋值.</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/test&quot;)
@ResponseBody
public String test(TestVO testVO) { 
  String name= testVO.getName();
}
</code></pre>
<h4 id="4动态代理">4.动态代理</h4>
<h5 id="定义">定义</h5>
<p>动态代理指的是:当jvm运行时,动态创建某个接口(interface)的实例.</p>
<p>(没有.java文件,只有生成的.class文件:public class $Proxy0 extends Proxy implements 接口)</p>
<h5 id="使用方式">使用方式</h5>
<pre><code class="language-java">/**
 * 反射实现动态代理三部曲
 * 1.创建InvocationHandler对象,通过匿名内部类实现invoke方法
 * 2.通过Proxy.newInstance创建Proxy代理对象,传入代理类的classloader,代理类的class数组,和刚刚实现的invoke()方法
 * 3.通过返回的代理对象Object,强制向下转型,调用方法
 */
public class DynamicProxy {

    /**
     * 实现代理对象的抽象方法
     * @return
     */
    public static InvocationHandler invoke(){
        return (proxy, method, args) -&gt; {
            //public abstract void org.pzzhang.reflection.DynamicProxy$Hello.hello()
            System.out.println(method);
            if(Hello.class.getMethod(&quot;hello&quot;).equals(method)){
                System.out.println(&quot;hello world&quot;);
            }
            if(Hello.class.getMethod(&quot;hey&quot;, String.class).equals(method)){
                System.out.println(&quot;hey,&quot;+args[0]);
            }
            return null;
        };
    }
    
    /**
     * 创建代理对象,其中代理对象的方法已经通过InvocationHandler实现
     * 直接将代理对象强制转型为目标对象,调用目标对象的方法即可
     */
    public static void proxyHandler(){
        Hello proxyInstance = (Hello)Proxy.newProxyInstance(Hello.class.getClassLoader(), new Class[]{Hello.class}, invoke());
        proxyInstance.hello();
        proxyInstance.hey(&quot;charles&quot;);
    }

}
interface Hello{
    void hello();
    void hey(String name);
}
</code></pre>
<p>等价于如下静态代理实现类</p>
<pre><code class="language-java">class DynamicProxyStaticImplements implements Hello{

    private final InvocationHandler invocationHandler;

    public DynamicProxyStaticImplements(InvocationHandler invocationHandler) {
        this.invocationHandler = invocationHandler;
    }

    @Override
    public void hello() {
        try {
            invocationHandler.invoke(this,Hello.class.getMethod(&quot;hello&quot;),null);//没有参数,所以args=null
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }

    @Override
    public void hey(String name) {
        try {
            invocationHandler.invoke(this,Hello.class.getMethod(&quot;hey&quot;, String.class),new Object[]{name});
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
    }

    public static void main(String[] args){
        DynamicProxyStaticImplements staticImplements = new DynamicProxyStaticImplements((proxy, method, args1) -&gt; {
            if (Hello.class.getMethod(&quot;hello&quot;).equals(method)) {
                System.out.println(&quot;hello world&quot;);
            }
            if (Hello.class.getMethod(&quot;hey&quot;, String.class).equals(method)) {
                System.out.println(&quot;hey,&quot; + args1[0]);
            }
            return null;
        });
        staticImplements.hello();
        staticImplements.hey(&quot;charles&quot;);
    }
}
</code></pre>
<h5 id="使用场景-2">使用场景</h5>
<p>利用动态代理,对方法增强.在方法执行前后执行事务/输出日志等操作</p>
<pre><code class="language-java">public interface SQL {

    void executeSQL();
}

class Executor implements SQL{

    @Override
    public void executeSQL() {
        Logger.getGlobal().info(&quot;select * from user&quot;);
    }
}

/**
 * 三部曲:
 * 1.创建InvokeHandler对象,处理method方法,进行方法加强(开启/关闭事务,打印输出日志)
 * 2.通过Proxy.newInstance创建代理对象,传入参数
 * 3.转化成实际对象,执行目标方法
 */
class Test{

    private static Logger global = Logger.getGlobal();

    public static InvocationHandler invoke(){
        return (proxy, method, args) -&gt; {
            if(method.equals(SQL.class.getMethod(&quot;executeSQL&quot;))){
                global.info(&quot;开启数据库连接&quot;);
                Connection conn = openConnection();//创建数据库连接
                global.info(&quot;开启事务&quot;);
                conn.setAutoCommit(false);//关闭自动提交
                method.invoke(new Executor());//执行目标SQL
                global.info(&quot;事务处理完毕,提交事务&quot;);
                conn.commit();//提交事务
                global.info(&quot;关闭数据库连接&quot;);
                conn.close();
            }
            return null;
        };
    }

     private static Connection openConnection() {
        try {
            return  DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;,&quot;root&quot;,&quot;123456&quot;);
        } catch (SQLException throwables) {
            throwables.printStackTrace();
            return null;
        }
    }
    
    public static void main(String[] args){
        SQL sql = (SQL)Proxy.newProxyInstance(SQL.class.getClassLoader(), new Class[]{SQL.class}, invoke());
        sql.executeSQL();
    }
}
</code></pre>
<p>执行结果:</p>
<figure data-type="image" tabindex="3"><img src="http://img.zhengjianru.work/%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20210512135749.png" alt="截图_选择区域_20210512135749" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础篇 - 注解]]></title>
        <id>https://nojudgeme.github.io/post/java-ji-chu-pian-zhu-jie/</id>
        <link href="https://nojudgeme.github.io/post/java-ji-chu-pian-zhu-jie/">
        </link>
        <updated>2021-05-07T09:05:28.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1注解是什么">1.注解是什么</h4>
<p>注释: 说明文字,给人看的.</p>
<p>注解: 修饰数据的元数据,给JVM看的.</p>
<p>元注解: 修饰注解的注解.</p>
<h4 id="2为什么要使用注解">2.为什么要使用注解</h4>
<p>当我们希望描述一种数据时,使它能有更多的内容(如修饰词一样).</p>
<h4 id="3如何使用注解">3.如何使用注解</h4>
<p>在使用注解之前,先了解一下几个常见注解.</p>
<h5 id="基本注解javalang包下">基本注解(java.lang包下)</h5>
<p>3.1 @Deprecated</p>
<blockquote>
<p>注释为@Deprecated的程序元素是不鼓励程序员使用的元素。 某个元素可能由于多种原因而被弃用，例如，其使用可能会导致错误； 可能无法兼容地进行更改，或者在将来的版本中将其删除； 它已被更新的，通常更可取的替代方法所取代； 否则它已经过时了。     								  -</p>
<p>​		--来源java.lang.Deprecated注释描述</p>
</blockquote>
<p>简而言之:Deprecated注解用于<strong>标记程序为过时的</strong>.</p>
<p>@FunctionalInterface</p>
<blockquote>
<p>信息性注释类型，用于指示接口类型声明旨在成为Java语言规范定义的功能接口。 从概念上讲，功能接口仅具有一种抽象方法。 由于默认方法具有实现，因此它们不是抽象的。 如果接口声明了一个覆盖java.lang.Object的公共方法之一的抽象方法，则该方法也不计入接口的抽象方法计数，因为该接口的任何实现都将具有java.lang.Object或其他地方的实现。</p>
<p>​		---来源java.lang.FunctionalInterface注释描述</p>
</blockquote>
<p>简而言之:FunctionalInterface注解用于<strong>标记接口为函数式接口</strong>.</p>
<p>3.3 @Override</p>
<blockquote>
<p>指示方法声明旨在覆盖超类型中的方法声明。 如果使用此注释类型对方法进行注释，则除非至少满足以下条件之一，否则要求编译器生成错误消息：<br>
该方法的确覆盖或实现了在超类型中声明的方法。<br>
该方法的签名与Object中声明的任何公共方法的签名等效。</p>
<p>​		---来源java.lang.Override注释描述</p>
</blockquote>
<p>简而言之:Override注解用于<strong>重写父类的方法</strong>.</p>
<p>3.4 @SafeVarargs</p>
<blockquote>
<p>程序员断言带注释的方法或构造函数的主体不会对其varargs参数执行潜在的不安全操作。 将此注释应用于方法或构造函数可抑制有关非可调整变量Arity （vararg）类型的未经检查的警告，并抑制有关在调用站点创建参数化数组的未经检查的警告。<br>
除了其@Target元注释所施加的使用限制外，还要求编译器对此注释类型实施附加的使用限制。 如果用@SafeVarargs批注对方法或构造函数声明进行批注，则编译时错误，并且：<br>
声明是固定的arity方法或构造函数<br>
声明是可变的arity方法，既非static也非final或private 。</p>
<p>@SafeVarargs // Not actually safe!<br>
static void m(List<String>... stringLists) {<br>
Object[] array = stringLists;<br>
List<Integer> tmpList = Arrays.asList(42);<br>
array[0] = tmpList; // Semantically invalid, but compiles without warnings<br>
String s = stringLists[0].get(0); // Oh no, ClassCastException at runtime!<br>
}</p>
<p>​		---来源java.lang.SafeVarargs注释描述</p>
</blockquote>
<p>简而言之:SafeVarargs注解用于<strong>当一个非泛型集合(如Object[])赋值给泛型集合时,发生堆污染</strong>.</p>
<p>3.5 @SuppressWarnings</p>
<blockquote>
<p>指示应在带注释的元素（以及带注释的元素中包含的所有程序元素）中禁止命名的编译器警告。 请注意，在给定元素中禁止显示的警告集是在所有包含元素中禁止显示的警告的超集。 例如，如果您注释一个类以禁止一个警告，并注释一个方法以禁止另一个警告，则两种警告将在该方法中被抑制。 但是，请注意，如果在module-info文件中禁止显示警告，则该禁止适用于文件中的元素，而不适用于模块中包含的类型。<br>
作为样式问题，程序员应始终在最有效嵌套的最深层元素上使用此注释。 如果要在特定方法中禁止显示警告，则应注释该方法而不是其类。</p>
<p>​		---来源java.lang.SuppressWarnings注释描述</p>
</blockquote>
<p>简而言之:SuppressWarnings用于<strong>抑制编译器警告</strong>.</p>
<h5 id="元注解javalangannotation包下">元注解(java.lang.annotation包下)</h5>
<p>3.6 @Documented</p>
<blockquote>
<p>如果注释@Documented出现在注释类型A的声明中，则元素上的任何@A注释@A视为元素公共合同的一部分。 更详细地，当注释类型A与注释Documented ，存在和类型A的注释的值是元素A注释的公共合同的一部分。 相反，如果注释类型B没有带注释Documented ，存在和B的注释的值都不是元件B注释的公共合同的一部分。 具体来说，如果注释类型用Documented注释，则默认情况下，像javadoc这样的工具将在其输出中显示该类型的注释，而没有Documented的注释类型的注释将不显示。</p>
<p>​		---来源java.lang.annotation.Documented注释描述</p>
</blockquote>
<p>简而言之:Documented用于<strong>被@Documented修饰的注解会被javadoc工具输出成文档</strong>.</p>
<p>3.7 @Inherited</p>
<blockquote>
<p>指示注释类型是自动继承的。 如果注释类型声明中存在继承的元注释，并且用户在类声明中查询该注释类型，并且该类声明中没有该类型的注释，则将自动查询该类的超类以获取注释类型。 重复此过程，直到找到该类型的注释或到达类层次结构（对象）的顶部为止。 如果没有超类对此类型进行注释，则查询将指示所讨论的类没有此类注释。<br>
请注意，如果带注释的类型用于注释除类之外的任何内容，则此元注释类型无效。 还要注意，此元注释仅使注释从超类继承； 已实现的接口上的注释无效。</p>
<p>​		---来源java.lang.annotation.Inherited注释描述</p>
</blockquote>
<p>简而言之:Inherited用于<strong>被修饰的注解将会被子类继承</strong>.</p>
<p>3.8 @Repeatable</p>
<blockquote>
<p>注释类型java.lang.annotation.Repeatable用于指示其声明（元（meta-））注释的注释类型可重复。 @Repeatable的值表示可重复注释类型的包含注释类型。</p>
<p>​		---来源java.lang.annotation.Repeatable注释描述</p>
</blockquote>
<p>简而言之：Repeatable用于<strong>被修饰的注解可以重复使用</strong>.</p>
<p>3.9 @Retention</p>
<blockquote>
<p>指示带注释类型的注释将保留多长时间。 如果注释类型声明上没有保留注释，则保留策略默认为RetentionPolicy.CLASS 。<br>
仅当元注释类型直接用于注释时，保留元注释才有效。 如果将元注释类型用作另一注释类型的成员类型，则无效。</p>
<p>​		---来源java.lang.annotation.Retention注释描述</p>
</blockquote>
<p>简而言之：Retention用于<strong>决定被修饰的注解的生命周期</strong>.</p>
<p>3.10 @Target</p>
<blockquote>
<p>指示注释类型适用的上下文。 在JLS 9.6.4.1中指定了可以在其中应用注释类型的声明上下文和类型上下文，并在源代码中用java.lang.annotation.ElementType的枚举常量表示。<br>
如果在注释类型T上不存在@Target元注释，则可以将类型T的注释写为除类型参数声明之外的任何声明的修饰符。<br>
如果存在@Target元注释，则编译器将强制执行ElementType枚举常量指示的使用限制，以符合JLS 9.7.4的要求。</p>
<p>​		---来源java.lang.annotation.Target注释描述</p>
</blockquote>
<p>简而言之：Target用于<strong>指定被修饰的注解用在可以修饰的地方</strong>.</p>
<h5 id="补充说明">补充说明</h5>
<p>上述说到，Retention用于<strong>决定被修饰的注解的生命周期</strong>.其中RetentionPolicy定义了三个生命阶段</p>
<pre><code class="language-java">public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}
</code></pre>
<p>RetentionPolicy.SOURCE：注解被编译器使用，只存在于.java文件，不会进入到.class文件，被编译后(javac)成.class文件后擦除。</p>
<p>RetentionPolicy.CLASS：注解被.class文件使用，不会进入到JRE(Java Runtime Environment)中。</p>
<p>RetentionPolicy.RUNTIME：注解会在程序运行时读取到，一直存在于JVM中，也是我们最常用以及自定义注解时需要指明的注解生命周期。</p>
<p>Java文件的编译流程：</p>
<figure data-type="image" tabindex="1"><img src="http://img.zhengjianru.work/dyo3u7g3go.png" alt="dyo3u7g3go" loading="lazy"></figure>
<p>其中source-&gt;compiler过程：</p>
<figure data-type="image" tabindex="2"><img src="http://img.zhengjianru.work/321arjo9gz.png" alt="321arjo9gz" loading="lazy"></figure>
<p>整个编译-&gt;执行过程：source(java源代码)-&gt;parse(分析和输入到符号表)-&gt;processor(注解处理器)-&gt;analyse(分析语义)-&gt;generate(生成文件)-&gt;javac(编译)-&gt;字节码-&gt;classload(类加载)-&gt;JIT-&gt;机器码-&gt;目标机器执行</p>
<p>如果想在RetentionPolicy.class周期时获取到注解信息，需要继承AbstractProcessor类，实现process功能.(Lombok 生成get/set方法实现方式)</p>
<h5 id="自定义注解">自定义注解</h5>
<p>元注解：</p>
<pre><code class="language-java">/**
 * 元注解:修饰注解的注解
 * 即Target为ElementType.ANNOTATION_TYPE
 * 对注解进行标记,说明
 * JDK提供的元注解在java.lang.annotation包下,一共有5个      			(Documented,Inherited,Repeatable,Retention,Target)
 * 其中Native注解较为特殊,使用@Target(ElementType.FIELD)
 * 另外:所有注解都隐式继承java.lang.annotation.Annotation接口
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface MetaAnnotation {
}
</code></pre>
<p>普通注解：</p>
<pre><code class="language-java">/**
 * 注解:修饰数据的元数据
 * 即Target为除了(ElementType.ANNOTATION_TYPE)之外的ElementType
 * 对数据进行标记,说明
 * JDK提供的注解在java.lang包下
 */
@Retention(RetentionPolicy.RUNTIME) //Retention注解决定了该注解的生命周期,默认值RetentionPolicy.CLASS,详见Retention.class注释
@Target({ElementType.CONSTRUCTOR,ElementType.PARAMETER}) //target注解决定了该注解的使用范围
@MetaAnnotation
public @interface MyAnnotation {

    /**
     * 注解不能使用除(String,基本数据类型,Class,枚举,数组,注解)以外的数据类型
     */

    String name();

    int age() default 18; //default指定了缺省值

    //Class clazz();
    //ElementType TYPE();
    //int[] numbs();
    //Retention RETENTION();
    //Integer age();  无法通过编译
}
</code></pre>
<p>特殊注解：</p>
<pre><code class="language-java">/**
 * 当注解只有一个成员变量,且属性名为value时,赋值时不用显示声明value=XX
 */
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation2 {

    String value();
}
</code></pre>
<h5 id="使用注解">使用注解</h5>
<pre><code class="language-java">public class Human {

    private String name;

    private int age;

    @MyAnnotation(name = &quot;jarvis&quot;)
    public Human() {
        for (Constructor&lt;?&gt; constructor : Human.class.getConstructors()) {
            if (constructor.isAnnotationPresent(MyAnnotation.class)) {
                MyAnnotation annotation = constructor.getAnnotation(MyAnnotation.class);
                this.name = annotation.name();
                this.age = annotation.age();
            }
        }
    }

    public Human(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Human resetHuman(@MyAnnotation(name = &quot;huffman&quot;, age = 22) Human human) throws NoSuchMethodException {
        Method resetHuman = Human.class.getMethod(&quot;resetHuman&quot;, Human.class);
        for (Annotation[] parameterAnnotation : resetHuman.getParameterAnnotations()) {
            for (Annotation annotation : parameterAnnotation) {
                if (annotation instanceof MyAnnotation) {
                    MyAnnotation myAnnotation = (MyAnnotation) annotation;
                    String name = myAnnotation.name();
                    int age = myAnnotation.age();
                    return new Human(name, age);
                }
            }
        }
        return null;
    }

    @MyAnnotation2(&quot;test&quot;)
    public String getValue() throws NoSuchMethodException {
        Method getValue = Human.class.getMethod(&quot;getValue&quot;);
        return getValue.getAnnotation(MyAnnotation2.class).value();
    }

    @Override
    public String toString() {
        return &quot;Human{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }

    public static void main(String[] args) throws NoSuchMethodException {
        Human human = new Human();
        //System.out.println(human); 输出Human{name='jarvis', age=18}
        human = human.resetHuman(human);
        //System.out.println(human); 输出Human{name='huffman', age=22}
        //System.out.println(human.getValue()); 输出test
    }
}
</code></pre>
<h4 id="4总结">4.总结</h4>
<p>1.注解是用于修饰数据的一种特殊标记，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p>
<p>2.当我们需要给程序添加标注时，可以使用注解。</p>
<p>3.java.lang包提供了基础注解和元注解，元注解用于修饰注解。</p>
<p>4.注解有三个生命周期：源码时(source)，Class文件时(class)，运行时(Runtime)。我们常常自定义注解需要在运行时通过反射获取，通过程序对获取到的注解实现相应功能。</p>
<p>5.如果想利用java文件在编译过程中，利用注解实现功能，可以考虑通过继承AbstractProcessor类，实现process功能来完成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零开始学算法 - 队列]]></title>
        <id>https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-dui-lie/</id>
        <link href="https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-dui-lie/">
        </link>
        <updated>2021-04-09T02:42:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">/**
 * Functional Purpose - 队列 先进先出数据结构 FIFO(first in first out)
 * @date:2021-04-08 下午4:01
 * @author huffman
*/
public interface Queue&lt;E&gt; {

    /**
     * 元素入队尾
     * @param e
     */
    void enqueue(E e);

    /**
     * 元素出队首
     * @return
     */
    E dequeue();

    /**
     * 获取队首元素
     * @return
     */
    E getFront();

    /**
     * 获取队列元素总个数
     * @return
     */
    int getSize();

    /**
     * 判断队列元素是否为空
     * @return
     */
    boolean isEmpty();
}

/**
 * Functional Purpose - 动态数组实现队列
 *
 * @author huffman
 * @date:2021-04-08 下午4:05
 */
public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; {

    private Arrays&lt;E&gt; data;

    public ArrayQueue() {
        data = new Arrays();
    }

    public ArrayQueue(int capacity) {
        data = new Arrays(capacity);
    }

    @Override
    public void enqueue(E e) {
        data.addLast(e);
    }

    @Override
    public E dequeue() {
        return data.removeFirst();
    }

    @Override
    public E getFront() {
        return data.getFirstElement();
    }

    @Override
    public boolean isEmpty() {
        return data.isEmpty();
    }

    @Override
    public int getSize() {
        return data.getSize();
    }

    public int getCapacity(){
        return data.getCapacity();
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format(&quot;ArrayQueue: size = %d , capacity = %d\n&quot;,getSize(),getCapacity()));
        res.append(&quot;front:[&quot;);
        for (int i = 0; i &lt; getSize(); i++) {
            res.append(data.getElement(i));
            if(i!=getSize()-1){
                res.append(&quot; ,&quot;);
            }
        }
        res.append(&quot;]tail&quot;);
        return res.toString();
    }

    public static void main(String[] args) {
        Queue&lt;Integer&gt; queue = new ArrayQueue&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            queue.enqueue(i);
            System.out.println(queue);
            if (i % 3 == 2) {
                queue.dequeue();
                System.out.println(queue);
            }
        }
    }
}

/**
 * Functional Purpose -  循环队列
 * 以牺牲一个空间,头部和尾部索引循环,得到循环队列
 * 当头部等于尾部时,认为该队列为空;当头部等于(尾部+1)/总容量时,认为该队列已满
 *
 * @author huffman
 * @date:2021-04-08 下午4:55
 */
public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; {

    /**
     * 数组存储元素
     */
    private E[] data;

    /**
     * 下标的头部,尾部
     */
    private int front, tail;

    /**
     * 元素总个数
     */
    private int size;

    /**
     * 扩容因子
     */
    private int resizeFactor = 2;

    public LoopQueue(int capacity) {
        data = (E[]) new Object[capacity + 1];
        front = 0;
        tail = 0;
        size = 0;
    }

    public LoopQueue() {
        this(10);
    }

    @Override
    public void enqueue(E e) {
        //先看容量大小,需不需要扩容
        if ((tail + 1) % data.length == front) {
            resize(resizeFactor * getCapacity());
        }
        //维护队尾下标和元素总数
        data[tail] = e;
        tail = (tail + 1) % data.length;
        size++;
    }

    @Override
    public E dequeue() {
        //如果容器中无元素,则直接抛出异常
        if (isEmpty()) {
            throw new IllegalArgumentException(&quot;The queue is empty,no element can be dequeue&quot;);
        }
        //维护队首下标和元素总数
        E e = data[front];
        data[front] = null;
        front = (front + 1) % data.length;
        size--;
        //看容量大小,需不需要扩容,这里也采用懒缩容的方式,避免复杂度震荡,增加复杂度
        if (size == getCapacity() / resizeFactor / 2) {
            resize(getCapacity() / resizeFactor);
        }
        return e;
    }

    @Override
    public E getFront() {
        if (isEmpty()) {
            throw new IllegalArgumentException(&quot;The queue is empty.&quot;);
        }
        return data[front];
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return front == tail;
    }

    public int getCapacity() {
        return data.length - 1;
    }

    private void resize(int newCapacity) {
        E[] newData = (E[]) new Object[newCapacity + 1];
        //挪动元素
        for (int i = 0; i &lt; size; i++) {
            newData[i] = data[(front + i) % data.length];
        }
        data = newData;
        front = 0;//头下标 从0开始
        tail = size;//尾下标 从最后的元素开始
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append(String.format(&quot;LoopQueue: size = %d , capacity = %d\n&quot;, getSize(), getCapacity()));
        res.append(String.format(&quot;front [&quot;));
        for (int i = front; i != tail; i = (i + 1) % data.length) {
            res.append(data[i]);
            if ((i + 1) % data.length != tail) {
                res.append(&quot;, &quot;);
            }
        }
        res.append(String.format(&quot;] tail&quot;));
        return res.toString();
    }

    public static void main(String[] args) {
        Queue&lt;Integer&gt; queue = new LoopQueue&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            queue.enqueue(i);
            System.out.println(queue);
            if (i % 3 == 2) {
                queue.dequeue();
                System.out.println(queue);
            }
        }
    }
}
</code></pre>
<blockquote>
<p>注意事项:</p>
<p>1.同样的,无论队列的数据结构实现是什么,用户并不关心,只用知道如何操作队列元素即可(入队:enqueue;出队:dequeue;查看队首元素:front).</p>
<p>2.此处队列提供了两种实现方式:以动态数组的方式实现与以循环数组的方式实现.</p>
<p>优缺点比较:</p>
<p>动态数组优点:直接采用动态数组为底层数据结构,直接复用Arrays代码,通过Arrays的增加/删除元素操作队列进行入队/出队操作.实现起来十分简单.</p>
<p>动态数组缺点:进行出队操作时,需要将头元素以后的元素往前挪一位,时间复杂度表现为O(n),性能较差.</p>
<p>循环数组优点:进行出队操作时,只需维护Front头元素的下标信息,指向下一个下标即可,时间复杂度表现为O(1),性能优秀.</p>
<p>循环数组缺点:需要实现新的数据结构-循环数组,在进行出队/入队操作时,需要维护front/tail信息,增加了理解难度.</p>
<p>3.循环数组的实现逻辑:可以想象一个时钟,刻度为12(capacity),头元素为0,尾元素最大值为11(capacity-1),当尾元素到达12时,也同时指向0. 可以理解为该时钟又从零开始 : 即 当头元素=尾元素时,该数组为空;当尾元素=11(capacity-1)时,最大,同时该数组应该扩容. 注意:capacity+1 = length!</p>
<p>4.循环数组牺牲了一个空间,为了保证该数组容积大小等于初始化时的容积大小,故在初始化时需要将指定容积大小+1,所以当获取该容积时,需要将数组长度-1时,才能符合用户预期输入时的容积大小.进行循环时,实际还是得除以数组的实际容积大小,才能保证循环.</p>
<p>5.循环操作:front = (front+1)/length;tail = (tail+1)/length.  只有除以了length,才能保证front、tail永远小于length,故在一个数组长度内进行循环</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零开始学算法 - 栈]]></title>
        <id>https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-zhan/</id>
        <link href="https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-zhan/">
        </link>
        <updated>2021-04-09T02:42:03.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">/**
 * Functional Purpose - 栈 后进先出数据结构 LIFO(Last in First Out)
 * @date:2021-04-08 上午11:31
 * @author huffman
*/
public interface Stack&lt;E&gt; {

    /**
     * 元素入栈尾
     * @param e
     */
    void push(E e);

    /**
     * 元素出栈尾
     * @return
     */
    E pop();

    /**
     * 获取栈尾元素
     * @return
     */
    E peek();

    /**
     * 获取栈内元素总个数
     * @return
     */
    int getSize();

    /**
     * 判断栈元素是否为空
     * @return
     */
    boolean isEmpty();
}

/**
 * Functional Purpose - 动态数组的方式实现栈
 * @date:2021-04-08 上午11:54
 * @author huffman
*/
public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt;{

    private final Arrays&lt;E&gt; arrays;

    public ArrayStack() {
        arrays = new Arrays&lt;&gt;();
    }

    public ArrayStack(int capacity){
        arrays = new Arrays&lt;&gt;(capacity);
    }

    @Override
    public void push(E e) {
        arrays.addLast(e);
    }

    @Override
    public E pop() {
        return arrays.removeLast();
    }

    @Override
    public E peek() {
        return arrays.getLastElement();
    }

    @Override
    public int getSize() {
        return arrays.getSize();
    }

    @Override
    public boolean isEmpty() {
        return arrays.isEmpty();
    }

    public int getCapacity(){
        return arrays.getCapacity();
    }

    @Override
    public String toString() {
        return &quot;ArrayStack{&quot; +
                &quot;arrays=&quot; + arrays +
                '}';
    }

}
</code></pre>
<blockquote>
<p>注意事项:</p>
<p>1.无论栈的数据结构实现是什么,用户并不关心,只用知道如何操作栈元素即可(入栈:push,出栈:pop,查看栈顶元素:peek).</p>
<p>2.基于动态数组实现的栈十分简单,进行栈元素操作时,直接使用动态数组提供的添加/删除元素操作,就可以实现栈元素的操作.但需要注意的是,栈是FILO(先进后出 first in last out)或者是LIFO(后进先出 last in first out),故在添加/删除栈元素时,是入头元素和出头元素.这一点与队列相反!</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零开始学算法 - 数组]]></title>
        <id>https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-shu-zu/</id>
        <link href="https://nojudgeme.github.io/post/cong-ling-kai-shi-xue-suan-fa-shu-zu/">
        </link>
        <updated>2021-04-09T02:33:05.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">/**
 * Functional Purpose - 动态数组 类似java.util.ArrayList
 *
 * @author huffman
 * @date:2021-04-06 下午5:26
 */
public class Arrays&lt;E&gt; {

    /**
     * 初始化数组数据
     */
    private E[] data;

    /**
     * 数组实际容量
     */
    private int size;

    /**
     * 扩容因子
     */
    private int resizeFactor = 2;

    /**
     * 以数组e初始化数组
     *
     * @param e 数组
     */
    public Arrays(E[] e) {
        this.data = e;
    }

    /**
     * 以最大容量为capacity初始化数组
     *
     * @param capacity 最大容量
     */
    public Arrays(int capacity) {
        data = (E[]) new Object[capacity];
        size = 0;
    }

    /**
     * 以默认容量10初始化数组
     */
    public Arrays() {
        this(10);
    }

    /**
     * 数组内元素是否为空
     *
     * @return
     */
    public boolean isEmpty() {
        return this.size == 0;
    }

    /**
     * 获取实际元素个数
     *
     * @return
     */
    public int getSize() {
        return size;
    }

    /**
     * 获取最大容量大小
     */
    public int getCapacity() {
        return data.length;
    }

    /**
     * 从指定位置插入元素
     */
    public void addElement(E e, int index) {
        checkIndex(index);
        //实际存储元素的容量已经满了
        if (size == data.length) {
            resize(resizeFactor * getCapacity());
        }
        //从下标为size-1的元素开始 从后往前挪动一位元素,即index+1的元素=index的元素
        for (int i = size - 1; i &gt;= index; i--) {
            data[i + 1] = data[i];
        }
        data[index] = e;
        size++;
    }

    /**
     * 从末尾新增元素
     */
    public void addLast(E e) {
        addElement(e, size);
    }

    /**
     * 从头尾新增元素
     */
    public void addFirst(E e) {
        addElement(e, 0);
    }

    /**
     * 获取指定下标元素
     *
     * @param index
     * @return
     */
    public E getElement(int index) {
        checkIndex(index);
        return data[index];
    }

    /**
     * 获取最后一个元素
     * @return
     */
    public E getLastElement() {
        return getElement(size-1);
    }

    /**
     * 获取第一个元素
     * @return
     */
    public E getFirstElement() {
        return getElement(0);
    }

    /**
     * 修改指定下标元素为e
     *
     * @param e
     * @param index
     */
    public void setElement(E e, int index) {
        checkIndex(index);
        data[index] = e;
    }

    /**
     * 检查下标
     *
     * @param index
     */
    public void checkIndex(int index) {
        //下标不能为负且数组得是连续的元素 所以也不能大于size,不然中间会出现空缺元素
        if (index &lt; 0 || index &gt; size) {
            throw new IllegalArgumentException(&quot;AddElement failed. The index can't be less then 0 or more than capacity&quot;);
        }
    }

    /**
     * 检查数组中是否包含元素e
     *
     * @param e
     * @return
     */
    public boolean contains(E e) {
        for (int i = 0; i &lt; size; i++) {
            if (data[i].equals(e)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 寻找数组中e元素的下标,若没有则返回-1
     *
     * @param e
     * @return
     */
    public int findElement(E e) {
        for (int i = 0; i &lt; size; i++) {
            if (data[i].equals(e)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 寻找数组中所有e元素的下标
     *
     * @param e
     * @return todo:不对 需要调整或删除
     */
    @Deprecated
    public int[] findAllElements(E e) {
        int[] indexArray = new int[size];
        int index = 0;
        for (int i = 0; i &lt; size; i++) {
            if (data[i].equals(e)) {
                indexArray[index++] = i;
            }
        }
        return indexArray;
    }

    /**
     * 删除数组中指定下标的元素,返回删除后的元素
     *
     * @param index
     * @return
     */
    public E remove(int index) {
        checkIndex(index);
        E e = data[index];
        for (int i = index+1; i &lt; size; i++) {
            data[i-1] = data[i];
        }
        size--;

        if (size &lt;= getCapacity() / resizeFactor / 2 &amp;&amp; getCapacity() / 2 != 0) {//懒处理 不及时缩容
            resize(getCapacity() / resizeFactor);
        }
        return e;
    }

    /**
     * 删除数组中第一个元素
     *
     * @return
     */
    public E removeFirst() {
        return remove(0);
    }

    /**
     * 删除数组中最后一个元素
     *
     * @return
     */
    public E removeLast() {
        return remove(size - 1);
    }

    /**
     * 删除一个元素e
     *
     * @param e
     */
    public void removeElement(E e) {
        if (contains(e)) {
            int index = findElement(e);
            remove(index);
        }
    }

    /**
     * 删除所有元素e
     *
     * @param e todo:不对 需要调整或删除
     */
    @Deprecated
    public void removeAllElements(E e) {
        if (contains(e)) {
            for (Integer index : findAllElements(e)) {
                remove(index);
            }
        }
    }

    @Override
    public String toString() {
        return &quot;Arrays{&quot; +
                &quot; size=&quot; + size +
                &quot;, capacity=&quot; + data.length +
                &quot;,data=&quot; + java.util.Arrays.toString(data) +
                '}';
    }

    private void resize(int newCapacity) {
        E[] newArray = (E[]) new Object[newCapacity];
        for (int i = 0; i &lt; size; i++) {
            newArray[i] = data[i];
        }
        data = newArray;
    }

}
</code></pre>
<blockquote>
<p>注意事项:</p>
<p>1.在指定下标操作元素时,要注意下标是否越界</p>
<p>2.在增加/删除元素时,要注意数组的大小,满了就扩容,少了就缩容.缩容时,要避免出现刚扩容后,立马缩容的情况,这样会增加时间复杂度,所以这里我们粗略的采用:当元素总数为容积的<strong>1/4</strong>时,进行容积的<strong>1/2</strong>缩容.</p>
<p>3.同时,增加/删除元素时,要同时维护元素总数(size)</p>
<p>4.扩容时复制元素至新数组,容量大小为 resizeFactor*capacity</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些有趣的事情]]></title>
        <id>https://nojudgeme.github.io/post/yi-xie-you-qu-de-shi-qing/</id>
        <link href="https://nojudgeme.github.io/post/yi-xie-you-qu-de-shi-qing/">
        </link>
        <updated>2021-01-18T10:12:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id=""></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[鸟哥的私房菜-Linux(基础学习篇)]]></title>
        <id>https://nojudgeme.github.io/post/niao-ge-de-si-fang-cai-linuxji-chu-xue-xi-pian/</id>
        <link href="https://nojudgeme.github.io/post/niao-ge-de-si-fang-cai-linuxji-chu-xue-xi-pian/">
        </link>
        <updated>2021-01-15T04:21:25.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/1.html">鸟哥的私房菜:基础学习篇 第四版</a><br>
<a href="https://www.processon.com/view/link/5faa4716e0b34d7a1aa28933" target="_blank"><br>
<img src="http://assets.processon.com/chart_image/5f59820c07912902cf7ed0a6.png"/><br>
</a></p>
]]></content>
    </entry>
</feed>